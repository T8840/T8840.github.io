{"meta":{"title":"Neal's World","subtitle":"","description":null,"author":"Neal.Wang","url":"https://t8840.github.io/project","root":"/"},"pages":[{"title":"","date":"2023-03-01T06:23:50.409Z","updated":"2023-03-01T06:23:50.409Z","comments":true,"path":"package.json","permalink":"https://t8840.github.io/project/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-03-01T06:23:50.262Z","comments":true,"path":"about/index.html","permalink":"https://t8840.github.io/project/about/index.html","excerpt":"","text":""},{"title":"","date":"2023-03-01T06:23:50.403Z","updated":"2023-03-01T06:23:50.403Z","comments":true,"path":"manifest.json","permalink":"https://t8840.github.io/project/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaの小窝\",\"short_name\":\"Ariasakaの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2023-03-01T06:23:50.264Z","comments":true,"path":"bangumis/index.html","permalink":"https://t8840.github.io/project/bangumis/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-01-29T07:23:17.000Z","updated":"2023-03-01T06:23:50.268Z","comments":true,"path":"fcircle/index.html","permalink":"https://t8840.github.io/project/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-03-01T06:23:50.267Z","comments":true,"path":"categories/index.html","permalink":"https://t8840.github.io/project/categories/index.html","excerpt":"","text":""},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-03-01T06:23:50.269Z","comments":true,"path":"fontawesome/index.html","permalink":"https://t8840.github.io/project/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"小空调","date":"2022-11-24T23:37:35.000Z","updated":"2023-03-01T06:23:50.402Z","comments":true,"path":"kongtiao/index.html","permalink":"https://t8840.github.io/project/kongtiao/index.html","excerpt":"","text":""},{"title":"声明","date":"2022-07-10T03:13:49.000Z","updated":"2023-03-01T06:23:50.402Z","comments":true,"path":"license/index.html","permalink":"https://t8840.github.io/project/license/index.html","excerpt":"","text":"Copyright© LYX 2022 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"友链","date":"2022-07-03T12:40:57.000Z","updated":"2023-03-01T06:23:50.403Z","comments":true,"path":"links/index.html","permalink":"https://t8840.github.io/project/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 我的信息Butterfly & MengDfluidvolantishtml12345- name: Ariasakaの小窝 link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: 人有悲欢离合 月有阴晴圆缺 siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;Ariasakaの小窝&#x27;, intro: &#x27;人有悲欢离合 月有阴晴圆缺&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: Ariasakaの小窝 avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: 个人博客 description: 人有悲欢离合 月有阴晴圆缺1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;Ariasakaの小窝&lt;/a&gt; 推荐标签衡量标准1.网站没有不良内容 2.文章质量较高 3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"好听的音乐","date":"2022-07-14T08:37:40.000Z","updated":"2023-03-01T06:23:50.406Z","comments":true,"path":"musics/index.html","permalink":"https://t8840.github.io/project/musics/index.html","excerpt":"","text":"好听的歌 歌曲排行榜 博主会每隔一段时间将自己近期爱听的歌排行在下面 2022-7 咕咕咕…"},{"title":"","date":"2023-03-01T06:23:50.404Z","updated":"2023-03-01T06:23:50.404Z","comments":true,"path":"messageboard/index.html","permalink":"https://t8840.github.io/project/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件lyxof2010@yisous.xyz寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | Ariasakaの小窝';"},{"title":"敲木鱼","date":"2022-11-25T00:16:09.000Z","updated":"2023-03-01T06:23:50.407Z","comments":true,"path":"muyu/index.html","permalink":"https://t8840.github.io/project/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-03-01T06:23:50.412Z","comments":true,"path":"tags/index.html","permalink":"https://t8840.github.io/project/tags/index.html","excerpt":"","text":""},{"title":"说说","date":"2023-03-01T06:23:50.412Z","updated":"2023-03-01T06:23:50.412Z","comments":true,"path":"speaks/index.html","permalink":"https://t8840.github.io/project/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | Ariasakaの小窝'; bbtalk.init({ appId: \"\", appKey: \"\", serverURLs: '', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"分站","date":"2022-08-04T03:38:05.000Z","updated":"2023-03-01T06:23:50.409Z","comments":true,"path":"othersite/index.html","permalink":"https://t8840.github.io/project/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"工具","date":"2022-07-13T07:23:02.000Z","updated":"2023-03-01T06:23:50.413Z","comments":true,"path":"tools/index.html","permalink":"https://t8840.github.io/project/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"早报","date":"2022-11-24T23:37:35.000Z","updated":"2023-03-01T06:23:50.415Z","comments":true,"path":"zaobao/index.html","permalink":"https://t8840.github.io/project/zaobao/index.html","excerpt":"","text":""},{"title":"网站更新日志","date":"2022-07-02T11:56:00.000Z","updated":"2023-03-01T06:23:50.414Z","comments":true,"path":"update/index.html","permalink":"https://t8840.github.io/project/update/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做Acryple，具体见： 引用站外地址 博客正式独立主题啦！ Ariasakaの小窝 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"量化交易","date":"2023-02-15T04:00:00.000Z","updated":"2023-03-01T06:23:50.413Z","comments":true,"path":"trade/index.html","permalink":"https://t8840.github.io/project/trade/index.html","excerpt":"","text":""},{"title":"Web3","date":"2023-02-15T04:00:00.000Z","updated":"2023-03-01T06:23:50.414Z","comments":true,"path":"web3/index.html","permalink":"https://t8840.github.io/project/web3/index.html","excerpt":"","text":""},{"title":"正念","date":"2023-02-15T04:00:00.000Z","updated":"2023-03-01T06:23:50.406Z","comments":true,"path":"mindfulness/index.html","permalink":"https://t8840.github.io/project/mindfulness/index.html","excerpt":"","text":"何谓正念 正念冥想是培养执行控制的理想心理工具，包含两大方面:觉察当下和接纳情绪！ 正念分为三大类: 专注力 正念觉察 慈悲冥想 练习正念 保持正念去做所有事，认知隔离放下。 不再企图采取行动摆脱或避免不想要的体验，而是接触它承认它的存在，然后转移到当下的事情上，不再习惯性的把自己放在世界的中心，而是采纳观察的我，这样的我有着不断变化的体验，可以与其体验相分离。 认知隔离是指接纳想法本质上只是词语和感觉，并不是想法所表述的东西。认知隔离让我们避免听信想法和感觉并据此采取行动。我们不是努力改变或消除这些想法和感觉，只是放下。"}],"posts":[{"title":"Solidity资料","slug":"SolidityMaterial","date":"2023-03-01T13:22:05.000Z","updated":"2023-03-01T13:22:05.000Z","comments":true,"path":"posts/77571803/","link":"","permalink":"https://t8840.github.io/project/posts/77571803/","excerpt":"","text":"视频 文字版 项目","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/project/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/project/tags/Solidity/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-03-01T06:23:50.261Z","updated":"2023-03-01T06:23:50.262Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://t8840.github.io/project/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Solidity","slug":"Solidity","date":"2023-02-26T14:05:05.000Z","updated":"2023-02-26T14:05:05.000Z","comments":true,"path":"posts/b9a928cc/","link":"","permalink":"https://t8840.github.io/project/posts/b9a928cc/","excerpt":"","text":"Solidity是一种基于以太坊区块链的智能合约编程语言，它具有类似于JavaScript和C++的语法和特性。 Solidity入门语法 注释 Solidity支持两种注释方式，单行注释和多行注释。单行注释使用//，多行注释使用/* */。 123456// 这是单行注释/*这是多行注释*/ 变量和数据类型 Solidity支持多种数据类型，包括布尔型、整型、地址、字符串和数组等。 布尔型 布尔型表示逻辑值，只有两个可能的值，即true和false。 123bool a = true;bool b = false; 整型 整型表示整数值，可以分为有符号整型和无符号整型。 123int a = 123; // 有符号整型uint b = 456; // 无符号整型 地址 地址类型表示以太坊账户的地址，它是一个20字节的值。 12address a = 0x1234567890123456789012345678901234567890; 字符串 字符串类型表示文本值。 12string a = &quot;Hello World!&quot;; 数组 数组表示具有相同类型的值的有序集合。 123uint[] a = [1, 2, 3];string[] b = [&quot;Hello&quot;, &quot;World&quot;]; 函数 Solidity中的函数可以接受参数和返回值。函数使用function关键字声明，可以指定函数的可见性和修饰符。 1234function add(uint a, uint b) public pure returns (uint) &#123; return a + b;&#125; 上面的代码定义了一个名为add的函数，它接受两个无符号整型参数a和b，返回它们的和。public表示该函数可以被外部调用，pure表示该函数不会读取或修改合约状态。 控制流 Solidity支持条件语句和循环语句。 条件语句 条件语句使用if和else关键字。 12345678uint a = 10;if (a &gt; 5) &#123; // 如果a大于5，执行这里的代码&#125; else &#123; // 否则执行这里的代码&#125; 循环语句 循环语句使用for和while关键字。 123456789101112for (uint i = 0; i &lt; 10; i++) &#123; // 执行10次循环&#125;uint i = 10;while (i &gt; 0) &#123; // 执行10次循环 i--;&#125; 结构体 结构体表示一种自定义数据类型，可以包含多个字段。 1234567struct Person &#123; string name; uint age;&#125;Person p = Person(&quot;Alice&quot;, 20); 上面的代码定义了一个名为Person的结构体，它包含两个字段：name和age。然后我们创建了一个名为p的Person类型的实例。 123456789101112131415161718192021222324252627pragma solidity ^0.8.0;contract Example &#123; struct Person &#123; string name; uint age; bool isAdult; &#125; Person public alice; constructor() &#123; alice.name = &quot;Alice&quot;; alice.age = 30; alice.isAdult = true; &#125; function setAge(uint age) public &#123; alice.age = age; if (age &gt;= 18) &#123; alice.isAdult = true; &#125; else &#123; alice.isAdult = false; &#125; &#125;&#125; 上面的代码定义了一个名为Person的结构体，包含三个字段：name（字符串类型）、age（无符号整数类型）和isAdult（布尔类型）。合约还包含一个名为alice的公共状态变量，其类型为Person，可以用来存储一个人的姓名、年龄和成年状态。合约还定义了一个名为setAge的函数，用于设置alice的年龄，并根据年龄计算其成年状态。 映射 映射表示一种将键映射到值的数据结构。 1234mapping(address =&gt; uint) balances;balances[0x1234567890123456789012345678901234567890] = 100; 上面的代码定义了一个名为balances的映射，它将地址映射到无符号整型。然后我们将地址0x1234567890123456789012345678901234567890的值设置为100。 123456789101112131415pragma solidity ^0.8.0;contract Example &#123; mapping(address =&gt; uint) public balances; function deposit() public payable &#123; balances[msg.sender] += msg.value; &#125; function withdraw(uint amount) public &#123; require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;); payable(msg.sender).transfer(amount); balances[msg.sender] -= amount; &#125;&#125; 上面的代码定义了一个名为balances的映射，将每个地址映射到一个无符号整数值上，表示该地址的余额。合约还定义了两个函数： deposit：允许发送以太币到合约地址，并将其存入发送方的余额中。 withdraw：允许发送方从其余额中取出指定数量的以太币。 在deposit和withdraw函数中，合约使用了msg.sender来引用当前交易的发送方地址，将其余额增加或减少，并使用require函数来确保余额不会变为负数。如果检查失败，函数会抛出一个错误消息，并停止执行。 映射是Solidity中的一项强大功能，可用于创建各种数据结构，如哈希表、关联数组等。在实际开发中，映射通常会更加复杂，并使用更高级的技术来确保其安全性和正确性 事件 Solidity中的事件是一种机制，用于在合约执行期间将通知发送给区块链上的其他应用程序。事件通常用于跟踪合约执行的状态变化，如交易成功或失败，合约状态更改等。 1234567event Transfer(address indexed from, address indexed to, uint value);function transfer(address to, uint value) public returns (bool) &#123; emit Transfer(msg.sender, to, value); return true;&#125; 上面的代码定义了一个名为Transfer的事件，它包含三个参数：from、to和value。然后我们在transfer函数中调用Transfer事件，记录转账操作。 另一个简单的事件示例： 123456789101112pragma solidity ^0.8.0;contract Example &#123; event Transfer(address indexed from, address indexed to, uint amount); function transfer(address to, uint amount) public &#123; require(amount &gt; 0, &quot;Amount must be greater than zero&quot;); require(msg.sender.balance &gt;= amount, &quot;Insufficient balance&quot;); payable(to).transfer(amount); emit Transfer(msg.sender, to, amount); &#125;&#125; 上面的代码定义了一个名为Transfer的事件，它有三个参数：from（地址类型，表示发送方地址）、to（地址类型，表示接收方地址）和amount（无符号整数类型，表示转账金额）。合约还定义了一个名为transfer的函数，用于从当前发送方地址向指定地址转移指定数量的以太币，并触发Transfer事件以通知其他应用程序。 在调用transfer函数时，合约会检查发送方余额是否足够，如果足够，则转移以太币并触发事件。其他应用程序可以监听Transfer事件，并根据其参数值更新其状态或执行其他操作。 事件是Solidity中的一项强大功能，可用于在合约执行期间与其他应用程序进行通信，如向前端Web应用程序发送通知、向后端服务器发送数据等。在实际开发中，事件通常会更加复杂，并使用更高级的技术来确保其安全性和正确性。 Solidity高级语法 模块化 Solidity支持模块化，即将合约拆分为多个文件，每个文件可以包含一个或多个合约。 导入文件 在Solidity中，可以使用import关键字导入其他文件中定义的合约。 123456import &quot;./MyContract.sol&quot;;contract AnotherContract &#123; MyContract c = MyContract(0x1234567890123456789012345678901234567890);&#125; 上面的代码从文件MyContract.sol中导入了名为MyContract的合约，然后我们在AnotherContract合约中创建了一个MyContract类型的实例。 继承 Solidity支持合约的继承，即一个合约可以从另一个合约继承其状态变量和函数。 1234567891011121314contract ParentContract &#123; uint public a = 123; function foo() public pure returns (uint) &#123; return 456; &#125;&#125;contract ChildContract is ParentContract &#123; function bar() public view returns (uint) &#123; return a + foo(); &#125;&#125; 上面的代码定义了两个合约，ParentContract和ChildContract。ChildContract继承了ParentContract的状态变量a和函数foo。 抽象合约 在Solidity中，抽象合约是一种不能直接实例化的合约，它只提供了一组接口（函数签名），而没有实现任何功能。抽象合约可以被认为是一个纯虚基类，只定义了一些需要被实现的方法。 抽象合约通常用于定义通用的接口，以便其他合约可以继承它并实现接口中定义的方法。这使得合约更易于模块化，并使代码更加可读和易于维护。 以下是一个简单的抽象合约示例： 1234567pragma solidity ^0.8.0;abstract contract PaymentGateway &#123; function deposit(uint amount) public virtual; function withdraw(uint amount) public virtual;&#125; 上面的代码定义了一个名为PaymentGateway的抽象合约，它有两个函数接口：deposit和withdraw。这个合约不能被直接实例化，但可以被其他合约继承并实现这些接口。 以下是一个继承了PaymentGateway抽象合约并实现了其接口的示例合约： 123456789101112131415161718192021pragma solidity ^0.8.0;contract Bank is PaymentGateway &#123; mapping(address =&gt; uint) private balances; function deposit(uint amount) public override &#123; require(amount &gt; 0, &quot;Amount must be greater than zero&quot;); balances[msg.sender] += amount; &#125; function withdraw(uint amount) public override &#123; require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;); balances[msg.sender] -= amount; payable(msg.sender).transfer(amount); &#125; function getBalance() public view returns (uint) &#123; return balances[msg.sender]; &#125;&#125; 上面的代码定义了一个名为Bank的合约，它继承了PaymentGateway抽象合约，并实现了其中定义的接口。Bank合约还定义了一个名为getBalance的函数，用于返回调用方的余额。 抽象合约是Solidity中的一个重要概念，它使得代码更加模块化和可重用。在实际开发中，可以使用抽象合约来定义通用的接口，并让其他合约继承它并实现这些接口，从而大大简化代码的开发和维护。 接口 Solidity支持接口，即仅定义函数签名而不提供实现的抽象合约。接口可以被其他合约实现。 12345678910interface MyInterface &#123; function foo() external returns (uint);&#125;contract MyContract is MyInterface &#123; function foo() public override returns (uint) &#123; return 123; &#125;&#125; 上面的代码定义了一个名为MyInterface的接口，它包含一个名为foo的函数。然后我们在MyContract合约中实现了foo函数。 消息 Solidity中有一些特殊的变量，它们称为“消息变量”，包含有关当前交易的信息。 msg.sender：当前交易的发送方地址。 msg.value：当前交易中发送的以太币数量。 msg.data：当前交易中传递的数据。 msg.sig：当前交易中函数调用的签名。 内联汇编 Solidity支持内联汇编，即在Solidity代码中直接嵌入汇编代码。 12345678function getGasPrice() public view returns (uint) &#123; uint gasPrice; assembly &#123; gasPrice := tx.gasprice &#125; return gasPrice;&#125; 上面的代码使用内联汇编获取当前交易的Gas价格。 安全性 Solidity是一门高度安全的编程语言，旨在防止智能合约中的漏洞。以下是Solidity中常用的安全性特性： 访问控制：Solidity提供了modifier关键字，用于在函数执行前检查某个条件是否满足。 溢出和下溢：Solidity提供了安全的数学库SafeMath，用于执行加、减、乘、除等操作时检查是否存在溢出或下溢。 资源管理：Solidity中的状态变量和存储变量有不同的访问权限，防止恶意合约访问和修改合约状态。 防重入攻击：Solidity提供了nonReentrant修饰符，用于防止合约被重复调用，从而避免恶意合约攻击。 示例合约 以下是一个简单的Solidity合约，它模拟了一个简单的银行账户系统，支持存款、取款和查询余额功能。 12345678910111213141516171819202122232425pragma solidity ^0.8.0;contract Bank &#123; mapping(address =&gt; uint) balances; event Deposit(address indexed from, uint value); event Withdrawal(address indexed to, uint value); function deposit() public payable &#123; require(msg.value &gt; 0, &quot;Deposit amount must be greater than 0&quot;); balances[msg.sender] += msg.value; emit Deposit(msg.sender, msg.value); &#125; function withdraw(uint amount) public &#123; require(amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;); require(amount &lt;= balances[msg.sender], &quot;Insufficient balance&quot;); balances[msg.sender] -= amount; payable(msg.sender).transfer(amount); emit Withdrawal(msg.sender, amount); &#125; function balanceOf(address account) public view returns (uint) &#123; return balances[account]; &#125; 上面的代码定义了一个名为Bank的合约，它包含一个名为balances的映射，用于存储每个地址的余额。合约还定义了三个函数： deposit：允许发送以太币到合约地址，并将其存入发送方的余额中。 withdraw：允许发送方从其余额中取出指定数量的以太币。 balanceOf：允许查询指定地址的余额。 合约还使用了事件Deposit和Withdrawal，用于记录每个存款和取款操作的发起方和数量。 这只是一个简单的示例合约，但它涵盖了Solidity中许多基本概念和语法。在实际开发中，合约通常会更加复杂，需要更高级的语法和技术来确保其安全性和正确性。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/project/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/project/tags/Solidity/"}]},{"title":"测试","slug":"Test","date":"2023-02-26T14:04:00.000Z","updated":"2023-02-26T14:04:00.000Z","comments":true,"path":"posts/9daba997/","link":"","permalink":"https://t8840.github.io/project/posts/9daba997/","excerpt":"","text":"测试","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/project/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/project/tags/Test/"}]},{"title":"Python入门","slug":"Python","date":"2023-02-26T14:02:52.000Z","updated":"2023-02-26T14:02:52.000Z","comments":true,"path":"posts/d9ef328/","link":"","permalink":"https://t8840.github.io/project/posts/d9ef328/","excerpt":"","text":"Python是一种高级、解释型的编程语言，广泛用于Web开发、数据科学、人工智能、自动化等各个领域。下面分别介绍Python的入门和高级语法。 Python基础语法介绍 变量和数据类型 在Python中，可以使用变量来存储值，并且不需要提前声明变量类型。Python支持多种数据类型，包括整数、浮点数、布尔值、字符串、列表、元组、字典等。 以下是一些变量和数据类型的示例： 1234567891011121314151617181920212223# 整数类型x = 5y = -10# 浮点数类型z = 3.14# 布尔值类型a = Trueb = False# 字符串类型c = &quot;Hello, World!&quot;# 列表类型d = [1, 2, 3, 4, 5]# 元组类型e = (1, 2, 3)# 字典类型f = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30&#125; 运算符 Python支持多种运算符，包括算术运算符、比较运算符、逻辑运算符、位运算符等。以下是一些运算符的示例： 1234567891011121314151617181920212223242526272829# 算术运算符x = 5 + 3y = 5 - 3z = 5 * 3a = 5 / 3b = 5 % 3c = 5 ** 3# 比较运算符d = 5 == 3e = 5 != 3f = 5 &gt; 3g = 5 &lt; 3h = 5 &gt;= 3i = 5 &lt;= 3# 逻辑运算符j = True and Falsek = True or Falsel = not True# 位运算符m = 5 &amp; 3n = 5 | 3o = 5 ^ 3p = ~5q = 5 &lt;&lt; 3r = 5 &gt;&gt; 3 控制流语句 Python支持多种控制流语句，包括if语句、for循环、while循环等。以下是一些控制流语句的示例： 12345678910111213141516171819202122232425262728293031# if语句x = 5if x &gt; 0: print(&quot;x is positive&quot;)elif x &lt; 0: print(&quot;x is negative&quot;)else: print(&quot;x is zero&quot;)# for循环y = [1, 2, 3, 4, 5]for i in y: print(i)# while循环z = 1while z &lt;= 10: print(z) z += 1``` ### 函数在Python中，可以使用def语句定义函数。函数可以接受参数并返回值。以下是一个函数的示例：```pythondef add(x, y): return x + yresult = add(5, 3)print(result) # 输出8 模块和包 Python中的模块是一个包含Python定义和语句的文件，可以通过import语句导入。Python中的包是一个包含多个模块的目录。 以下是一个模块和包的示例： 12345678910111213141516171819# 模块# mymodule.pydef greeting(name): print(&quot;Hello, &quot; + name)# 使用模块import mymodulemymodule.greeting(&quot;Alice&quot;) # 输出Hello, Alice# 包# mypackage/mymodule.pydef add(x, y): return x + y# 使用包from mypackage import mymoduleresult = mymodule.add(5, 3)print(result) # 输出8 Python高级语法介绍 迭代器和生成器 Python中的迭代器是一个可以迭代访问的对象，例如列表、元组、字典等。Python中的生成器是一种更加高效的迭代器，使用yield语句生成值。 以下是一个迭代器和生成器的示例： 1234567891011121314151617181920212223242526272829303132333435363738# 迭代器my_list = [1, 2, 3, 4, 5]my_iterator = iter(my_list)print(next(my_iterator)) # 输出1print(next(my_iterator)) # 输出2print(next(my_iterator)) # 输出3# 生成器def my_generator(): yield 1 yield 2 yield 3for i in my_generator(): print(i) # 输出1, 2, 3``` ### 装饰器Python中的装饰器是一种用于修改函数或类的行为的语法。装饰器本质上是一个函数，可以在不修改原函数或类的情况下修改其行为。以下是一个装饰器的示例：```python# 装饰器def my_decorator(func): def wrapper(): print(&quot;Before the function is called.&quot;) func() print(&quot;After the function is called.&quot;) return wrapper@my_decoratordef my_function(): print(&quot;Hello, World!&quot;)my_function() # 输出Before the function is called. Hello, World! After the function is called. 异常处理 在Python中，可以使用try语句和except语句来处理异常。当程序出现异常时，Python会跳转到最近的except语句，并执行其中的代码。 以下是一个异常处理的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 异常处理try: x = 5 / 0except ZeroDivisionError: print(&quot;Error: division by zero&quot;)``` ### 多线程和多进程在Python中，可以使用多线程和多进程来实现并发编程。多线程是指在一个程序中同时执行多个线程，多进程是指在一个程序中同时运行多个进程。以下是一个多线程和多进程的示例：```python# 多线程import threadingdef print_numbers(): for i in range(10): print(i)def print_letters(): for letter in &quot;abcdefghij&quot;: print(letter)thread1 = threading.Thread(target=print_numbers)thread2 = threading.Thread(target=print_letters)thread1.start()thread2.start()# 多进程import multiprocessingdef square(number): return number ** 2if __name__ == &#x27;__main__&#x27;: pool = multiprocessing.Pool(processes=4) results = pool.map(square, [1, 2, 3, 4, 5]) print(results) # 输出[1, 4, 9, 16, 25]``` ### 类和面向对象编程Python是一种面向对象编程语言，支持类和对象的概念。可以使用class语句来定义类，使用对象来访问类中的属性和方法。以下是一个类和面向对象编程的示例：```python# 类和面向对象编程class Person: def __init__(self, name, age): self.name = name self.age = age def greet(self): print(&quot;Hello, my name is &quot; + self.name + &quot; and I am &quot; + str(self.age) + &quot; years old.&quot;)person1 = Person(&quot;Alice&quot;, 25)person1.greet() # 输出Hello, my name is Alice and I am 25 years old. Lambda函数 Lambda函数是一种匿名函数，可以使用lambda关键字定义。Lambda函数通常用于简单的操作，例如对列表进行排序或筛选。 以下是一个Lambda函数的示例： 123456789# Lambda函数numbers = [1, 2, 3, 4, 5]squared_numbers = list(map(lambda x: x ** 2, numbers))print(squared_numbers) # 输出[1, 4, 9, 16, 25]even_numbers = list(filter(lambda x: x % 2 == 0, numbers))print(even_numbers) # 输出[2, 4] 生成式 Python中的生成式是一种用于生成列表、集合或字典的简便语法。生成式通常比使用循环来生成相同的结果更加简洁和可读。 以下是一个生成式的示例： 12345678910# 生成式numbers = [1, 2, 3, 4, 5]squared_numbers = [x ** 2 for x in numbers]print(squared_numbers) # 输出[1, 4, 9, 16, 25]even_numbers = [x for x in numbers if x % 2 == 0]print(even_numbers) # 输出[2, 4] 结语 本文介绍了Python的入门和高级语法，包括基本语法、数据类型、控制流、函数、模块和包、迭代器和生成器、装饰器、异常处理、多线程和多进程、类和面向对象编程、Lambda函数以及生成式。Python是一种功能强大的编程语言，具有简单易学、可读性高等特点，在数据科学、机器学习、Web开发等","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/project/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/project/tags/Python/"}]},{"title":"Go入门","slug":"Go","date":"2023-02-26T13:54:26.000Z","updated":"2023-02-26T13:54:26.000Z","comments":true,"path":"posts/3e80a85d/","link":"","permalink":"https://t8840.github.io/project/posts/3e80a85d/","excerpt":"","text":"Go语言基础语法介绍 安装和环境配置 首先，你需要下载并安装Go语言环境。可以从官方网站（https://golang.org/dl/）上下载并安装，安装完成后设置环境变量，使其可被命令行使用。 Go语言的Hello World程序如下： 12345678package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 这个程序包含了一个main函数，该函数调用了fmt包的Println函数，将&quot;Hello, World!&quot;打印到控制台。 变量和类型 Go语言是一种静态类型的语言，也就是说变量的类型在编译时就确定了。Go语言有多种基本数据类型，包括bool、int、float、string等，同时还有结构体和数组等复合类型。 变量可以使用var关键字来声明，例如： 12var i inti = 42 可以使用:=语法来简化变量声明和赋值的过程： 1i := 42 控制流语句 Go语言的控制流语句包括if、for、switch和select等。 if语句的语法如下： 1234567if condition &#123; // do something&#125; else if condition &#123; // do something else&#125; else &#123; // do something else&#125; for语句可以用来循环执行一段代码，语法如下： 123for initialization; condition; post &#123; // do something&#125; switch语句可以根据某个表达式的值进行多个分支选择，语法如下： 12345678switch expression &#123;case value1: // do somethingcase value2: // do something elsedefault: // do something else&#125; 函数和方法 Go语言中函数和方法是非常重要的概念。函数是一组指定输入和输出的代码，可以独立地调用。方法是与特定类型相关联的函数。 函数的语法如下： 1234func functionName(parameter1 type, parameter2 type) returnType &#123; // do something return someValue&#125; 方法的语法如下： 12345func (receiverType) methodName(parameter1 type, parameter2 type) returnType &#123; // do something return someValue&#125; 数组和切片 Go语言中的数组是一种固定长度的数据结构，定义一个数组的语法如下： 1var arr [5]int 切片是一种动态长度的数据结构，它可以根据需要自动扩容。定义一个切片的语法如下： 1var slice []int 结构体和指针 Go语言中的结构体是一种自定义类型，可以包含多个字段，定义一个结构体的语法如下： 1234type Person struct &#123;Name stringAge int&#125; 基本的结构体示例 12345678910111213141516171819202122232425type Person struct &#123; name string age int&#125;func main() &#123; p := Person&#123;name: &quot;Alice&quot;, age: 30&#125; fmt.Println(p)&#125;在上面的示例中，我们定义了一个名为Person的结构体，包含name和age两个字段。然后我们创建了一个Person类型的变量p，并为其赋值，最后打印p。2. 匿名结构体示例```gofunc main() &#123; p := struct &#123; name string age int &#125;&#123; name: &quot;Alice&quot;, age: 30, &#125; fmt.Println(p)&#125; 在上面的示例中，我们定义了一个匿名结构体，并为其赋值，最后打印该结构体。 嵌套结构体示例 12345678910111213141516171819202122232425type Address struct &#123; street string city string country string&#125;type Person struct &#123; name string age int address Address&#125;func main() &#123; p := Person&#123; name: &quot;Alice&quot;, age: 30, address: Address&#123; street: &quot;Main St&quot;, city: &quot;New York&quot;, country: &quot;USA&quot;, &#125;, &#125; fmt.Println(p)&#125; 在上面的示例中，我们定义了一个名为Address的结构体，包含street、city和country三个字段。然后我们定义了一个名为Person的结构体，包含name、age和address三个字段，其中address字段类型为Address。然后我们创建了一个Person类型的变量p，并为其赋值，其中address字段又包含了一个Address类型的值。最后打印p。 匿名字段结构体示例 1234567891011type Person struct &#123; string int&#125;func main() &#123; p := Person&#123;&quot;Alice&quot;, 30&#125; fmt.Println(p) fmt.Println(p.string)&#125; 在上面的示例中，我们定义了一个名为Person的结构体，包含两个匿名字段，分别为string和int类型。然后我们创建了一个Person类型的变量p，并为其赋值。我们可以通过.访问匿名字段的值，例如p.string表示访问string字段的值。最后打印p和p.string。 指针是一种特殊的变量类型，它存储了一个变量的内存地址，可以使用&amp;符号来获取一个变量的地址，使用*符号来获取指针所指向的值。例如： 1234var i intvar p *intp = &amp;i*i = 42 并发和并行 Go语言是一种天生支持并发和并行的语言。 Go语言中的goroutine是一种轻量级的线程，可以在同一个进程中同时运行多个goroutine。 Go语言中的channel是一种可以在不同goroutine之间进行通信的机制。 错误处理 Go语言中的错误处理非常重要。Go语言中的函数通常会返回一个错误值，如果函数执行过程中出现了错误，就会返回一个非空的错误值。可以使用if语句来检查是否出现了错误。 包和模块 Go语言中的包是一种组织代码的机制，一个包可以包含多个文件。包可以使用import语句来导入其他包中的代码。Go语言中的模块是一种用来管理代码版本和依赖关系的机制，可以使用go mod命令来管理模块。 Go语言高级语法介绍 接口和多态 Go语言中的接口是一种约束，可以指定一个类型需要实现哪些方法。可以使用接口来实现多态。例如： 12345678910111213141516171819202122type Animal interface &#123;Speak() string&#125;type Dog struct &#123;&#125;func (d Dog) Speak() string &#123;return &quot;Woof!&quot;&#125;type Cat struct &#123;&#125;func (c Cat) Speak() string &#123;return &quot;Meow!&quot;&#125;func main() &#123;animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125;for _, animal := range animals &#123;fmt.Println(animal.Speak())&#125;&#125; 在这个例子中，Dog和Cat都实现了Animal接口的Speak方法，所以它们都可以存储在Animal类型的切片中。 反射 Go语言中的反射机制可以让程序在运行时动态地获取类型信息和调用方法。反射可以让程序更加灵活，但也会带来一些性能损失。例如： 1234567func main() &#123;var x float64 = 3.14v := reflect.ValueOf(x)fmt.Println(&quot;type:&quot;, v.Type())fmt.Println(&quot;value:&quot;, v.Float())&#125; 在这个例子中，reflect.ValueOf函数可以获取变量x的反射对象，可以使用Type方法获取x的类型信息，使用Float方法获取x的值。 并发编程 Go语言的并发编程非常强大，可以使用goroutine和channel来实现。例如： goroutine示例 goroutine是Go语言中的轻量级线程，可以在一个程序中同时运行多个goroutine。使用goroutine可以轻松地实现并发执行的任务，而无需显式地管理线程或协程。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;time&quot;)func printNumbers() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Println(i) time.Sleep(1 * time.Second) &#125;&#125;func main() &#123; go printNumbers() // 启动一个goroutine fmt.Println(&quot;Main function execution&quot;) time.Sleep(6 * time.Second) // 主函数等待6秒钟&#125; 在上面的示例中，printNumbers()函数被启动为一个goroutine，同时main()函数继续执行，因此可以看到输出交错进行。 channel示例 channel是Go语言中用于goroutine之间通信的机制。channel是一个类型化的管道，可以通过它发送和接收值。channel的发送和接收操作都是阻塞的，这使得goroutine可以安全地通信。 示例： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)func producer(c chan&lt;- int) &#123; for i := 1; i &lt;= 5; i++ &#123; c &lt;- i // 发送数据到channel &#125; close(c) // 关闭channel&#125;func consumer(c &lt;-chan int) &#123; for i := range c &#123; // 循环从channel中接收数据 fmt.Println(i) &#125;&#125;func main() &#123; c := make(chan int) // 创建一个channel go producer(c) // 启动一个生产者goroutine consumer(c) // 消费者从channel中接收数据&#125; 在上面的示例中，producer()函数将1到5的整数发送到channel中，然后关闭channel。consumer()函数从channel中接收数据并将其打印出来。注意到在main()函数中没有显式地等待生产者和消费者的执行，但是由于channel是阻塞的，因此它们的执行顺序是正确的。 匿名函数和闭包 Go语言支持匿名函数和闭包，这使得代码更简洁、易于阅读和维护。闭包是一个函数值，它引用了函数体外部的变量。 示例： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; x := 10 func() &#123; fmt.Println(&quot;x =&quot;, x) // 匿名函数引用外部变量 x &#125;()&#125; defer语句 defer语句可以用于在函数返回前执行某些代码。defer语句通常用于清理资源或解锁锁定的资源。 示例： 123456789package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) // 在函数返回前执行 fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125; 接口 Go语言的接口使得代码更具可扩展性和可复用性。接口是一种类型，定义了一组方法，任何实现了这些方法的类型都可以作为该接口的实例。 示例： 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;type Shape interface &#123; Area() float64 Perimeter() float64&#125;type Rectangle struct &#123; width float64 height float64&#125;func (r Rectangle) Area() float64 &#123; return r.width * r.height&#125;func (r Rectangle) Perimeter() float64 &#123; return 2*r.width + 2*r.height&#125;func main() &#123; var s Shape = Rectangle&#123;width: 10, height: 20&#125; fmt.Println(&quot;Area:&quot;, s.Area()) fmt.Println(&quot;Perimeter:&quot;, s.Perimeter())&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/project/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://t8840.github.io/project/tags/Go/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/project/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/project/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/project/tags/Solidity/"},{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/project/tags/Test/"},{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/project/tags/Python/"},{"name":"Go","slug":"Go","permalink":"https://t8840.github.io/project/tags/Go/"}]}