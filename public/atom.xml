<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neal&#39;s World</title>
  
  
  <link href="https://t8840.github.io/atom.xml" rel="self"/>
  
  <link href="https://t8840.github.io/"/>
  <updated>2023-09-16T10:01:17.000Z</updated>
  <id>https://t8840.github.io/</id>
  
  <author>
    <name>Neal.Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RUST-Test</title>
    <link href="https://t8840.github.io/posts/4211dcac/"/>
    <id>https://t8840.github.io/posts/4211dcac/</id>
    <published>2023-09-16T10:01:17.000Z</published>
    <updated>2023-09-16T10:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="the-test-library"><a class="markdownIt-Anchor" href="#the-test-library"></a> The Test Library</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert_cmd </span><br></pre></td></tr></table></figure><h3 id="assert_cmd库"><a class="markdownIt-Anchor" href="#assert_cmd库"></a> assert_cmd库</h3><p>Uses the assert_cmd crate to test the output of a binary called “hello”. The test case verifies that executing the “hello” binary is successful and that the stdout (standard output) matches the expected string “Hello, world!\n”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use assert_cmd::Command;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn work()&#123;</span><br><span class="line">    let mut cmd = Command::cargo_bin(&quot;hello&quot;).unwrap();</span><br><span class="line">    cmd.assert().success();</span><br><span class="line">    cmd.assert().success().stdout(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;the-test-library&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#the-test-library&quot;&gt;&lt;/a&gt; The Test Library&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TEST-Burpsuite</title>
    <link href="https://t8840.github.io/posts/c180da4e/"/>
    <id>https://t8840.github.io/posts/c180da4e/</id>
    <published>2023-09-15T14:25:01.000Z</published>
    <updated>2023-09-15T14:25:01.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>TEST-Sqlmap</title>
    <link href="https://t8840.github.io/posts/bc1e8349/"/>
    <id>https://t8840.github.io/posts/bc1e8349/</id>
    <published>2023-09-15T14:01:40.000Z</published>
    <updated>2023-09-15T14:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sqlmap"><a class="markdownIt-Anchor" href="#sqlmap"></a> Sqlmap</h2><ul><li>Install</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install sqlmap</span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sqlmap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sqlmap&quot;&gt;&lt;/a&gt; Sqlmap&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Install&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PWD-Wordlist</title>
    <link href="https://t8840.github.io/posts/9f0d0a7a/"/>
    <id>https://t8840.github.io/posts/9f0d0a7a/</id>
    <published>2023-09-15T10:16:49.000Z</published>
    <updated>2023-09-15T10:16:49.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>PWD</title>
    <link href="https://t8840.github.io/posts/17b6b9b8/"/>
    <id>https://t8840.github.io/posts/17b6b9b8/</id>
    <published>2023-09-15T10:16:37.000Z</published>
    <updated>2023-09-15T10:16:37.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>INFO-WebsiteSubDomain</title>
    <link href="https://t8840.github.io/posts/c32d6646/"/>
    <id>https://t8840.github.io/posts/c32d6646/</id>
    <published>2023-09-15T09:59:04.000Z</published>
    <updated>2023-09-15T09:59:04.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>INFO-WebsiteFinger</title>
    <link href="https://t8840.github.io/posts/daccb71/"/>
    <id>https://t8840.github.io/posts/daccb71/</id>
    <published>2023-09-15T09:27:53.000Z</published>
    <updated>2023-09-15T09:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-check"><a class="markdownIt-Anchor" href="#web-check"></a> Web-check</h2><p><a href="">Github</a><br /><a href="https://web-check.xyz/">OnlineUse</a></p><h2 id="nmap"><a class="markdownIt-Anchor" href="#nmap"></a> Nmap</h2><h3 id="install"><a class="markdownIt-Anchor" href="#install"></a> Install</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nmap</span><br></pre></td></tr></table></figure><h3 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap IP</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web-check&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#web-check&quot;&gt;&lt;/a&gt; Web-check&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;Github&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://web-ch</summary>
      
    
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/categories/InfoCollect/"/>
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/tags/InfoCollect/"/>
    
  </entry>
  
  <entry>
    <title>INFO-Tool Summary</title>
    <link href="https://t8840.github.io/posts/f3f81bd1/"/>
    <id>https://t8840.github.io/posts/f3f81bd1/</id>
    <published>2023-09-15T07:30:52.000Z</published>
    <updated>2023-09-15T07:30:52.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>INFO-WebsiteDir</title>
    <link href="https://t8840.github.io/posts/a36ba747/"/>
    <id>https://t8840.github.io/posts/a36ba747/</id>
    <published>2023-09-15T07:30:10.000Z</published>
    <updated>2023-09-15T07:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><p><a href="https://github.com/OJ/gobuster">Gobuster：URI/DNS/WEB爆破</a><br /><a href="https://github.com/maurosoria/dirsearch">dirsearch：目录扫描/爆破</a><br /><a href="https://github.com/H4ckForJob/dirmap">dirmap：目录扫描/爆破</a></p><p>jwt_tool：JSON Web Token Toolkit <a href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a><br />ffuf：高速web fuzz工具 <a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a><br />Arjun：HTTP参数扫描器 <a href="https://github.com/s0md3v/Arjun">https://github.com/s0md3v/Arjun</a><br />URLFinder：JS与URL快速提取检测 <a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a><br />ksubdomain：子域名爆破 <a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a><br /><a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker：JSON Web Token Cracker</a></p><h3 id="gobuster"><a class="markdownIt-Anchor" href="#gobuster"></a> Gobuster</h3><p><a href="https://github.com/OJ/gobuster/releases">DownloadLink</a></p><ul><li>Usage</li></ul><h3 id="dirsearch"><a class="markdownIt-Anchor" href="#dirsearch"></a> Dirsearch</h3><ul><li>Usage</li></ul><h3 id="dirmap"><a class="markdownIt-Anchor" href="#dirmap"></a> dirmap</h3><ul><li>Install</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/H4ckForJob/dirmap.git &amp;&amp; cd dirmap &amp;&amp; python3 -m pip install -r requirement.txt</span><br></pre></td></tr></table></figure><ul><li>Usage</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dirmap.py -i https://target.com -lcf</span><br></pre></td></tr></table></figure><ul><li>Commit<br />The tool can use but the author haven’t update for a long time.<br />And seems the tool is useless.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#summary&quot;&gt;&lt;/a&gt; Summary&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/OJ/gobuster&quot;&gt;Gobuster：URI/DNS</summary>
      
    
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/categories/InfoCollect/"/>
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/tags/InfoCollect/"/>
    
  </entry>
  
  <entry>
    <title>XRAY</title>
    <link href="https://t8840.github.io/posts/bb10959b/"/>
    <id>https://t8840.github.io/posts/bb10959b/</id>
    <published>2023-09-15T07:21:54.000Z</published>
    <updated>2023-09-15T07:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="intro"><a class="markdownIt-Anchor" href="#intro"></a> Intro</h2><p><a href="https://github.com/chaitin/xray">GitHub</a><br /><a href="https://docs.xray.cool/">Doc</a></p><h3 id="intall"><a class="markdownIt-Anchor" href="#intall"></a> Intall</h3><p><a href="https://github.com/chaitin/xray/releases">ReleaseAdrress</a></p><ul><li>Linux Intall</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/chaitin/xray/releases/download/1.9.11/xray_linux_amd64.zip</span><br><span class="line">unzip xray_linux_amd64.zip</span><br><span class="line">./xray_linux_amd64 version</span><br></pre></td></tr></table></figure><ul><li>Problem</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xray_linux_amd64: error while loading shared libraries: libpcap.so.0.8: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><h2 id="use-steps"><a class="markdownIt-Anchor" href="#use-steps"></a> Use Steps</h2><h3 id="basic-crawl"><a class="markdownIt-Anchor" href="#basic-crawl"></a> Basic-crawl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xray_linux_amd64  webscan --basic-crawler https://test.com  --html-output xray-crawler-testphp.html</span><br></pre></td></tr></table></figure><h3 id="service-scan"><a class="markdownIt-Anchor" href="#service-scan"></a> Service Scan</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xray_linux_amd64  servicescan --target https://test.com  --html-output xray-crawler-testphp.html</span><br></pre></td></tr></table></figure><h3 id="xray-burp"><a class="markdownIt-Anchor" href="#xray-burp"></a> Xray + Burp</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;intro&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#intro&quot;&gt;&lt;/a&gt; Intro&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chaitin/xray&quot;&gt;GitHub&lt;/a&gt;&lt;br /&gt;
&lt;a h</summary>
      
    
    
    
    <category term="测试开发" scheme="https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Test" scheme="https://t8840.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>TOOL-RemoteAPPWebsite</title>
    <link href="https://t8840.github.io/posts/58f8afd2/"/>
    <id>https://t8840.github.io/posts/58f8afd2/</id>
    <published>2023-09-15T02:12:59.000Z</published>
    <updated>2023-09-15T02:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="appetize"><a class="markdownIt-Anchor" href="#appetize"></a> APPETIZE</h2><p><a href="https://appetize.io/">WEBSITE</a></p><ul><li>Advantage<br />It offer living demo, even you don’t need register use the demo app.<br />And it offer user free use it most 50 minters</li></ul><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;appetize&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#appetize&quot;&gt;&lt;/a&gt; APPETIZE&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://appetize.io/&quot;&gt;WEBSITE&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="TOOL" scheme="https://t8840.github.io/categories/TOOL/"/>
    
    
    <category term="TOOL TEST" scheme="https://t8840.github.io/tags/TOOL-TEST/"/>
    
  </entry>
  
  <entry>
    <title>PYTHON-Encoding</title>
    <link href="https://t8840.github.io/posts/6d2ab45f/"/>
    <id>https://t8840.github.io/posts/6d2ab45f/</id>
    <published>2023-09-15T00:34:52.000Z</published>
    <updated>2023-09-15T00:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="transfer-chinese"><a class="markdownIt-Anchor" href="#transfer-chinese"></a> Transfer Chinese</h2><p>There are many times that the output of python result contains Chinese ,that can’t show.<br />So you need transfer it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#.encode(&#x27;utf-8&#x27;)</span><br><span class="line">#.decode(&#x27;utf-8&#x27;)</span><br><span class="line"># For Example:</span><br><span class="line">print(&#x27;wifi scan result: &#123;&#125;&#x27;.format(i.ssid.encode(&#x27;utf-8&#x27;).decode(&#x27;gbk&#x27;)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;transfer-chinese&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#transfer-chinese&quot;&gt;&lt;/a&gt; Transfer Chinese&lt;/h2&gt;
&lt;p&gt;There are many times that the </summary>
      
    
    
    
    <category term="Python" scheme="https://t8840.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://t8840.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>TOOL-VsCode</title>
    <link href="https://t8840.github.io/posts/8fe43100/"/>
    <id>https://t8840.github.io/posts/8fe43100/</id>
    <published>2023-09-15T00:17:46.000Z</published>
    <updated>2023-09-15T00:17:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="plugin"><a class="markdownIt-Anchor" href="#plugin"></a> Plugin</h2><h3 id="autocompleteplugin"><a class="markdownIt-Anchor" href="#autocompleteplugin"></a> AutoCompletePlugin</h3><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;plugin&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#plugin&quot;&gt;&lt;/a&gt; Plugin&lt;/h2&gt;
&lt;h3 id=&quot;autocompleteplugin&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="TOOL" scheme="https://t8840.github.io/categories/TOOL/"/>
    
    
    <category term="TOOL" scheme="https://t8840.github.io/tags/TOOL/"/>
    
  </entry>
  
  <entry>
    <title>TEST-Httprunner</title>
    <link href="https://t8840.github.io/posts/7ca05367/"/>
    <id>https://t8840.github.io/posts/7ca05367/</id>
    <published>2023-09-15T00:12:34.000Z</published>
    <updated>2023-09-15T00:12:34.000Z</updated>
    
    
    
    
    <category term="测试开发" scheme="https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Test" scheme="https://t8840.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>INFO-Wechat</title>
    <link href="https://t8840.github.io/posts/b12ebec1/"/>
    <id>https://t8840.github.io/posts/b12ebec1/</id>
    <published>2023-09-15T00:08:12.000Z</published>
    <updated>2023-09-15T00:08:12.000Z</updated>
    
    
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/categories/InfoCollect/"/>
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/tags/InfoCollect/"/>
    
  </entry>
  
  <entry>
    <title>INFO-Wifi</title>
    <link href="https://t8840.github.io/posts/5ebeb00b/"/>
    <id>https://t8840.github.io/posts/5ebeb00b/</id>
    <published>2023-09-15T00:07:48.000Z</published>
    <updated>2023-09-15T00:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wifi"><a class="markdownIt-Anchor" href="#wifi"></a> WIFI</h2><h3 id="pywifi"><a class="markdownIt-Anchor" href="#pywifi"></a> Pywifi</h3><p>Use pywifi get around wifi information.<br />Check the code in here:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wifi&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#wifi&quot;&gt;&lt;/a&gt; WIFI&lt;/h2&gt;
&lt;h3 id=&quot;pywifi&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pywifi&quot;&gt;&lt;/a&gt; Pywi</summary>
      
    
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/categories/InfoCollect/"/>
    
    
    <category term="InfoCollect" scheme="https://t8840.github.io/tags/InfoCollect/"/>
    
  </entry>
  
  <entry>
    <title>WEB3-Ton</title>
    <link href="https://t8840.github.io/posts/f961dce1/"/>
    <id>https://t8840.github.io/posts/f961dce1/</id>
    <published>2023-09-15T00:07:09.000Z</published>
    <updated>2023-09-15T00:07:09.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>INFO-TelegramInfoCollect</title>
    <link href="https://t8840.github.io/posts/86743e4d/"/>
    <id>https://t8840.github.io/posts/86743e4d/</id>
    <published>2023-09-15T00:06:45.000Z</published>
    <updated>2023-09-15T00:06:45.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST-Concurrency</title>
    <link href="https://t8840.github.io/posts/fd08b82f/"/>
    <id>https://t8840.github.io/posts/fd08b82f/</id>
    <published>2023-09-14T23:59:58.000Z</published>
    <updated>2023-09-14T23:59:58.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST-WEB</title>
    <link href="https://t8840.github.io/posts/6a322aba/"/>
    <id>https://t8840.github.io/posts/6a322aba/</id>
    <published>2023-09-14T23:59:03.000Z</published>
    <updated>2023-09-14T23:59:03.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST-GUI</title>
    <link href="https://t8840.github.io/posts/ab044213/"/>
    <id>https://t8840.github.io/posts/ab044213/</id>
    <published>2023-09-14T23:58:53.000Z</published>
    <updated>2023-09-14T23:58:53.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST-NET</title>
    <link href="https://t8840.github.io/posts/8d110714/"/>
    <id>https://t8840.github.io/posts/8d110714/</id>
    <published>2023-09-14T23:58:44.000Z</published>
    <updated>2023-09-14T23:58:44.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST-Basic</title>
    <link href="https://t8840.github.io/posts/4635b819/"/>
    <id>https://t8840.github.io/posts/4635b819/</id>
    <published>2023-09-14T23:58:27.000Z</published>
    <updated>2023-09-14T23:58:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="variable"><a class="markdownIt-Anchor" href="#variable"></a> Variable</h2><h2 id="data-type"><a class="markdownIt-Anchor" href="#data-type"></a> Data Type</h2><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><h3 id="vec"><a class="markdownIt-Anchor" href="#vec"></a> Vec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec::join</span><br></pre></td></tr></table></figure><h3 id="values"><a class="markdownIt-Anchor" href="#values"></a> Values</h3><h3 id="option"><a class="markdownIt-Anchor" href="#option"></a> Option</h3><h2 id="statement"><a class="markdownIt-Anchor" href="#statement"></a> Statement</h2><h2 id="symbol"><a class="markdownIt-Anchor" href="#symbol"></a> Symbol</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;:?&#125;</span><br><span class="line">&#123;:#?&#125;</span><br></pre></td></tr></table></figure><h3 id="loop-statement"><a class="markdownIt-Anchor" href="#loop-statement"></a> Loop Statement</h3><h3 id="condition-statement"><a class="markdownIt-Anchor" href="#condition-statement"></a> Condition Statement</h3><h2 id="function-feature"><a class="markdownIt-Anchor" href="#function-feature"></a> Function Feature</h2><h3 id="derivedebug"><a class="markdownIt-Anchor" href="#derivedebug"></a> #[derive(Debug)]</h3><p>#[derive(Debug)] is an attribute in Rust used to automatically generate code that implements the Debug trait. The Debug trait is a built-in trait in Rust that provides a default way to format and print values for debugging purposes.</p><p>By adding #[derive(Debug)] to a struct or an enum, the Rust compiler automatically generates the necessary code to implement the Debug trait. This allows us to use println! macro or other debugging tools to print and inspect the contents of the types.</p><h3 id="test"><a class="markdownIt-Anchor" href="#test"></a> #[test]</h3><h2 id="function"><a class="markdownIt-Anchor" href="#function"></a> Function</h2><h3 id="unwrap"><a class="markdownIt-Anchor" href="#unwrap"></a> .unwrap()</h3><p>The .unwrap() method in Rust is used to extract the value from an Option or Result type. It returns the inner value if it exists or panics if it encounters a None or Err variant.</p><h3 id="stdenvargs"><a class="markdownIt-Anchor" href="#stdenvargs"></a> std::env::args()</h3><p>std::env::args() is a function provided by the Rust standard library (std::env module) that returns an iterator over the command-line arguments passed to the program.</p><p>The args() function returns an iterator of type std::env::Args, which represents the individual command-line arguments as strings. The first element of the iterator (std::env::Args) is always the name of the executable binary itself.</p><p>Here’s an example of how to use std::env::args():</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // Access the command-line arguments</span><br><span class="line">    let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    // Print the binary name and command-line arguments</span><br><span class="line">    println!(&quot;Binary: &#123;&#125;&quot;, args[0]);</span><br><span class="line">    println!(&quot;Arguments: &#123;:?&#125;&quot;, &amp;args[1..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./my_program arg1 arg2 arg3</span><br><span class="line">Binary: ./my_program</span><br><span class="line">Arguments: [&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]</span><br></pre></td></tr></table></figure><h3 id="clap"><a class="markdownIt-Anchor" href="#clap"></a> clap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matches.values_of(&quot;text&quot;).unwrap();</span><br><span class="line">matches.values_of_lossy(&quot;text&quot;).unwrap();</span><br><span class="line">matches.is_present(&quot;omit_newline&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Example: use clap=“3”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">use clap::&#123;App,Arg&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args = App::new(&quot;MyApp&quot;)</span><br><span class="line">        .version(&quot;1.0&quot;)</span><br><span class="line">        .author(&quot;jonhn&quot;)</span><br><span class="line">        .help(&quot;A simple App&quot;)</span><br><span class="line">        .arg(</span><br><span class="line">            Arg::with_name(&quot;input&quot;)</span><br><span class="line">                .short(&#x27;i&#x27;)</span><br><span class="line">                .long(&quot;input&quot;)</span><br><span class="line">                .value_name(&quot;FILE&quot;)</span><br><span class="line">                .help(&quot;Sets the input file&quot;)</span><br><span class="line">                .takes_value(true),</span><br><span class="line">                )</span><br><span class="line">        .arg(</span><br><span class="line">            Arg::with_name(&quot;output&quot;)</span><br><span class="line">                .short(&#x27;o&#x27;)</span><br><span class="line">                .long(&quot;output&quot;)</span><br><span class="line">                .value_name(&quot;FILE&quot;)</span><br><span class="line">                .help(&quot;Sets the output file&quot;)</span><br><span class="line">                .takes_value(true),</span><br><span class="line">                )</span><br><span class="line">        .get_matches();</span><br><span class="line">    println!(&quot;&#123;:#?&#125;&quot;,args);</span><br><span class="line">    if let Some(input_file) = args.value_of(&quot;input&quot;) &#123;</span><br><span class="line">        println!(&quot;Input file:&#123;&#125;&quot;,input_file);</span><br><span class="line">    &#125;</span><br><span class="line">    if let Some(output_file) = args.value_of(&quot;output&quot;) &#123;</span><br><span class="line">        println!(&quot;output file:&#123;&#125;&quot;, output_file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stdfs"><a class="markdownIt-Anchor" href="#stdfs"></a> std::fs</h3><h3 id="stderrorerror"><a class="markdownIt-Anchor" href="#stderrorerror"></a> std::error::Error</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;variable&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#variable&quot;&gt;&lt;/a&gt; Variable&lt;/h2&gt;
&lt;h2 id=&quot;data-type&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#da</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RUST</title>
    <link href="https://t8840.github.io/posts/d7a76f14/"/>
    <id>https://t8840.github.io/posts/d7a76f14/</id>
    <published>2023-09-14T23:58:15.000Z</published>
    <updated>2023-09-14T23:58:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install"><a class="markdownIt-Anchor" href="#install"></a> Install</h2><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h2><h3 id="run-demo"><a class="markdownIt-Anchor" href="#run-demo"></a> Run Demo</h3><ol><li>Use rustc</li></ol><ul><li><a href="http://hello.rs">hello.rs</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rustc <a href="http://hello.rs">hello.rs</a></li><li>./hello</li></ul><ol start="2"><li>Use Cargo</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello</span><br><span class="line">cd hello</span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><h3 id="test-demo"><a class="markdownIt-Anchor" href="#test-demo"></a> Test Demo</h3><ul><li>mkdir tests</li><li>vim tests/cli.rs</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use std::process::Command;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn work()&#123;</span><br><span class="line">    let mut cmd = Command::new(&quot;ls&quot;);</span><br><span class="line">    let res = cmd.output();</span><br><span class="line">    assert!(res.is_ok());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cargo test</li></ul><h3 id="adding-a-project-dependency"><a class="markdownIt-Anchor" href="#adding-a-project-dependency"></a> Adding a project dependency</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;install&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#install&quot;&gt;&lt;/a&gt; Install&lt;/h2&gt;
&lt;h2 id=&quot;example&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#example</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LING-Infomation Salo</title>
    <link href="https://t8840.github.io/posts/78e9cc95/"/>
    <id>https://t8840.github.io/posts/78e9cc95/</id>
    <published>2023-09-14T23:45:10.000Z</published>
    <updated>2023-09-14T23:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>We live in an Information Age, where computers have become an integral part of our daily lives. Personally, I work with a computer every day, constantly exploring and seeking out better programming tools like Python and other languages. It’s difficult for me to imagine a life without a computer, as I have realized that I spend a significant amount of time using one. Additionally, news apps have become a crucial source of information for us.</p><p>However, it’s important to be aware that our reliance on technology and the influence of companies can sometimes impact our thoughts and perceptions. By presenting information in a controlled and easily digestible manner, companies can shape our understanding of the world. It’s essential to maintain critical thinking skills and seek diverse sources of information to ensure a well-rounded perspective.</p><p>Please note that the impact of technology and media on our lives is a complex and multifaceted topic. It’s important to engage in thoughtful discussions and consider various viewpoints to gain a comprehensive understanding of the subject.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;We live in an Information Age, where computers have become an integral part of our daily lives. Personally, I work with a computer every </summary>
      
    
    
    
    <category term="Mental" scheme="https://t8840.github.io/categories/Mental/"/>
    
    
    <category term="Mental" scheme="https://t8840.github.io/tags/Mental/"/>
    
  </entry>
  
  <entry>
    <title>Solana环境部署</title>
    <link href="https://t8840.github.io/posts/aad447b0/"/>
    <id>https://t8840.github.io/posts/aad447b0/</id>
    <published>2023-09-14T08:51:28.000Z</published>
    <updated>2023-09-14T08:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="cargo安装"><a class="markdownIt-Anchor" href="#cargo安装"></a> Cargo安装</h3><h3 id="二进制安装"><a class="markdownIt-Anchor" href="#二进制安装"></a> 二进制安装</h3><h2 id="问题处理"><a class="markdownIt-Anchor" href="#问题处理"></a> 问题处理</h2><ol><li><p>Linux出现不支持AVX2指令的解决办法</p><pre class="highlight"><code class="">[2023-09-14T08:41:31.273811400Z INFO  solana_perf] AVX detected[2023-09-14T08:41:31.273825030Z ERROR solana_perf] Incompatible CPU detected: missing AVX2 support. Please build from source on the targetAborted (core dumped)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Check Your CPU: First, determine if your CPU has support for AVX2. This can be done using:</span><br><span class="line">For Linux:</span><br></pre></td></tr></table></figure>grep avx2 /proc/cpuinfo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you get output, your CPU supports AVX2. If you don&#x27;t get any output, it doesn&#x27;t.</span><br><span class="line"></span><br><span class="line">For macOS:</span><br></pre></td></tr></table></figure>sysctl -a | grep machdep.cpu.features<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Look for AVX2 in the output.</span><br><span class="line"></span><br><span class="line">- Building From Source</span><br><span class="line">If your CPU does not support AVX2, the recommendation, as given by the error message, is to build Solana from source on the target machine. This way, the build process will optimize for the specific features that your CPU supports.</span><br><span class="line">Here&#x27;s a basic guide to building Solana from source:</span><br><span class="line">Clone the Solana repository:</span><br></pre></td></tr></table></figure>git clone https://github.com/solana-labs/solana.gitcd solana<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Build Solana:</span><br><span class="line"></span><br></pre></td></tr></table></figure>cargo build --release```Once built, the Solana binaries will be available under the target/release directory.Upgrade or Change Your Hardware: If you're running on a cloud provider, consider changing your instance type to one that has AVX2 support. If you're on physical hardware and you require AVX2 support frequently, consider upgrading your CPU to a more recent one that supports AVX2.- Use Docker: If Solana provides a Docker image, you might be able to run Solana in a container. Docker containers can abstract away some of the hardware dependencies, although performance might be impacted.Remember that not having AVX2 support will not prevent Solana from running when built from source; it just means you won't be able to utilize some of the optimizations that the pre-built binaries might have.</code></pre></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;h3 id=&quot;cargo安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#cargo安装&quot;&gt;&lt;/a&gt; Cargo安装&lt;</summary>
      
    
    
    
    <category term="Web3" scheme="https://t8840.github.io/categories/Web3/"/>
    
    
    <category term="Web3" scheme="https://t8840.github.io/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>Solana Anchor使用</title>
    <link href="https://t8840.github.io/posts/db86fce/"/>
    <id>https://t8840.github.io/posts/db86fce/</id>
    <published>2023-09-14T07:20:58.000Z</published>
    <updated>2023-09-14T07:20:58.000Z</updated>
    
    
    
    
    <category term="Web3" scheme="https://t8840.github.io/categories/Web3/"/>
    
    
    <category term="Web3" scheme="https://t8840.github.io/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://t8840.github.io/posts/69c3279c/"/>
    <id>https://t8840.github.io/posts/69c3279c/</id>
    <published>2023-09-14T07:02:28.000Z</published>
    <updated>2023-09-14T07:02:28.000Z</updated>
    
    
    
    
    <category term="Devops" scheme="https://t8840.github.io/categories/Devops/"/>
    
    
    <category term="Devops" scheme="https://t8840.github.io/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs环境配置</title>
    <link href="https://t8840.github.io/posts/4fe94406/"/>
    <id>https://t8840.github.io/posts/4fe94406/</id>
    <published>2023-09-14T06:59:05.000Z</published>
    <updated>2023-09-14T06:59:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nvm"><a class="markdownIt-Anchor" href="#安装nvm"></a> 安装NVM</h2><p>要安装 nvm（Node Version Manager），可以按照以下步骤进行：</p><h4 id="linux安装nvm"><a class="markdownIt-Anchor" href="#linux安装nvm"></a> Linux安装nvm</h4><p>打开终端。<br />在终端中运行以下命令来安装 nvm 的安装脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>这将下载并运行 nvm 的安装脚本。</p><p>安装完成后，终端会显示一些说明信息。按照说明，在终端中运行以下命令来加载 nvm：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.nvm/nvm.sh</span><br></pre></td></tr></table></figure><p>或者，你可以重新打开一个新的终端窗口，nvm 将会自动加载。</p><p>现在，你可以使用 nvm 来安装和管理 Node.js 版本。例如，要安装最新版本的 Node.js，可以运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install node</span><br></pre></td></tr></table></figure><p>这将安装最新的稳定版本的 Node.js。</p><p>验证安装是否成功，可以运行以下命令检查 Node.js 和 npm（Node 包管理器）的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>这将显示已安装的 Node.js 和 npm 的版本号。</p><p>以上是在 Linux 或 macOS 系统上安装 nvm 的步骤。如果你使用的是 Windows 系统，可以尝试使用 nvm 的 Windows 版本（nvm-windows）。你可以在 nvm 的 GitHub 存储库上找到更多关于 nvm 的详细信息和使用说明。</p><h3 id="安装yarn"><a class="markdownIt-Anchor" href="#安装yarn"></a> 安装yarn</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nvm&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装nvm&quot;&gt;&lt;/a&gt; 安装NVM&lt;/h2&gt;
&lt;p&gt;要安装 nvm（Node Version Manager），可以按照以下步骤进行：&lt;/p&gt;
&lt;h4 id=&quot;linux安装nv</summary>
      
    
    
    
    <category term="JS" scheme="https://t8840.github.io/categories/JS/"/>
    
    
    <category term="JS" scheme="https://t8840.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Trade</title>
    <link href="https://t8840.github.io/posts/bfdb6c62/"/>
    <id>https://t8840.github.io/posts/bfdb6c62/</id>
    <published>2023-09-13T09:21:56.000Z</published>
    <updated>2023-09-13T09:21:56.000Z</updated>
    
    
    
    
    <category term="Trade" scheme="https://t8840.github.io/categories/Trade/"/>
    
    
    <category term="Trade" scheme="https://t8840.github.io/tags/Trade/"/>
    
  </entry>
  
  <entry>
    <title>开悟</title>
    <link href="https://t8840.github.io/posts/f808b0ac/"/>
    <id>https://t8840.github.io/posts/f808b0ac/</id>
    <published>2023-09-13T09:18:52.000Z</published>
    <updated>2023-09-13T09:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br />目录</p><p>01 人生一世最大的成就是什么？</p><p>02 开悟最简单的第四种途径——当下顿悟</p><p>03 我见证了父亲的开悟时刻</p><p>04 开悟就是找到第三个“我”在哪里</p><p>05 捐出100万还要说谢谢</p><p>06 大脑的死穴</p><p>07 如何观察一只杯子由你的深度决定</p><p>08 大脑如何装下整个宇宙</p><p>09 开悟常在绝境处</p><p>10 大脑不死心灵不现（上）</p><p>11 大脑不死心灵不现（中）</p><p>12 大脑不死心灵不现（下）</p><p>有没有开悟?如何开悟？开悟之后是个怎样的状况？我们为什么要追求开悟？</p><p>这是每一个修行人士都渴望了解的问题。</p><p>据说地球上开悟的人不到百万分之一，也就是说，一百万个人之中只有一个人开悟了，为何如此稀有？</p><p>答案就是：开悟不是因为太难，而是因为太简单，简单到让你无法想象。就好像鱼儿生活在水中，因为朝夕相处，从而忽略了水的存在；就像我们每天呼吸的空气，因为免费提供，从而常常忘记空气的存在一样。</p><p>人类可以发明原子弹，登上月球，探索火星，因为人类有地球上最聪明的大脑。</p><p>但是开悟与大脑无关，与知识无关，与经验无关。要说困难，这就是唯一最难理解的地方。因此最简单的办法就是放弃所有大脑的努力，一旦如此，属于你的悟境立刻显现。</p><p>开悟是存在的，这一点毫无疑问。</p><p>我以自己十多年的修行经验和最后的体验成果，并以自己生命的最高荣誉发誓：不要有任何怀疑，开悟是百分之一千存在的，就好像我们每天睡觉的床，走路穿的鞋子一样真真切切，实实在在。</p><p>至于如何开悟？</p><p>开悟之后究竟是个怎样的状况？</p><p>本人将在天涯发帖，与广大爱好修行的人，一起分享这其中的无限秘密。</p><p><strong>01 人生一世最大的成就是什么？</strong></p><p>莫言在东南亚大学的演讲中曾经提到：人类社会闹闹哄哄，乱七八糟，灯红酒绿，声色犬马，看上去无比的复杂，但认真一想，也不过是贫困者追求富贵，富贵者追求享乐和刺激，基本上就是这么一点事儿。</p><p>他还在演讲中提到，无论富人还是穷人一生中都面临四大诱惑：金钱、名利、权势、美色的诱惑。</p><p>莫言说的没有错，只是他说的还不够全面，他只说出了一半的真理。</p><p>还有一半的真理是什么呢？</p><p>说是真理，只是针对大脑层面的人来说的，其实根本谈不上真正的真理，那么另一半所谓的真理究竟是什么呢？</p><p>另一半的所谓真理就是：有非常稀有的人在满足物质、精神需求之后，苦苦追寻心灵的需求，他们渴望宁静、淡泊、安详、喜乐。（说明：本帖所说的心灵世界就是佛家所说的人所具有的‘佛性‘‘真我’，也就是开悟的状态）</p><p>他们在满足了物质层面、精神层面的需求之后，忽然觉得内心深处好像还有个小孩很饥饿，还有个小孩非常闹腾，因为他开始苏醒了，他也需要成长。</p><p>很多年前香港著名影星张国荣就是非常典型的案例：据说张国荣在跳楼自杀时，他的个人账户里有大约3亿美金的存款，这样说张国荣根本就不存在物质上的困惑，另外张国荣的事业也是风生水起，演戏、唱歌、电视剧样样火红，论成就、论成功也算是首屈一指，在精神层面，也算成功，那么他为什么还要选择自杀？</p><p>因为张国荣在以上两方面都获得满足后，忽然内心的另外一个小孩苏醒了，那个小孩就是心灵小孩，他感到非常无助，他以前从来没有注意到在心灵深处还有个小孩，他一直以来都忽略了这个小孩的存在，要怎样才能让这个心灵小孩成长呢，要怎么样才能照顾好这个心灵小孩呢？要去哪里才能获得心灵小孩的奶粉呢？</p><p>他太迷惑了，他禁不住心灵小孩的折腾，于是他选择极端的方式结束了自己和心灵小孩的生命。</p><p>要获得心灵层面的丰富人生绝对是比物质层面、精神层面的人生的满足还要奢侈一万倍的事情，因为这是完全不同的另外一种游戏，当一个人已经习惯了，已经熟悉了物质和精神层面的所有游戏，突然要去玩一种完全不同的游戏，结果只能是无所适从，结果只能是更加迷茫。</p><p>因为心灵层面的游戏不是靠计划、靠执行、靠努力、靠争取、靠奋斗能够获得的，相反，心灵层面的人生实现需要的是：不努力、不争取，需要的是放弃、放下。</p><p>心灵层面追求的是平凡，精神层面追求的是非凡，心灵层面追求的是淡定，精神层面追求的是激昂，心灵层面越努力越挫折，精神层面奋斗就可实现，心灵层面需要做减法，精神层面需要则要做加法。</p><p>差别实在太大，追求心灵层面的生活。生活在完全开悟的状态下，绝对是非常奢侈的，地球上不会到百万分之一的人有这种福气。</p><p>在物质上成功，在精神上成功，目前在中国都已经达到了5%，也就是说100个人中，至少有5个人可以在自己的人人生中通过努力奋斗实现财富和精神上的极大满足，但是只有百万分之一的人才有可能深入到心灵层面。</p><p>但是，无论我们物质上多么富有，事业上多么成功（精神层面），挫折感一直都在那里，我们总会重复生活的悲剧，在物质和精神面从来没有圆满的人生，只有充满挫折和困惑的人生。</p><p>要如何才能进入圆满的心灵层面呢，我们如何能够一窥开悟状态的美景呢？</p><p>有三条途径：</p><p>第一， 通过静心，静心的方式有很多种，如瑜伽、打坐、禅修等，在这种静坐之中，慢慢让大脑里的各种思维安静下来，让自己的肉身彻底放松，然后就有机会打开心灵之门，大脑一直是个干扰，唯有大脑安静下来，心灵之门才可以打开，请问世人有几个可以让大脑安静下来的，据不完全统计，每秒钟我们的大脑就要处理几万个信息，如此多的信息冲击大脑，如此多的念头穿梭大脑，让大脑安静下来绝非易事。</p><p>第二， 通过专注，专注一直是一条通往心灵之门的非常好的道路，专注是一种注意力非常集中的努力，但是这样的努力其实一直都没有用，唯有在我们专注到极致时，然后在放下专注的那一瞬间，在放弃专注的所有努力后的那一瞬间，我们就有机会踏入心灵之门，专注的过程一定穷尽一切努力，这极致的努力只为最后那一刻突然地放下，在极致努力和忽然放下的间隙中，有一个机会，那就是大脑彻底绝望的空隙，我们便可以步入心灵之门。</p><p>第三， 通过爱，爱一直是直接进入心灵之门的最直接最短的距离。</p><p>但是遗憾的是我们在这个物质世界、在这个到处都鼓吹成功人生的励志世界，早已经失去了爱的能力。我们一直都害怕爱，我们一直都逃避爱，我们一直都糟蹋爱。</p><p>如果你爱鲜花，鲜花中就有心灵世界一切的美丽，如果你爱音乐，音乐中就有心灵世界一切的灵感，爱就是心灵世界里最好的礼物，一个活在心灵世界的人一定是个慈悲的人，一定是个友爱善良的人。</p><p>因此，追求财富容易，追求成功也容易，追求宁静、淡泊绝对不容易，因为宁静也好、淡泊也好压根就不是靠努力追求得来的。</p><p>那是一种遇见，因为心灵一直都在你自己的家里，只是因为你一直努力在外面打拼，忽略家里的宝藏而已。</p><p>突然有一天，你已经做出了你这一生所能付出的所有努力，你极度疲惫的回到家里，打开门，心灵就在家里满脸堆笑地恭候着您的光临。</p><p><strong>02 开悟最简单的第四种途径——当下顿悟</strong></p><p>曾经有三到五年的时间，我非常困惑，我几乎读遍了所有的禅宗公案，希望在其中寻找一个答案：什么是开悟？</p><p>看着那些禅宗大师每时每刻停驻在开悟状态，十分羡慕，但是，我不知道，我也无法体验那样美妙无比的状态。</p><p>我甚至怀疑那样的状态是不是一种幻境，是不是一种秘而不宣的欺骗，也就是说所谓的开悟根本不存在。</p><p>那些看起来无比荒唐的禅宗公案：什么师傅用木棒敲一下徒弟脑袋，什么师傅大喝一声弟子，什么师傅把徒弟手指砍掉，然后弟子一瞬间开悟了。</p><p>然后我就想，好神奇啊，这么简单，我特么希望找个师傅把我打一顿，然后奇迹就发生了。</p><p>但是遗憾的是，奇迹一直没有在我身上发生。</p><p>直到有一天，我遇到一个其貌不扬的年纪不较大老师，是个女的，个子不高，长着一张圆圆的脸，不爱与人多交流。</p><p>那一天，我今生今世永远都不能忘记，我看到她在看一本《金刚经》，于是非常有兴趣上前请教：“某老师，您也喜欢《金刚经》呀，我也好喜欢，就是看不懂，《金刚经》里有句话说‘过去心不可得，现在心不可得，未来心不可得’，请问这句话究竟说的是什么？”</p><p>只见她头也不抬，也不吭声，突然之间，她迅速站起来，右手猛拍桌子，大吼一声“我凭什么告诉你！”</p><p>我猝不及防，被她这种完全出乎意料的反应吓呆了，我想我的魂魄可能在那一瞬间也被吓出体外了，脑袋里好像被掏空一样，干干净净，一无所有，完全丧失了所有的思考和应急反应。</p><p>就在我的大脑失去思考能力的时候，我在那一刻遇见了一种自己从未经历过的现象，当时我并不知道那种状态究竟是什么。</p><p>那一刻，周围异常的安静，我没有思考，也没有任何念头，虽然没有思考，没有念头浮现在大脑，我也不知道我在那里，根本就没有了我的存在，但是对周围却有一种异常清晰的觉知，也就是“没有觉知者但觉知正在进行，没有观察者但观察在发生”，内心异常的清明透彻，整个人除了丧失了思考能力之外，浑身上下非常敏锐。</p><p>我没有任何焦虑，没有任何担心，也没有兴奋，只是感知到异常的宁静，时间观念没有了，我停留在那一瞬间，好像永恒。</p><p>我就像一条清澈透底的小溪流，缓缓流淌，小溪映照着蓝天白云和两岸的美景，一切都是那样的和谐，我就是那样的透明清澈，一切都收纳与心中，不做任何评价，只是敏锐的保持一种全方位的觉知状态。</p><p>也好像一口波浪不惊的古井，安安静静地立在那里，所有来井边打水的人，我看得一清二楚，但是没有任何念头浮现，只是反射和观察。</p><p>我无比的震惊，我知道自己根本还没有准备好迎接这种生命的全新状况，我几乎用了将近一个月的时间才从那次震惊中适应过来。</p><p>我现在知道了，那就是完全脱离我们的身体和精神的另一种存在形式，我给这种生命的全新存在形态命名为心灵，也就是人处于开悟的状态。</p><p>这就是我经历开悟状态的一次奇遇。</p><p>也就是禅宗最喜欢的开悟方式：当下顿悟。</p><p>当下顿悟可以说是开悟最直接最快速也最简单的途径，但是在这之前，我们必须经历九九八十一难，经历所有能够经历的一切，思考所有能够思考的疑问，然后就在某个机缘巧合的时机，你就会遇见。</p><p>自从那次遭遇后，我忽然之间一下子明白了几乎所有的禅宗公案，那就是一通百通，原来他们都是用他们彼此之间能够理解的方式在交流，局外人根本听不懂。</p><p>就好比我们修行的人都是中国人，而人家开悟的人都是说俄罗斯语言一样，完全是两个不同地方的人，彼此说彼此国家的语言，怎么能够相互理解。</p><p>唯一的办法就是你必须成为俄罗斯人，然后，所有的一切你都明白了。</p><p>因为所有开悟的人在交流时，他们的语言都是来自心灵，而不是大脑，一个生活在大脑世界的人怎么可能理解一个生活在心灵世界的人？</p><p>要想在某一天顿悟，现在你就需要做好充分的准备。</p><p><strong>03 我见证了父亲的开悟时刻</strong></p><p>我父亲患有老年糖尿病十多年，去年三月份因为糖尿病引起的多种并发症紧急住院，在医院住了大约三个月后，转入高危病房，然后一个星期后，所有的医生和人类现今发明的所有最先进的医药已经无能为力了，医生们终于承认无药可救了。</p><p>医生宣布，我父亲熬不过一周，赶快接回家。</p><p>由于父亲顽强的求生欲望，回家后用自己坚强的意志力坚持了15天，才离开这个他恋恋不舍的世界。</p><p>这15天里，我几乎是24小时寸步不离，我记得很清楚，回到家中的第四天晚上，昏迷中的父亲忽然神奇般地清醒过来，看看时间，是晚上2点半，而且父亲居然还能开口说话：“儿子，你怎么不把外面的人招呼进屋坐。”</p><p>我抬头看看窗外，没有人，于是问：“外面是谁呀，爸爸？”</p><p>“外面是我。”</p><p>我在此慎重声明：本人没有任何杜撰、没有任何故弄玄虚，只是真实客观记录当时与父亲最真实的对话，我不是唯物主义，也不是唯心主义，我坚持分享我自己亲眼所见、亲耳所听、亲身体验的东西。</p><p>其实在这次对话之前，我早已经确切了解到人类的确是除了身体和精神之外，还有第三样东西的存在，有些人称之为灵魂，人的身体只是一个房子，父亲的身体早已经千疮百孔，他的灵魂离开自己这座危房也是情理之中的事情。</p><p>“这么晚了，你在外面干什么？”我没有一丁点的害怕，我迫切希望与父亲的灵魂来一次深层次的对话。</p><p>“我打算去旅游。”父亲的语言很清晰，很空灵，不像是从身体里发出来的，而且折磨父亲多日的剧烈疼痛好像已经停止了。</p><p>“你一个人去吗？”</p><p>“还有你奶奶。”奶奶已经于2014年8月1号去世。</p><p>传说中一个人要离开人间，阴间有亲人来接，也大概是真的了。这是另外一种讽刺：历史常常是人为杜撰的，而传说恰恰是真的。</p><p>“你要去哪里呢？”</p><p>“去很远很远的地方。”</p><p>“那你什么时候回来？”</p><p>“不回来了。”这是父亲的灵魂在与我告别。</p><p>“爸爸，你要不要准备点东西才出远门，衣服、零钱之类？”</p><p>“我不需要了。”对于一个即将离开的灵魂，人世间的一切都是微不足道的。</p><p>“但是出远门，还是带点钱吧。”</p><p>“我不需要了，钱财如粪土，孩子。”</p><p>父亲一辈子把钱看得比生命还重要，此时此刻，父亲居然说“钱财如粪土”，这是一种纯粹的了解，这是一种彻头彻尾的解脱。</p><p>活着的人有几个看得透“钱财如粪土”，为钱财，兄弟反目成仇者有之，夫妻对簿公堂者有之，正在活着的人远没有即将离开的人活得明白。这又是另外的一种讽刺。</p><p>“你不回来了吗？”我继续问。</p><p>“不回来了。”</p><p>“留下妈妈，你放心吗？”我其实还想问：“爸爸，你还有儿女，孙子、外孙，你不留恋吗？”</p><p>“那已经不关我的事，那是你的事情。”</p><p>我是家中的长子，父亲早在衡阳附一ICU病房里，在我去探望他的时候已经交代清楚：在他离开后，母亲的一切——生、养、死、葬，都由我一个人负责，另外我还要帮助姐姐和弟弟，让他们过上更好地生活。</p><p>对于父亲这样的安排，我觉得自豪，因为我非常清楚，只有在父亲内心深处觉得他的大儿子有能力承担这一切的时候，他才可能做这样的安排。</p><p>中国传统文化中有句话“长子当父”，我在父亲无能无力即将离开这个世界时，深刻领悟了这句话的内涵。</p><p>最终，我的所作所为，我想父亲会为我感到骄傲的：我承担了父亲三月份、四月份、五月份以及父亲在ICU病房五天时间里，每天一两万的所有费用。</p><p>当然，在我内心深处，我为父亲所花费的任何费用，都是无怨无悔的，因为姐姐和弟弟经济条件相对来说会弱一些，我从来没有任何念头说希望姐姐和弟弟分担一些，我作为家中长子，我乐意去承担，这是为人儿子义不容辞的责任。</p><p>听了父亲这些语言，我很清楚地知道，父亲此时与我的谈话，已经不是平常的父亲，父亲此时此刻已经开悟了，虽然短暂，但是在经历与死神搏斗的三个月时间后，居住在父亲身体里的那个心灵苏醒了。</p><p>父亲此时此刻的语言，都是在心灵苏醒之后，心灵清晰地关照自己，周围环境发出的语言。</p><p>父亲是如此平静，从容，一改往日狂躁的心情，父亲继续说：“你要把你妈妈照顾好，我这一辈子，最对不起的是你妈妈。”</p><p>这句话，依照父亲的性格，平时是不可能说出口的，因为父亲属于超级大男子主义，几十年以来，一直都在欺负妈妈，根本就没有妈妈发表任何意见的机会。</p><p>第一次， 父亲表现出对妈妈的公正，我知道，这时的父亲正处于开悟状态。</p><p>这里需要多说几句，很多人有种误会，以为智慧、宁静、从容、慈悲等品质是开悟的特征，其实不然，开悟本身没有任何特性，这些东西如慈悲、爱、宁静等还是属于大脑层面，只是人一旦开悟后，在开悟的关照下，我们的身体，我们的精神会表现得更好而已。</p><p>我反复强调: 开悟就是当下的觉知和关照而已。</p><p>开悟就像一面镜子，当我们的身体来到镜子面前，看到脸上脏兮兮，我们自然会去洗脸，当我们的思维来到镜子面前，看到自己的思想狭隘，自然会嘲笑自己一样。</p><p>开悟就是那个质检员，时刻检阅我们的身体，我们的精神，从而会让我的身体和精神呈现出更好品质。</p><p>我和父亲的对话大约半个小时，之后父亲再次陷入昏迷，直到离开这个世界。</p><p>一个即将离开的人就是一个彻底解脱的人，因为他是真的知道，很多东西他再也抓不住了，在他意识到他什么东西都抓不住的时候，一定有某一个时刻来临，那个时刻就是他真正开悟的时刻。</p><p>我说过人的一生都会有机会开悟，只是时间早晚的问题，所谓大师，佛陀，只是他们停留在开悟的状态时间比凡人要久一些，无他。</p><p>请仔细阅读这段话：</p><p>这里需要多说几句，很多人有种误会，以为智慧、宁静、从容、慈悲等品质是开悟的特征，其实不然，开悟本身没有任何特性，这些东西如慈悲、爱、宁静等还是属于大脑层面，只是人一旦开悟后，在开悟的关照下，我们的身体，我们的精神会表现得更好而已。</p><p>我反复强调: 开悟就是当下的觉知和关照而已。</p><p>开悟就像一面镜子，当我们的身体来到镜子面前，看到脸上脏兮兮，我们自然会去洗脸，当我们的思维来到镜子面前，看到自己的思想狭隘，自然会嘲笑自己一样。</p><p>开悟就是那个质检员，时刻检阅我们的身体，我们的精神，从而会让我的身体和精神呈现出更好品质。</p><p>这段话是重中之重，也是所有的核心所在。能理解这段话，你离开悟不远了。</p><p><strong>04 开悟就是找到第三个“我”在哪里</strong></p><p>开悟一直都被无数修行人当做最高的成就，并且将开悟赋予了无数多神奇的特性，仿佛一个人一旦开悟，便能眼观六路耳听八方，便能够上看一千年，下看一千年。</p><p>其实不然，开悟其实什么也没有，开悟最终的结果只为寻找那个一直跟随我们的透明人、隐形人而已。</p><p>人一直都是由三个“我“组成，身体我，大脑我和心灵我。</p><p>身体我很容易找，因为看得见摸得着，这个人长的帅不帅，身材好不好，身体是不是很健康，一看便知，因此绝大多数世人都把时间花在喂养身体我上面，吃喝拉撒成了他们一生最主要的追求。</p><p>大脑我也很容易感知，我们学习、我们讨论，我们思考、我们辩论、我们高兴、我们生气，都是很容易被感知的，那个念头在头脑中升起，我们很容易抓住。因此一部分人在满足物质需求后，开始追求精神的升华。</p><p>唯独第三个我很难找到。</p><p>何也？</p><p>因为第三个我——心灵我是透明的，是隐形的。</p><p>佛曰：无我相，无人相，无众生相，无寿者相，即为是也。</p><p>佛又曰：一切有为法，如梦幻泡影，如雾亦如电，应作如是观。</p><p>此两句，不知难住了多少修行人，苦苦修行，苦苦参悟，最终不得要领。</p><p>绕来绕去，始终停留在大脑层次的理解，以为通过大脑的理解，便可以参透其中奥秘，其实这样越努力，越迷失。</p><p>因为心灵是没有大脑的状态，企图通过思考、通过比较、通过分析、通过讨论、通过记忆、通过背诵、通过熟读经典，就觉得自己可以找到心灵我，恰恰是努力的方向错了，大脑越努力，最后越纠结，因为大脑如何做到“无我相，无人相，无众生相，无寿者相”，大脑只要一动，就是“有我相，有人相，有众生相，有寿者相”，这样不就是走进了死胡同吗，心灵要的是“无”，但是大脑一运作就是“有”，如何破解这个难题，根本无解。</p><p>放弃一切大脑的努力，立即杀死大脑，心灵马上就呈现出来。</p><p>问题是如何杀死大脑呢？</p><p>如何达到没有大脑的状态呢？</p><p>禅宗大师们最喜欢的两种游戏就是：</p><p>第一，制造混乱，制造不合逻辑的情景。因为大脑能够理解符合逻辑的事情，不符合逻辑的事情，大脑就会短路，大脑就会死机，在大脑短路和时机的那一瞬间，大脑就暂时休眠了，心灵就有机会出现。</p><p>禅宗大师喜欢玩的第二种游戏就是当头喝棒，在弟子们完全没有预兆的情况下，突然之间做出荒唐的举动，大脑来不及反应，猝不及防，此时大脑也会死机。与第一种游戏效果一样。</p><p>我们不妨看一则禅宗公案：</p><p>马祖禅师到怀让禅师那儿学道，每天都坐禅，而且很用功。</p><p>有一次怀让禅师问马祖：“你坐禅是为了什么？”</p><p>马祖说：“为了成佛呀！”</p><p>怀让就拿了一块砖磨了起来，马祖觉得很奇怪，问他磨砖做什么？</p><p>怀让说：“把它磨成镜子。”</p><p>马祖很是疑惑，说：“磨砖怎能磨成镜子呢？”</p><p>怀让答：“磨砖既不成镜，坐禅又怎么成得了佛呢？”</p><p>你看，这就是师傅在制造一个荒唐的情景，让徒弟看到完全不合逻辑的地方，从而让徒弟有机会放弃大脑，哪怕只有一秒钟。</p><p>成佛也好，开悟也好，不在于坐。在于能否放弃大脑，没有执着、没有挂碍，不在于坐的姿势好不好、坐得久不久、腿痛不痛，这是毫不相关的。</p><p>如果像马祖那样不断地打坐，马祖可能成不了马祖，也开不了悟。一旦他明白砖头磨不成镜子，打坐也成不了佛，对打坐的执着就放下了。</p><p>第三个我很难直接描绘，但不是不能描绘，打比方、象征、类比、讲故事等都是非常好的方法。</p><p>一旦找到第三个我，其实会让人很失望，如果之前怀有很高的期待，一定会失望。</p><p>第三个我是透明的，无色无味、无形无影，没有任何特异功能。</p><p>第三个我只是当下的“不观照的观照，不观察的观察”，因为第三个我的苏醒，就像一个严格的质检员，认真观照每一句说出口的话，每一个闪过头脑的念头，从而赋予了我们说出去的话和头脑中出现的思维不同的品质而已。</p><p>也就是第三个我的苏醒，在客观上能够让第一个我——物质我，第二个我——精神我表现得更好，而这里的难点在于：第三个我并不提出任何改正的建议，他只是一束光，三百六十度照亮思维的误区和思维的狭隘，从而让思维自己去做调整而已。</p><p>第三个我只是一面一尘不染的镜子而已，他很安静，只是当下反应和观照，无他。</p><p><strong>05 捐出100万还要说谢谢</strong></p><p>下面是一个非常有趣的故事，但你不一定懂：</p><p>有一个得道的大师，因为远近闻名，前来听他布道的信徒络绎不绝，很快，大师的道场就显得非常拥挤，于是，大师计划建造一个大一点的道场。</p><p>大师根本没有钱，因为大师并没有把时间和精力放在赚钱上，他的布道是免费的，他生活在智慧里面。</p><p>有一个非常富有商人，知道这件事，于是决定捐赠100万来帮助大师建成新房子。富商手里提着100万现金准备交给大师。</p><p>大师说：“好的，你放下。”</p><p>富商把钱给了大师，但是他非常不满意大师的态度，因为他是给了一笔很大数目的钱，整整100万，现在一个人全年的生活费都只需要一万元，而大师甚至都没有谢谢他。</p><p>“那个袋子里有100万。”富商提醒道。</p><p>“在此之前你已经告诉过我了。”大师说。</p><p>“就算我是一个富有的商人，100万也算一笔不小的钱。”富商继续说。</p><p>“你是不是想要我为此谢谢你？”大师说。</p><p>“出于礼貌，你应该谢谢。”富商说。</p><p>“为什么我应该感谢你呢？”大师说，“相反，你应该谢谢我。”</p><p>富商很生气，觉得大师太怪异，简直不可理喻，同时他觉得自己是个冤大头，自己很傻很天真。</p><p>这是什么逻辑？</p><p>捐钱的要感谢接受捐赠的，这简直太荒谬了。</p><p>大多数人看不懂这个故事，这就对了，生活在大脑层面的人永远无法懂得这个故事深意，因为大脑是狡猾的、是精于算计的，大脑能理解符合逻辑的事情，但是如果某件事不符合逻辑，大脑立刻像白痴一样，立刻短路，因为从任何一个角度来说，都不可能让一个捐出 100 万的富商去感谢一个接受捐赠的人，这完全不符合逻辑。</p><p>当代社会是一个充满交易、算计、掠夺的糟糕时代。我们的大脑已经被训练得无比聪明，我们做任何一件事都会在大脑中进行精心算计，算算做某件事的性价比。</p><p>慈善活动变成了秀场和生意场；爱心基金变成了偷税漏税的遮羞布；美色权力变成了交易的廉价筹码；还有哪件事不是一场交易呢？</p><p>在这个处处都充满交易的时代，几乎所有的关系都变了味，什么干爹、什么干妈，什么兄弟、什么同乡，统统围绕着利益在转动。</p><p>这一切都是大脑的诡计，故事中的富商一直在算计，100万的投入可以为自己赢得多少美誉，可以为自己树立一个多么崇高的形象，但是大师甚至连一声谢谢都没有，这太无理了，这对富商来说，对一个精明的大脑来说简直不可理喻。</p><p>但是大师是完全脱离大脑的，他生活在心灵世界中，他没有算计，他没有期待，在他的世界里没有交易，他所有的布道全是免费的，他只有一颗救世度人的慈悲心，他希望建一个更大的道场，他纯粹是希望有更多的人得到感召，得到救赎，他不需要任何回报，他每时每刻都在感谢那些远道而来的客人，他感谢他们对自己的信任，他感谢他们对真理的追求和对真理的敬重。</p><p>大师生活在一个洋溢的世界中，他的心灵是如此清澈，因而他的智慧是如此丰富，他需要不停地分享和给与，他不得不去分享，他不得不去给与，分享得越多，给与的越多，他的心灵就愈加清澈透明。</p><p>他就好像一座深不见底古井，如果没有人源源不断地把井水打走，全新的井水就无法涌进来，当有越来越多人到他这口古井打水，他的井水就会更加清凉，干净。他将换发更加强大的活力，他将每时每刻都生活在鲜活中，因此大师需要感谢那些前来不断取水的人。</p><p>大师在不断给予，但是无时不刻都心怀感激，感谢那些前来接受洗礼的人，感谢那些信任自己并一直陪伴他的人。因为他们的存在，他的生命才如此洋溢、他的生命才如此鲜活。</p><p>大师一直都在感谢那些前来接受布道的人。</p><p>因此大师说：“你应该谢谢我。”</p><p>显然，富商不明白大师的意思，一个大脑世界的人和一个心灵世界人站在一起，根本无法对话，因为大脑和心灵完全是一个不同的世界。</p><p>大脑是索取的，心灵则观照出奉献的一面；</p><p>大脑是算计的，心灵则观照出分享的一面；</p><p>大脑是精明的，心灵则观照出天真的一面；</p><p>大脑是复杂的，心灵则观照出简单的一面；</p><p>大脑是浑浊的，心灵是清澈的…</p><p>当大师说：“你应该谢谢我。”大师是站在自己的角度，是站在心灵层次的角度说这句话的，因此他不需要对富商说谢谢，相反富商需要对大师说一声谢谢。</p><p>因为大师的缘故，他的100万建成了一个更大的道场，将有更多的人收益，大师完成富商功德的传递，在这件事上，大师只是一个媒介，大师只是一个桥梁，富商通过大师完成了自己无上功德的奉献。</p><p>而且因为大师的接受，这样就完成了富商生命的真正流动，富商不再是一个守财奴，他的生命也开始流动了，而流动恰恰是生命的真正意义所在。</p><p>因此给予者应该感谢，感谢那些接受馈赠的人。</p><p>有一次，夫人在整理衣服时，发现很多旧衣服，无论质量、款式、做工等都不错，但是衣柜已经无法装下那么多，男人们要清楚，女人的衣柜总是嫌小，夫人的衣服已经塞满了整个衣柜，需要清理，但是这么多还算不错的旧衣服如何处理呢？</p><p>夫人一直纠结这个事，送给别人吧，觉得很难为情，毕竟是自己穿过的衣服；但是扔掉吧，心里又觉得十分可惜，女人就是这样的动物，衣柜里永远都缺一件衣服，但是旧衣服又从来都舍不得扔掉。</p><p>送给别人，担心伤害别人，于是很纠结。</p><p>不久，老家来了两个亲戚，闲聊中间，夫人拿出她的收藏，她小心翼翼地试探，拿出几件衣服给她们试穿，结果她们很喜欢，夫人就顺势送给了她们，她们很高兴，夫人更是高兴，高兴她们能够喜欢，高兴她们能够接受，夫人心中充满了感激。</p><p>感激她们没有嫌弃，感激她们能够快乐接受，感谢她们完成了一次生命的传递和流动。</p><p>因此馈赠者应该感谢，接受者才是真正的天使。</p><p>但是一旦某项馈赠包含了某种期待、同时在给予时一直在期望回报时，这样的给予将一文不值。这样的给予就是一种侮辱，是一种亵渎，是可不原谅的。</p><p>给予就必须是无私的，无所求的，必须是心怀感激的，否则就收起我们那一颗虚伪的面孔，做回一个拥有精明头脑的人。</p><p>大多数人看不懂这个故事，这就对了，生活在大脑层面的人永远无法懂得这个故事深意，因为大脑是狡猾的、是精于算计的，大脑能理解符合逻辑的事情，但是如果某件事不符合逻辑，大脑立刻像白痴一样，立刻短路，因为从任何一个角度来说，都不可能让一个捐出100万的富商去感谢一个接受捐赠的人，这完全不符合逻辑。</p><p><strong>06 大脑的死穴</strong></p><p>大约在我28岁到30岁那几年，对于禅文化特别着迷，遗憾的是，自己根本看不懂，于是乎较上劲了，我根本不相信会有我看不懂得书籍，这一本看不懂就换一本，这位大师写的看不懂就换另一个大师写的，前前后后总共阅读了大约300本左右关于禅文化的书籍。</p><p>结果是越看越糊涂，越看越不明白。</p><p>随便举一个禅宗公案：</p><p>司马头陀在大伪山找到了一块风水宝地，他想找个有道行的人来开辟道场。于是来到百丈禅师处选拔人才。待大众聚齐，司马头陀手举净瓶说：“这不是净瓶，谁能说出这是什么？”</p><p>在场大众茫然不知所答。</p><p>这时，从后面挤上来一个脏兮兮的杂务僧说：“我可以试试吗？”</p><p>“可以啊”！司马头陀说。</p><p>杂务僧接过净瓶，放地上，猛地飞起一脚，将净瓶踢出墙外。</p><p>司马头陀大笑说：“这才是大伪山真正的主人啊！”</p><p>请大家说说：司马头陀和杂务僧的奇怪动作，在向对方传递什么信息？其中又暗藏了什么玄机呢？</p><p>如果你看到这个公案，看到上面的提问，于是在大脑里一直思索，寻找答案，那么你就上当了，在大脑层面，你将永远找不到答案。</p><p>正如我当年陷入困境一样，对于大师级别的对话或者大师之间发出的奇怪行为，总是企图在大脑层面寻找答案，无异于缘木求鱼，越努力越挫折，因为答案不在脑袋里。</p><p>谜底就是：答案在心灵层面，如果无法跳跃到心灵层面，上面的公案，你一辈子都不可能明白。</p><p>对于大脑来说，可以学会逻辑分析、技巧方法等，这些都没有问题，但是对于不合符合逻辑的语言和行为，大脑就会疯掉。</p><p>而心灵恰恰相反，心灵是没有逻辑的，心灵是一种跳跃，是一种领悟，一种非逻辑。</p><p>公案一开始，司马头陀就提出了一个不符合逻辑的问题：“这不是净瓶，这是什么？”</p><p>一个不符合逻辑的问题，大脑如何分析，如何能够给出答案，但是司马头陀是一个得道的大师，这一点没有疑问，他是从心灵层面、从本质出发而提出这个问题。</p><p>是一个师傅，但是他需要借由这个非逻辑问题来甄别，面前几百号门徒，究竟哪一个已经完成了跳跃。</p><p>绝大多数保持沉默，说明绝大多数还停留在大脑层面，那个飞跃、那个质变还没有发生。他们依然执着于寻找一个合理的答案，他们依然停留在大脑层面，他们依然没有深度，他们还没有锐变。</p><p>一个脏兮兮的杂务僧从后台走出来，在修行的道路上似乎总是这样，越平凡的人实现跳跃越容易。一个毫不起眼的杂务僧他的内在已经突破了，那个质变已经在他的内在发生了，他知道司马头陀的问题是荒谬的、甚至是愚蠢的，根本是没有答案的，既然没有答案，又何必浪费口舌。</p><p>于是，他一脚就踢飞了那个净瓶。直接粉碎了大脑的所有执着，当绝大多数门徒在那一霎那间，肯定有一个片刻，这个片刻大脑是不能思考的片刻，如果对于某些已经准备好的门徒来说，这个片刻是千金难买的，只要这个片刻，大脑短路的短暂片刻，那些已经准备好的门徒完全可以借由这个片刻对心灵世界，对自己的核心本质有一个电光火石般的瞥见。</p><p>对于司马头陀和杂务僧来说，完全没有问题，他们实现了心灵层面的交流，他们彼此都懂对方。</p><p>大师之间的交流都是这样，看似荒唐，实则彼此心心相映。</p><p>心灵层面发出的问题，必须由非逻辑方式解决。一个不遵循逻辑出牌的师傅他需要看到一个同样不按逻辑出牌的高徒。</p><p>那个问题就是一个阴谋，一个试探，如果你按逻辑出牌，那就证明你还没有锐变，你还在大脑层面思索答案，你就不是他要寻找的人。</p><p>心灵层面发出的问题，必须由非逻辑方式解决。一个不遵循逻辑出牌的师傅他需要看到一个同样不按逻辑出牌的高徒。</p><p><strong>07 如何观察一只杯子由你的深度决定</strong></p><p>某天下午，与几位老友喝茶，面前放着一只青花器茶杯，所谓老友就是小区里上了年纪的几个老大哥，他们退休后闲暇时间最爱到我办公室喝上几杯，而且每次来都喜欢带上几本国学或者佛学方面的经典，与我一起探讨。</p><p>无论他们带多少本国学巨著抑或带上多么经典的佛学经书，也不管他们有多大年纪，在我看来，他们还基本上不入门。因为一个有悟性的人，一个受到国学、佛学浸染的人，一举一动、一言一行都会表现出与众不同的端倪，一个真正有深度的人是根本藏不住的。这与他们的年龄和手中的书毫无关系。</p><p>况且佛学经典根本不是用来读的，读佛经完全是扯蛋，所有的佛学经典是一种体验科学，需要体验、感悟和升华，是需要用“悟”去感受的。越是依赖大脑，离佛经越远，佛学不是来自大脑，而是来自心灵层面，用大脑去读心灵层面的智慧，这本身就是一个笑话。</p><p>歌后王菲经常换老公，世人各有评说，但是其中有一个人，评价最为深刻，就是的陈道明，他说过一句话：“王菲过去所经历的每一个男人，最多停留在精神层面，没有一个达到心灵层面，但是王菲已经是一个处于心灵层面的人，于是内在的渴望迫使她去不停寻找那个可以和他匹配的男人。”</p><p>不用说陈道明绝对是一个有深度的男人，因为只有一个老子一样的人物才可以读懂老子。</p><p>两位老大哥开始向我推荐国学经典和佛学，并不停背诵其中经典的句子，我礼貌地点点头，我看到了某种可爱，同时也看到了某种虚荣，为了让他们安静下来，我开玩笑问：“两位老哥，仔细看看你们面前的茶杯，你们看到了什么？”</p><p>一个说：“茶杯不错，花纹很别致，做工精细，属于上等茶杯。”</p><p>另一个说：“这个茶杯颜色饱满，用材考究，用来泡茶，味道纯正。”</p><p>还有吗？我继续问，虽然两位大哥继续补充了一些，但基本上停留在上面层次。</p><p>一个茶杯，不同深度的人来观察，观察到的结果会相差非常遥远。</p><p>首先说花纹，上等茶杯的花纹必定是经过大师级的人经过精心描绘而成，大师出品必是精品，大师在描绘花纹的过程，不仅注意力高度集中，而且会充分投入了他的情感和灵魂，一个大师绝不会允许自己手下的作品粗制滥造，好比一个优秀的歌唱家，唱歌不仅不能跑调，最为关键的是歌声中必定饱含情感和人生的领悟，听者才会心有戚戚。</p><p>一个饱含了大师心血和情感的花纹，虽然静静地刻在杯子上，没有一颗敏锐的心是无论如何也感受不到的。</p><p>再说烧制杯子的经过，一只小小的茶杯，如果是纯手工制作，必是经过能工巧匠的精心打磨，反复烧制而成，大家都知道，茶杯的烧制过程不可能一次成型，需要反复烧制，在烧制的过程中，每时每刻都需要小心翼翼，犹如看护一个襁褓中婴儿，不得有些许的大意，从这个方面说，一个茶杯又融入了更多能人的精魂。</p><p>最后说说制作这杯子的材料。</p><p>一个好的茶杯，选材非常考究，需从天地间去精挑细选，然后反复搅拌、揉搓，谁也不知道这块从天地间攫取的材料，已经存在了多少年，或许与地球同岁，这样，这块材料毫无疑问必定承载了日月星辰的灵气，人类历史的兴衰更替。</p><p>这就是真理，当真理说出口的那一刹那，几乎所有的人都会立即感觉到。</p><p>因此，我说面前的茶杯是一个有生命的精灵。</p><p>两位老大哥终于安静下来。</p><p>地球上的人是分层次的，从来没有往深处探索的人，不可能有深度，有的人活一辈子活的非常表浅，就像看一只杯子，怎么看都只能看到外在的表象。</p><p>活在物质层面的人最可怜，一生劳碌；</p><p>活在精神层面的人最折腾，一生困惑；</p><p>唯有升华到心灵层面的人，才可以找到生命的真谛：安详、宁静，淡定、满足、喜乐。</p><p><strong>08 大脑如何装下整个宇宙</strong></p><p>有一个大学教授去请教一位高僧：“什么是道？”</p><p>高僧没有直接作答，只是将教授带到屋后的百花园中，当教授再次问：“请问高僧，道是什么？”时，高僧立即打断教授的问话：“别说话，请享受这里的百花香，你闻到花香了吗？”</p><p>教授深深呼吸一口气，然后说：“好香。”</p><p>高僧：“这就是道，关于道，我没有更多可说的了。”</p><p>那个教授呆在那里，比以前更加困惑了。</p><p>事情就是这样，一个教授带着满脑袋的知识去请教高僧，他企图获得某些概念上、知识上的认知，但是这与道完全就是风马牛不相及的事情，知识越多的人，离道越远，头脑越聪明的人，知识越渊博的人离道越远。</p><p>教授是一个完全活在大脑层面的人，而高僧则是生活在另一个世界中：心灵世界。</p><p>两个不同世界的人其实很难对话，“道”是没有头脑的一种状况，道是一种体验、一种实证，没有时间、没有空间概念的存在感。是一种一个片刻接着一个片刻的存在的状态。大脑如何去理解，大脑无法理解这种状态，大脑需要一个概念，需要一个定义、需要一个记忆，离开概念，离开记忆，大脑就会发疯。</p><p>道和大脑生来就是势不两立的冤家。</p><p>道不可言说，只可以启发，只可以意味，但是究竟什么样的人可以被启发呢？什么样的人才能被点亮呢？</p><p>那些完全抛弃大脑的人才可以被启发，才可以被点亮。</p><p>问题的难点在于：我们从来没有尝试过，过一种完全没有思考活动的生活，头脑中没有任何念头，没有任何努力的状态。我们已经习惯于依赖大脑，没有大脑，我们甚至不知道下一步该干嘛？</p><p>我们不知道往哪里走，因为我们已经习惯做大脑的奴隶，我们采取的每一个行动，说的每一句话，都要经过大脑的处理。</p><p>否则，我们要去哪里，我们该怎样表达？</p><p>完全放弃大脑几乎不可想象。</p><p>然而，道也好，存在也好，真我也好，心灵也好，恰恰是没有大脑的状态，这样一件极简单的事情，因为大脑的干扰变得极为复杂和困难，好像没有谁可以完全脱离大脑而存在。</p><p>我们照样来看一个很美的故事：</p><p>有一天，亚里斯多德正在海边散步，他看到一个人拿着一支汤匙在舀海水，舀到他在海堤边挖好的一个洞。</p><p>亚里斯多德因为有自己的问题要操心，他一边思考，一边延着海边散步，他一步一步走向那个怪人。</p><p>那个奇怪的人一直都非常聚精会神，这让亚里斯多德产生了很大的好奇心：“他在做什么啊？”</p><p>他无法克制住自己的好奇心，但是那个怪人依然那么聚精会神，完全没有注意到他的到来。</p><p>怪人又他走到海边去，舀满一汤匙的海水，再带着海水到堤防边，把它灌入洞中，然后再走到海边去……，如此不知疲倦地往返。</p><p>最后，亚里斯多德不得不说：“等一下！这位老先生，我并不想打扰你，但是您在做什么啊？您这样做真的让我感到非常迷惑。”</p><p>那个怪人说：“你没看见吗，我正打算用整个大海中的水来填满那个海堤坝边上的洞。”</p><p>学富五车、才高八斗的亚里斯多德实在忍不住，终于笑了出来，他说：“你真是个笨蛋，这怎么可能呢？你没看见整个海洋有多么的广大，而你那个洞是多么渺小，你居然想得出来，你要用一支汤匙把整个海洋舀到这个洞？你简直疯了，你这样只是在浪费生命！你是个疯子，赶快回家休息去吧！”</p><p>令亚里士多德发狂的事情发生了，那个怪人，笑得比亚里斯多德还要大声，还说：“你说得没错，我要回家了，因为我的工作已经完成了。”</p><p>亚里斯多德说：“你这话是什么意思？，你已经完成了你的工作？”</p><p>怪人说：”尊敬的大哲学家，你可知道，你一直在做和我一样愚蠢的事情，甚至比我还愚蠢。你现在就看看你的头，看看你的大脑，他是不是它比我的那个洞还小很多呢。我愚蠢到要将整个大海都装到我的那个小洞里，而你，聪明的大哲学家，你看看整个宇宙，整个存在，它是不是比海洋还要辽阔，而你，居然企图将他们装到你的大脑中。”</p><p>那个怪人放肆大笑，而且越笑越大声，而那个哲学家，那个亚里斯多德却早已经傻在那里，完全忘记了自己刚才大脑还在不停思索的问题。</p><p>在一个真人面前，博学的哲学家一直都是个笑话，大脑如何装得下整个宇宙？</p><p>因为这个问题在哲学家看来简直就是无稽之谈，荒谬透顶，根本就是浪费时间考虑这个问题。</p><p>哲学家一直都某个狭隘领域里的偏执狂，但是他们却又特别喜欢装得什么都懂，这样就很麻烦。</p><p>大脑如何装下整个宇宙，在哲学范围内，哲学家会被这个问题折磨到死，然而换一个角度，答案如此简单。</p><p>好比曾经有一个云游和尚，面对大家夸下海口，他说：“三天之内，我有能力让村前的那座大山走到我的面前来。“</p><p>三天之后，奇迹没有出现，而这个云游和尚直接走到大山面前，大声说“既然山不过来，那我就过去，这样大山还不是一样在我眼前吗？”</p><p>心灵是灵活的，大脑是僵硬的，心灵的选择是无限的，大脑的选择非常局限，大脑的选择永远超不出大脑的储存。</p><p>大脑如何装下整个宇宙，我们需要换一种模式，换一种看问题的角度。</p><p>就好像另一个问题：我们到达月球最快的方式是什么？</p><p>答案是：闭上眼睛，意念一动立刻到达，比光速还快。</p><p>闭上眼睛，大脑一瞬间就可以装下整个宇宙了。</p><p><strong>09 开悟常在绝境处</strong></p><p>一万个人就有一万条通往开悟的道路，开悟好比一个圆的中心，从四面八方任何一个点开始，只要朝圆点开始前进，都可以到达这个圆点。</p><p>能够最终到达圆点的人无疑都是他所在领域里最顶尖的高手。</p><p>卖油翁可以成为开悟者，当他离地三尺，将油准确无误地滴入地面一个瓶口很少的瓶子里，而且一滴不漏，那一刻，他就是一个开悟者；</p><p>伯昏无人站在悬崖边，而且半只脚悬在半空，准确无误地射中百米开外的铜钱时，那一刻，他就是一个开悟者；</p><p>开悟对任何人都是开放的，他就在那里，只要你迈开腿向他出发，你就可以到达。从出发点到达圆点的每一步都是修行。</p><p>我们看一个故事：</p><p>曾经有一个医术非常高明的医生，常常手到病除，但是尽管如此，还是有不少病人因为病入膏肓，无力回天，因此这位医生每天在面对病人时，内心都有都惧怕死亡的阴影。</p><p>有一次，这位医生又出去出诊，路上，他碰到一位云游僧，医生于是就请示道：“请教大师，什么叫开悟？”</p><p>云游僧回答道：“施主，实在抱歉，我目前的修行还不能告诉你什么是开悟，但有一点可以确信的是，一旦你开悟之后，你就不用担心什么了，如果你真心想得到答案，你就去找一个师傅，他会给你答案。”</p><p>于是在云游僧的指示下，医生前往参访南隐禅师。</p><p>医师找到南隐禅师后，开门见山说明来意，并请求开示。</p><p>南隐禅师道：“开悟很简单，你既然身为一个医师，就应该好好对待你的病人，那就是你的开悟！”</p><p>医师似懂非懂。</p><p>他前后拜访了南隐禅师三次，南隐禅师总是对他说道：”一位医生不该把时间每天消磨在寺院里，快回家照顾你的病患去，治病救人就是你的最终开悟。”</p><p>医师非常不解，他很困惑，心想：这种开示，怎能袪除怕死的心呢？因此，当他第四次参访时，就抱怨道：“有位云游僧告诉过我，人一旦开悟之后就不会有任何担心。而每次这里，你总是要我照顾我的病患者。难道这就是所谓的开悟？”</p><p>“你四年来，自己觉得有什么变化吗？。”南隐禅师说。</p><p>“我还是很担心我眼前的病人，虽然每次我都会尽力去救治，但是那个担心总是没有办法消除。“医生说。</p><p>这时一条狗恰好从南隐禅师的禅房前走过。</p><p>禅师于是问：“你觉得一条狗会担心吗？”</p><p>医生顿住，觉得有些被侮辱，但是他还是很理性地回答：“没有，师傅。”</p><p>禅师继续逼问：“很好，以后你可以不再过来了，狗就是你最好的老师。”</p><p>医生很是困惑，但是禅师已经闭上眼睛，不再说话。</p><p>这位医生继续行医，兢兢业业，但是从没忘记向狗学习如何不担心，直到临终，他终于悟透禅师的话机。</p><p>为何狗不担心呢？很简单，因为狗终其一生都活在无知无识中，自然不担心。</p><p>人又如何能够活在无知无识之中，从而没有任何担心呢？</p><p>又如何理解南隐禅师一方面告诉医生，去救助你的病人吧，你可以得安心。一方面有告诫医生去向狗学习吧，你可以得安心。</p><p>救助病人是不可能无知无识的，这前后如此矛盾，难怪医生需要一生去参悟。</p><p>领悟这一点，需要一个跳跃，一个包容，而不是用一种非此即彼的思维，谁说矛盾不可以共存？谁说魔鬼天使不可以共处？</p><p>一个包容，让两者共同存在，让无知无识与有知有识同时存在，做到这一点，你就可以看到开悟其实就在眼前。</p><p>我曾说过，任何领域里最顶尖的高手都是开悟者。</p><p>看云飞第一次在星光大道唱《父亲的草原母亲的河》，如此动情，如此感人，唱哭了台下多少评委，感动了电视机前多少观众。</p><p>那一刻，云飞就是一个开悟者，云飞不在了，空气中只有他的歌，云飞和这首歌合二为一；这就是无知无识；同时云飞不可能不在，他在那一刻，只不过是将他的人生、他的情感、他的思想、他的感受完全融入到歌声中而已，这就是有知有识。</p><p>毫不夸张地说，任何行业里最出色的作品都是在这种状态下创作出来。</p><p>我经常说一句话：一个真正美的女人是不知道自己很美的，一个真正很帅的男人也是不知道自己很帅的。</p><p>这非常有趣，需要很好地领悟。</p><p>本文中的这位高明的医生直到临终才领悟禅师的开市，因为只有他来到了那个点，也就是本文开头所说的那个圆点，他才可以明白。</p><p>当他在全心全意地去善待他的病人时，全心全意意味着完全地付出、意味着废寝忘食；而同时自己又完全忘记自己的所作所为，他并没有那个自己善待病人的观念在，即从有心到无心，从有我到无我，从有生到无生，他便脱离了生死挂碍了，他也完成了自己一生的修行。</p><p><strong>10 大脑不死心灵不现（上）</strong></p><p>精神病，一个多么可怕的名词，然而这却是几个世纪以来人类最无知的定义，这个世界其实没有精神病，被我们定义为所谓的精神病患者只不过是他们的思维和情绪被困在某一个狭窄的空间里暂时走不出来而已，他们只是一时的执念，他们只是一群暂时被困在大脑世界里某个狭窄角落里的人。</p><p>具有讽刺意味的是目前绝大多数心理医生也是生活在大脑层面的人，他们自己也是一个不折不扣的精神病患者，只不过他们生活的大脑空间稍微宽敞一些。</p><p>从这个意义上讲，我们每一个生活在大脑层面的人，都是某种程度的精神病，区别只在那个空间的大小。</p><p>打个比方就是：被我们称为精神病患者的，他们居住的可能是地下室只有3个平米大小的笼房，精神病医生可能居住的是三房一厅，普通大众居住的大约就是两房一厅。所有的区别就是那个空间的大小，但是层次却是一样，大家都在精神层面，大脑层面，当我们嘲笑那些所谓的精神病患者时，殊不知，我们只是五十步笑一百步而已。</p><p>本文就探讨什么是大脑世界，什么是心灵世界，我将亲自带你去心灵世界走一遭，因为我去过那个地方。</p><p>大脑世界是一种知道、一种累积，一种记忆；大脑世界里一切东西都是陈旧的、过去的，大脑是一个知识仓库，是一个人生经验的百货超市。</p><p>而心灵世界是一种信任，一种流动、一种洞察，心灵世界没有过去、没有未来，只有当下，当下一切都是鲜活的、活泼的、灵动的。</p><p>心灵世界与大脑世界是两个完全不同的世界。</p><p>大脑最擅长的就是分析、总结、归纳，然后企图去理解，大脑最擅长逻辑和思考。</p><p>而心灵是一种当下的反应、一个观照、是一束光，大脑世界的一切活动都在心灵之光的照耀下遍体通透。</p><p>心灵不遵循任何逻辑，也没有逻辑，心灵与大脑是完全相反的两个世界。</p><p>大脑世界是混乱的，纠结的，是相互矛盾的，大脑不可能不纠结，因为这个世界上从来没有两颗相同的大脑，不同的大脑有不同的知识，不同的经验、不同的文化、不同的传统、不同习俗。地球上遍地都是不同的大脑、到处都是固执的大脑。</p><p>所以大脑之间的斗争从来就没有停止过。</p><p>而心灵世界是清澈的、单纯的、流动的，心灵从不记忆，因为心灵不需要记忆，心灵是当下的反应，是一面一尘不染的镜子，是清澈透明的湖水，心灵从来不累积任何东西，心灵是一种即刻反应，是一种物来则应，事过不留的当下观照，心灵只是反应，即刻反应，心灵世界就是一个片刻接一个片刻，完全活在当下，他不属于过去，也不属于未来，它只属于当下。所以心灵世界是轻松的，因为没有任何负担，没有任何垃圾。</p><p>这对于那些从来没有这种体验的人来说，从来没有跨进心灵大门的人来说，这种状态实在是太陌生了，几乎很难理解，甚至无法理解。</p><p>但心灵的确就在那里，不管你了解还是不了解，他就在那里，它只属于那些跳进他怀抱的人。</p><p>心灵世界属于人类进化过程中相对高级的世界，对于绝大多数人来，他们根本就不知道还有心灵世界的存在，这样对绝大多数众生来说，就有很大的困难，如果你压根就不知道有心灵世界的存在，那你如何探索你的心灵，你又如何成长你的心灵？</p><p>因为不了解某样东西，甚至压根就不知道某样东西的存在，你如何去开发他？又如何去发展他，这很困难。</p><p>企图用大脑去分析心灵，去理解心灵那是徒劳的，根本不可能，大脑不可能理解心灵，两个不同世界人如何沟通，而且这里的关键恰恰是：大脑必须停止一切思考、停止一切分析，停止一切企图理解的努力，大脑必须彻底安静，彻底死掉后，心灵世界才会出现。</p><p>这一点，大脑很难接受，绝大多数人终其一生也看不见心灵世界的出现，根本原因就在这里：大脑太努力了，以为通过大脑的思考和分析就可以进入心灵世界，就可以了解心灵世界，这是缘木求鱼，方向错了，越努力，离目标越远。</p><p>进入心灵世界恰恰需要的是不努力，不折腾，进入心灵世界必须抛弃大脑所有的努力，大脑必须彻底休息，彻底安静，不能有一丝念头，因为心灵就是没有大脑的世界。</p><p>这是一件让人几乎绝望的事情。但是对于那些去过心灵世界的人来说，却易如反掌，就在当下立即马上可以进入心灵世界。</p><p>我见过太多两眼空洞，内心绝望的道士、和尚和那些自称很有修为的修士，他们其实什么也没达成，他们停留在大脑的世界里，没有任何进步，他们困在大脑里，那个突破，没有发生，那个锐变没有发生。他们被困住了，找不到方向，他们继续努力，结果越来越远。</p><p><strong>11 大脑不死心灵不现（中）</strong></p><p>我父亲死后，家里长辈要求请和尚为父亲念经超度，和尚来了，见到我就跑了，因为我一瞬间就看透他们了，他们是假和尚，他们身上的那个跳跃根本就没有发生。</p><p>于是我自己为父亲念经，我为父亲念落地经，何谓落地经，就是处理好父亲生前担心任何事情，而且做得比父亲要求的更好。</p><p>心灵与大脑天生就是一对冤家，他们势不两立，心灵就像大海中的隐藏在海水中的岛屿，唯有海水退去，岛屿才会显现，海水就是大脑，岛屿就是心灵。</p><p>看得见海水，岛屿就是被淹没状态，岛屿露出来，海水必须退出。</p><p>一个消失，另一个才会出现，他们不可能同时出现，大脑至始至终都是一个干扰，大脑越努力，好比海水涨得越高，心灵就越藏得更深。</p><p>我走过这一条路，所以我很熟悉这一片海，我知道在某一片海水之下的确存在一个神秘的岛屿。</p><p>我们看一则故事，帮助领会：</p><p>有一个小沙弥跟随一个师傅修行了好几年，他一直有个怀疑，怀疑心灵世界的存在，因为几乎所有的修行都是针对心灵世界而修炼的，于是，某一天，他终于鼓起勇气问师傅：“师傅，我一直有个怀疑，我不相信有心灵世界的存在，这就是我这几年没有长进的原因，因为我怀疑是否有那么一个叫心灵世界的存在？”</p><p>小沙弥有问题很正常，怀疑心灵世界的存在也很正常，毕竟这个所谓的心灵世界看不见，摸不着，所以小沙弥一直很困惑，也因此他一直没有任何突破。</p><p>修行绝对是一场信仰的革命，没有信仰、没有绝对的信任是不可能有突破、有锐变的。</p><p>就像一颗橡树种子，如果不相信自己可以长成一颗参天大树，他将永远只能是颗种子，只有彻底地信任，然后奋不顾身地投入大地的怀抱，只有这样锐变才会发生，奇迹才会发生，这棵橡树种子终究是可以长成一棵大树的，原来的种子必须死去，新的生命才会开始，这就是两难所在，种子永远看不见自己成为橡树的那一刻，因为在这之前，种子必须死去。</p><p>如果在锐变之前自己根本就看不到自己锐变后的那一种状态，又如何勇敢地去行动，所以除了信任没有第二个办法。</p><p>上升到心灵层次也是同样的道理，上升到心灵层次，大脑必须死掉，彻底地死掉，否则永远也见不到、体验不到心灵世界的无限美景。</p><p>小沙弥一直停留在大脑层面，他的大脑一刻不停都在运转，他在怀疑，怀疑就是大脑的标志。</p><p>师傅没有说话，把小沙弥带到一间非常黑暗的房间，告诉小沙弥，房角有一块石头，小沙弥不相信，他说：“师傅，屋子这么黑，我看不见，我不相信角落里有石头。”</p><p>师傅点燃一只蜡烛，屋子里立刻光明起来，东边屋角放着一块大大的石头。</p><p>很多东西并不是你不相信，他就不存在。相信是大脑的诡计，需要很多的证据，很的多见证人，大脑才愿意相信，而心灵是信任，信任是绝对的接纳，信任是一种跨越，一个跳跃，中间不需要证据和见证人的过渡，是直接融入。</p><p>这就是我们上升到心灵世界面临的巨大的困难：我们一直习惯了由大脑主宰我们，我们被大脑统治了很久很久，我们已经变成了大脑的奴隶，我们太依赖我们的大脑了，如果大脑不发出指令，我们根本就不会采取任何行动。</p><p><strong>12 大脑不死心灵不现（下）</strong></p><p>我们如何翻身变成大脑的主人呢？这太困难了，奴隶翻身做主人，这是一个伟大的颠覆，这不是每一个人都可以实现的颠覆。</p><p>我们要清晰地认识到：大脑本身就是一个干扰，一个障碍，只有绕开大脑，才能进入心灵世界。</p><p>干掉大脑，让大脑死掉、让大脑休克，让大脑停止一切，心灵立刻就显现了，就这么简单。</p><p>去过心灵世界的所有师傅都有一个非常简便的办法帮助后来者干掉大脑：那就是人为地制造混乱、制造荒谬，创造一个完全不合逻辑的契机，让后来者的大脑在某一瞬间短路。</p><p>大脑一旦遇到无法思考的事情、一旦遇到不符合逻辑的事情，大脑就会短路，大脑就会休克，在大脑短路和休克的瞬间，心灵会出现，这样我们就可以对心灵世界有一个短暂的瞥见，就像师傅点亮一盏蜡烛一样，当蜡烛点燃的那一瞬间，墙角的石头立刻显现，当大脑短路的那一瞬间，心灵就会立刻显现，虽然很短暂，但是有一个瞥见，这样至少我们有那么一个瞬间真正且感知到：心灵是确实存在的。</p><p>我们再看一个故事：</p><p>有一个徒弟跟随师父很多年，徒弟很用功，但是没有用，一直没有本质上变化，有一天，天上没有月亮也没有星星，他带着很多问题再一次去师傅的禅房，因为他一直在大脑层面用工，所以有很多问题，心灵层面从来不会有问题，这是一个很显著的标志，心灵层面一切都很清澈透明，一切都非常祥和宁静，心灵不会产生任何问题，只有大脑才会有问题，而且很多。</p><p>这个小和尚带着很多问题去找师傅，师傅正在静坐，那么的安详，那么的宁静，徒弟过来了，师傅开口说话了：“外面那么黑，进来吧。”</p><p>外面那么黑是一个隐喻，是一个双关语，天上没有月亮也没有星星，当然很黑，同时他是在暗示徒弟，你生活在黑暗中，徒弟一直在黑暗中，一直在无明中挣扎，师傅非常清楚，一个生活在心灵层面的人，师傅一眼就能看出来。</p><p>徒弟走进去，他不敢打扰师傅，静静坐在旁边，很久很久，徒弟坐不住了，夜已经很深了，他不想打搅师傅，他起身要离开，师傅再一次说：“外面很黑，我给你点一盏灯吧。”</p><p>于是师傅把灯点亮。徒弟刚接过灯，师傅突然把灯吹灭了。</p><p>师傅吹灭灯火来得那么突然，来得那么不和情理，这太荒唐了，那一瞬间，徒弟的大脑一定会短路，这不符合逻辑，这简直太不可思议，徒弟无法思考，既然天这么黑，师傅给自己点一盏灯是符合逻辑的，但是点亮灯火后又立即吹灭，这不符合逻辑，脑袋无法承受这荒唐的行为，大脑无法思考这完全不符合逻辑的行为，于是大脑短路了。</p><p>就在徒弟的大脑一片空白的瞬间，他见到了另一个世界，这个世界是他一直都在梦寐以求的——心灵世界，只要一个瞥见就足够了，因为他一直在寻找，现在他寻找的就在眼前，他内心所有的怀疑消失了，他顿悟了老师的一片苦心，在那一瞬间，徒弟升华了，那个锐变，那个跳跃发生了，他顿时泪流满面，感激不尽。</p><p>制造混乱、制造荒唐一直都是师傅常用的手段。如果你懂，就能立刻领悟无数个看似荒唐不经的禅宗公案，师傅们几乎都用相似的手法。</p><p>无论是棒打、吆喝、吐口水，这只是形式上的不同，目的都是一个，让你那该死的大脑短路，哪怕只有一瞬间。</p><p>我也曾辛辛苦苦地一路走过来，我也遭遇过师傅的当头棒喝，附注：这个对我当头大喝一个传奇人物，后面有机会我还会提到她。因为我已经辛辛苦苦准备了三五年，那一声大吼来得正是时候。正是师傅的那一声大吼，直接将心灵世界在我面前展开，我直接跳进了心灵世界，我激动得三天没有睡觉，我像个疯子一样浑身发抖，泪流满面，我以自己最直接的体验，可以负责地说：请不要怀疑心灵世界的存在，如果有任何怀疑，那就是大脑进入了干扰状态，大脑一旦介入，一切便前功尽弃，心灵世界永不得见。</p><p>因为走过这条路，所以我很清楚，从我们的身体出发，我们会来到我们的精神世界，这个没有问题，大多数人在一生中都可以走到这个世界，而且目前这个精神世界已经非常拥挤，大多数人还在这个精神世界里结婚生子了，他们在精神世界生活的非常惬意，他们以为人生的终点就是那里，遗憾的是，他们错过了人生中更重要的下一站，那就是从精神世界出发，我们终究会到达下一个更加美丽的世界——心灵世界。</p><p>心灵世界就是精神世界的一面镜子，精神世界在心灵世界这面清澈的镜子面前，一目了然，心灵世界就是一束光，精神世界在这一束光的照耀下，通体透明，无处可藏。</p><p>从心灵世界看人生百态，一切了悟于心，精神世界里所有的苦恼、所有的困惑、所有的纠结只不是人类自己作茧自缚而已。</p><p>这就是我一直强调的重点：治疗精神病必须从心灵层面入手的根本原因所在。</p><p>从我们的身体出发，我们会来到我们的精神世界，这个没有问题，大多数人在一生中都可以走到这个世界，而且目前这个精神世界已经非常拥挤，大多数人还在这个精神世界里结婚生子了，他们在精神世界生活的非常惬意，他们以为人生的终点就是那里，遗憾的是，他们错过了人生中更重要的下一站，那就是从精神世界出发，我们终究会到达下一个更加美丽的世界——心灵世界。<br />（完）</p><p>推荐大家看下seeker大师兄视频中的介绍：<a href="https://www.youtube.com/watch?v=uSQ8PrzrSmk">https://www.youtube.com/watch?v=uSQ8PrzrSmk</a></p><p>希望这篇文章能够帮助到您，感恩让我们再此相遇♥</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言&lt;br /&gt;
目录&lt;/p&gt;
&lt;p&gt;01 人生一世最大的成就是什么？&lt;/p&gt;
&lt;p&gt;02 开悟最简单的第四种途径——当下顿悟&lt;/p&gt;
&lt;p&gt;03 我见证了父亲的开悟时刻&lt;/p&gt;
&lt;p&gt;04 开悟就是找到第三个“我”在哪里&lt;/p&gt;
&lt;p&gt;05 捐出100万还要说谢谢&lt;/p&gt;</summary>
      
    
    
    
    <category term="Mental" scheme="https://t8840.github.io/categories/Mental/"/>
    
    
    <category term="Mental" scheme="https://t8840.github.io/tags/Mental/"/>
    
  </entry>
  
  <entry>
    <title>道家真气</title>
    <link href="https://t8840.github.io/posts/8df76a52/"/>
    <id>https://t8840.github.io/posts/8df76a52/</id>
    <published>2023-09-13T09:18:23.000Z</published>
    <updated>2023-09-13T09:18:23.000Z</updated>
    
    
    
    
    <category term="Mental" scheme="https://t8840.github.io/categories/Mental/"/>
    
    
    <category term="Mental" scheme="https://t8840.github.io/tags/Mental/"/>
    
  </entry>
  
  <entry>
    <title>RemoteControl</title>
    <link href="https://t8840.github.io/posts/e7b1adcd/"/>
    <id>https://t8840.github.io/posts/e7b1adcd/</id>
    <published>2023-09-13T09:12:41.000Z</published>
    <updated>2023-09-13T09:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程控制工具"><a class="markdownIt-Anchor" href="#远程控制工具"></a> 远程控制工具</h2><h3 id="gotohttp"><a class="markdownIt-Anchor" href="#gotohttp"></a> GotoHTTP</h3><p>GotoHTTP是一款基于https的远控工具。</p><ul><li>优势<br />B2C 模式，无需安装控制端软件，有浏览器就可以远控。<br />流量走 https 协议，只要目标放行 443 端口出口就可以实现内网穿透。</li><li>GoToHTTP安装<br />官网地址：<a href="http://www.gotohttp.com/">http://www.gotohttp.com/</a></li><li>在Linux中运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://gotohttp.com/gotohttp_gui_x64.tar.gz</span><br><span class="line">tar -xvf gotohttp_gui_x64.tar.gz</span><br><span class="line">sudo ./gotohttp_gui_x64/gotohttp</span><br></pre></td></tr></table></figure><p>如上，我们运行软件得到了控制Linux的id和控制码。<br />在浏览器输入远程电脑ID及控制码立即开始控制。<br />这时候，通过浏览器便可以直接控制Linux。<br />当然，用手机浏览器也是可以连接的。</p><ul><li>控制安卓手机<br />安装手机需要运行，需要adb执行下面命令<br />adb tcpip 5555</li><li>在Windows运行<br />下载对应的Windows安装包，直接运行即可。连接方式和上面一样。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;远程控制工具&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#远程控制工具&quot;&gt;&lt;/a&gt; 远程控制工具&lt;/h2&gt;
&lt;h3 id=&quot;gotohttp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#gotohttp&quot;</summary>
      
    
    
    
    <category term="网络安全" scheme="https://t8840.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="https://t8840.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>网站信息收集</title>
    <link href="https://t8840.github.io/posts/ef265ae3/"/>
    <id>https://t8840.github.io/posts/ef265ae3/</id>
    <published>2023-09-13T09:07:25.000Z</published>
    <updated>2023-09-13T09:07:25.000Z</updated>
    
    
    
    
    <category term="网络安全" scheme="https://t8840.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="https://t8840.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>VPN</title>
    <link href="https://t8840.github.io/posts/bcafbad3/"/>
    <id>https://t8840.github.io/posts/bcafbad3/</id>
    <published>2023-09-13T09:06:27.000Z</published>
    <updated>2023-09-13T09:06:27.000Z</updated>
    
    
    
    
    <category term="Devops" scheme="https://t8840.github.io/categories/Devops/"/>
    
    
    <category term="Devops" scheme="https://t8840.github.io/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>Solana</title>
    <link href="https://t8840.github.io/posts/d994c52d/"/>
    <id>https://t8840.github.io/posts/d994c52d/</id>
    <published>2023-09-13T08:52:39.000Z</published>
    <updated>2023-09-13T08:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solana面向性能的区块链"><a class="markdownIt-Anchor" href="#solana面向性能的区块链"></a> Solana：面向性能的区块链</h1><p>Solana 是一个快速、安全和抗审查的区块链，由于其开创性的可扩展性解决方案和创新技术，它在加密社区中引起了很大的关注。本指南深入探讨了 Solana 是什么，为什么它是独一无二的，以及为什么它受到了如此多的关注。</p><h2 id="历史和背景"><a class="markdownIt-Anchor" href="#历史和背景"></a> <strong>历史和背景</strong></h2><p>Solana 由 Anatoly Yakovenko 于 2017 年创立。在创建 Solana 之前，Yakovenko 在 Qualcomm 和 Dropbox 工作，这为他提供了优化系统性能的深入见解。认识到现有区块链所面临的可扩展性问题，Yakovenko 试图从零开始设计一个系统，该系统可以在不妥协安全性的情况下处理全球规模的需求。</p><h2 id="技术创新"><a class="markdownIt-Anchor" href="#技术创新"></a> <strong>技术创新</strong></h2><h3 id="1-历史证明-poh"><a class="markdownIt-Anchor" href="#1-历史证明-poh"></a> 1. <strong>历史证明 (PoH)：</strong></h3><p>Solana 最独特的特点是其新颖的共识机制，称为历史证明。与传统的区块链不同，它要求验证者观察并就交易的顺序达成共识，PoH 允许验证者信任给交易的时间戳，而无需外部确认。这一创新极大地加快了验证过程，减少了节点之间的通信需求。</p><h3 id="2-tower-bft"><a class="markdownIt-Anchor" href="#2-tower-bft"></a> 2. <strong>Tower BFT：</strong></h3><p>基于 PoH，Tower BFT 是 Solana 的自定义共识算法。它受益于 PoH 提供的已建立的时间顺序，快速达成共识并确认交易，使网络更加高效和安全。</p><h3 id="3-turbine"><a class="markdownIt-Anchor" href="#3-turbine"></a> 3. <strong>Turbine：</strong></h3><p>Solana 的数据广播解决方案是 Turbine。它不向所有节点发送完整数据，而是将数据分解成更小的数据包，并使用流协议分发它们，使数据传播效率提高数倍。</p><h3 id="4-gulf-stream"><a class="markdownIt-Anchor" href="#4-gulf-stream"></a> 4. <strong>Gulf Stream：</strong></h3><p>为了处理交易缓存并将其转发到网络的边缘，Solana 使用了 Gulf Stream。这种机制允许验证者提前执行交易，减少确认时间并增加网络的整体吞吐量。</p><h3 id="5-sealevel"><a class="markdownIt-Anchor" href="#5-sealevel"></a> 5. <strong>Sealevel：</strong></h3><p>通过 Sealevel，可以并行智能合约运行时。这允许在同一状态上并发处理交易，是大幅提高吞吐量的革命性方式。</p><h3 id="6-pipeline"><a class="markdownIt-Anchor" href="#6-pipeline"></a> 6. <strong>Pipeline：</strong></h3><p>为了优化事务处理单元验证，Pipeline 将事务验证分配给不同的硬件单元进行并行和更快的处理。</p><h2 id="代币和生态系统"><a class="markdownIt-Anchor" href="#代币和生态系统"></a> <strong>代币和生态系统</strong></h2><p><strong>SOL</strong> 是 Solana 的原生加密货币。它用于权益证明、交易费用，并可以在该平台上构建的各种 DeFi 应用程序中使用。</p><p>Solana 生态系统一直在快速增长，许多项目选择在其上构建，因为其高吞吐量和低交易成本。这导致了 Solana 上各种 DeFi 平台、NFT 市场和其他分散应用的崛起，进一步推动了其采用和增长。</p><h2 id="优势和潜在挑战"><a class="markdownIt-Anchor" href="#优势和潜在挑战"></a> <strong>优势和潜在挑战</strong></h2><p><strong>优势：</strong></p><ul><li><p><strong>可扩展性：</strong> Solana 吹嘘其吞吐量为每秒 65,000 笔交易，使其成为最快的区块链之一。</p></li><li><p><strong>低费用：</strong> 尽管其吞吐量很高，但交易成本仍然很低。</p></li><li><p><strong>不断增长的生态系统：</strong> 越来越多的项目正在 Solana 上建立，这表明了对其基础设施的信任。</p></li></ul><p><strong>潜在挑战：</strong></p><ul><li><p><strong>网络中心化：</strong> 一些批评者认为，对高性能硬件的需求可能导致验证者的集中。</p></li><li><p><strong>年轻的生态系统：</strong> 与 Ethereum 这样的成熟链相比，Solana 相对较新，随着其增长，可能会面临无法预见的挑战。</p></li></ul><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> <strong>结论</strong></h2><p>Solana 代表了区块链技术的重大进步，解决了困扰早期代代的可扩展性问题。通过重新构想具有历史证明和 Tower BFT 机制的架构，它提供了一个承诺的未来去中心化应用的平台。然而，像所有技术一样，监控其演变并解决潜在挑战对确保其长期成功至关重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;solana面向性能的区块链&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#solana面向性能的区块链&quot;&gt;&lt;/a&gt; Solana：面向性能的区块链&lt;/h1&gt;
&lt;p&gt;Solana 是一个快速、安全和抗审查的区块链，由于其开创性的可扩展性</summary>
      
    
    
    
    <category term="Web3" scheme="https://t8840.github.io/categories/Web3/"/>
    
    
    <category term="Web3" scheme="https://t8840.github.io/tags/Web3/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://t8840.github.io/posts/f5f9fa9b/"/>
    <id>https://t8840.github.io/posts/f5f9fa9b/</id>
    <published>2023-09-13T08:36:26.000Z</published>
    <updated>2023-09-13T08:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker安装"><a class="markdownIt-Anchor" href="#docker安装"></a> Docker安装</h2><h3 id="linux安装"><a class="markdownIt-Anchor" href="#linux安装"></a> Linux安装</h3><ul><li>方式一：一键安装脚本</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wget -qO- https://get.docker.com/ | bash</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 如果上面的不行，执行下面两句</span></span><br><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 安装成功执行下面语句，如果有类似回显，说明安装成功</span></span><br><span class="line">$ docker --version</span><br><span class="line">Docker version 23.0.1, build a5ee5b1</span><br></pre></td></tr></table></figure><ul><li>方式二：二进制安装</li></ul><h3 id="mac安装"><a class="markdownIt-Anchor" href="#mac安装"></a> Mac安装</h3><p>下载：<a href="https://download.docker.com/mac/stable/Docker.dmg">https://download.docker.com/mac/stable/Docker.dmg</a><br />双击安装</p><h3 id="增加普通用户docker权限"><a class="markdownIt-Anchor" href="#增加普通用户docker权限"></a> 增加普通用户Docker权限</h3><ul><li>参考：<a href="https://www.cnblogs.com/lxsky/p/12829864.html">https://www.cnblogs.com/lxsky/p/12829864.html</a></li><li>root用户新建docker组：groupadd docker</li><li>使用普通用户appdeploy执行：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker</span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有sudo权限需要按照下面进行配置</span></span><br><span class="line">a. 首先找到文件位置，示例中文件在/etc/sudoers位置。</span><br><span class="line">whereis sudoers</span><br><span class="line"></span><br><span class="line">b.强调内容 修改文件权限，一般文件默认为只读。</span><br><span class="line"><span class="built_in">ls</span> -l /etc/sudoers 查看文件权限</span><br><span class="line"><span class="built_in">chmod</span> -v u+w /etc/sudoers 修改文件权限为可编辑</span><br><span class="line"></span><br><span class="line">c. 修改文件，在如下位置增加一行，保存退出。</span><br><span class="line">vim /etc/sudoers 进入文件编辑器</span><br><span class="line">文件内容改变如下：</span><br><span class="line">root ALL=(ALL) ALL 已有行</span><br><span class="line">appdeploy ALL=(ALL) ALL 新增行</span><br><span class="line"></span><br><span class="line">d. 记得将文件权限还原回只读。</span><br><span class="line"><span class="built_in">ls</span> -l /etc/sudoers 查看文件权限</span><br><span class="line"><span class="built_in">chmod</span> -v u-w /etc/sudoers 修改文件权限为只读</span><br></pre></td></tr></table></figure><p>如果上面没有生效，再重启下docker</p><ul><li>systemctl daemon-reload</li><li>systemctl restart docker</li></ul><h2 id="docker-compose安装"><a class="markdownIt-Anchor" href="#docker-compose安装"></a> Docker-Compose安装</h2><ul><li>方式一：pip3安装<ul><li>有网络情况：<br />pip3 install docker-compose</li><li>无网络情况：  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用有网络的电脑下载并上传</span></span><br><span class="line">pip3 download  -d /root/software/python3.7/pippackage/ docker-compose</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip3 install --no-index --find-links=/root/software/python3.7/pippackage/ docker-compose</span><br></pre></td></tr></table></figure></li></ul></li><li>方式二: 二进制安装<ul><li>Linux安装：直接从 <a href="https://github.com/docker/compose/releases/download/1.22.0/docker-compose-">https://github.com/docker/compose/releases</a> 找到合适的版本下载docker-compose-Linux-x86_64</li><li>接着上传到linux服务器</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker安装&quot;&gt;&lt;/a&gt; Docker安装&lt;/h2&gt;
&lt;h3 id=&quot;linux安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linu</summary>
      
    
    
    
    <category term="Devops" scheme="https://t8840.github.io/categories/Devops/"/>
    
    
    <category term="Devops" scheme="https://t8840.github.io/tags/Devops/"/>
    
  </entry>
  
  <entry>
    <title>常用API测试工具</title>
    <link href="https://t8840.github.io/posts/eda31c22/"/>
    <id>https://t8840.github.io/posts/eda31c22/</id>
    <published>2023-09-13T08:12:46.000Z</published>
    <updated>2023-09-13T08:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抓包工具"><a class="markdownIt-Anchor" href="#抓包工具"></a> 抓包工具</h2><h3 id="mitmproxyanyproxy"><a class="markdownIt-Anchor" href="#mitmproxyanyproxy"></a> mitmproxy/anyproxy</h3><h3 id="burpsuitefiddlecharles"><a class="markdownIt-Anchor" href="#burpsuitefiddlecharles"></a> burpsuite/fiddle/Charles</h3><h2 id="http-client工具"><a class="markdownIt-Anchor" href="#http-client工具"></a> http client工具</h2><h3 id="requesthttpxaiohttp"><a class="markdownIt-Anchor" href="#requesthttpxaiohttp"></a> request/httpx/aiohttp</h3><h3 id="httprunner"><a class="markdownIt-Anchor" href="#httprunner"></a> httprunner</h3><h3 id="yapi"><a class="markdownIt-Anchor" href="#yapi"></a> Yapi</h3><h3 id="jmeter"><a class="markdownIt-Anchor" href="#jmeter"></a> Jmeter</h3><h3 id="apiauto"><a class="markdownIt-Anchor" href="#apiauto"></a> APIAuto</h3><p><a href="https://github.com/TommyLemon/APIAuto">https://github.com/TommyLemon/APIAuto</a></p><h3 id="hoppscotch"><a class="markdownIt-Anchor" href="#hoppscotch"></a> hoppscotch</h3><p>Open source API development ecosystem<br /><a href="https://github.com/hoppscotch/hoppscotch">https://github.com/hoppscotch/hoppscotch</a></p><h2 id="mock工具"><a class="markdownIt-Anchor" href="#mock工具"></a> Mock工具</h2><h3 id="yapi-2"><a class="markdownIt-Anchor" href="#yapi-2"></a> YApi</h3><h3 id="easymock"><a class="markdownIt-Anchor" href="#easymock"></a> EasyMock</h3><h3 id="httpretty"><a class="markdownIt-Anchor" href="#httpretty"></a> HTTPretty</h3><p><a href="https://github.com/gabrielfalcao/HTTPretty">https://github.com/gabrielfalcao/HTTPretty</a></p><h2 id="商用工具"><a class="markdownIt-Anchor" href="#商用工具"></a> 商用工具</h2><h3 id="apifox"><a class="markdownIt-Anchor" href="#apifox"></a> Apifox</h3><p>Apifox = Postman + Swagger + Mock + JMeter<br />文档：<a href="https://www.apifox.cn/help">https://www.apifox.cn/help</a></p><h3 id="metepheres"><a class="markdownIt-Anchor" href="#metepheres"></a> Metepheres</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;抓包工具&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#抓包工具&quot;&gt;&lt;/a&gt; 抓包工具&lt;/h2&gt;
&lt;h3 id=&quot;mitmproxyanyproxy&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mitmpr</summary>
      
    
    
    
    <category term="测试开发" scheme="https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Test" scheme="https://t8840.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://t8840.github.io/posts/4a17b156/"/>
    <id>https://t8840.github.io/posts/4a17b156/</id>
    <published>2023-09-13T06:44:16.114Z</published>
    <updated>2023-09-13T06:44:16.116Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Solidity资料</title>
    <link href="https://t8840.github.io/posts/77571803/"/>
    <id>https://t8840.github.io/posts/77571803/</id>
    <published>2023-03-01T13:22:05.000Z</published>
    <updated>2023-03-01T13:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频"><a class="markdownIt-Anchor" href="#视频"></a> 视频</h2><h2 id="文字版"><a class="markdownIt-Anchor" href="#文字版"></a> 文字版</h2><h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视频&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#视频&quot;&gt;&lt;/a&gt; 视频&lt;/h2&gt;
&lt;h2 id=&quot;文字版&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文字版&quot;&gt;&lt;/a&gt; 文字版&lt;/h2&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="编程语言" scheme="https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Solidity" scheme="https://t8840.github.io/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>Solidity</title>
    <link href="https://t8840.github.io/posts/b9a928cc/"/>
    <id>https://t8840.github.io/posts/b9a928cc/</id>
    <published>2023-02-26T14:05:05.000Z</published>
    <updated>2023-02-26T14:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity是一种基于以太坊区块链的智能合约编程语言，它具有类似于JavaScript和C++的语法和特性。</p><h2 id="solidity入门语法"><a class="markdownIt-Anchor" href="#solidity入门语法"></a> Solidity入门语法</h2><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p>Solidity支持两种注释方式，单行注释和多行注释。单行注释使用//，多行注释使用/* */。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 这是单行注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这是多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="变量和数据类型"><a class="markdownIt-Anchor" href="#变量和数据类型"></a> 变量和数据类型</h3><p>Solidity支持多种数据类型，包括布尔型、整型、地址、字符串和数组等。</p><ul><li>布尔型<br />布尔型表示逻辑值，只有两个可能的值，即true和false。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool a = true;</span><br><span class="line">bool b = false;</span><br></pre></td></tr></table></figure><ul><li>整型<br />整型表示整数值，可以分为有符号整型和无符号整型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int a = 123;  // 有符号整型</span><br><span class="line">uint b = 456;  // 无符号整型</span><br></pre></td></tr></table></figure><ul><li>地址<br />地址类型表示以太坊账户的地址，它是一个20字节的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">address a = 0x1234567890123456789012345678901234567890;</span><br></pre></td></tr></table></figure><ul><li>字符串<br />字符串类型表示文本值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string a = &quot;Hello World!&quot;;</span><br></pre></td></tr></table></figure><ul><li>数组<br />数组表示具有相同类型的值的有序集合。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint[] a = [1, 2, 3];</span><br><span class="line">string[] b = [&quot;Hello&quot;, &quot;World&quot;];</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>Solidity中的函数可以接受参数和返回值。函数使用function关键字声明，可以指定函数的可见性和修饰符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function add(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为add的函数，它接受两个无符号整型参数a和b，返回它们的和。public表示该函数可以被外部调用，pure表示该函数不会读取或修改合约状态。</p><h3 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h3><p>Solidity支持条件语句和循环语句。</p><ul><li>条件语句<br />条件语句使用if和else关键字。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uint a = 10;</span><br><span class="line"></span><br><span class="line">if (a &gt; 5) &#123;</span><br><span class="line">    // 如果a大于5，执行这里的代码</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 否则执行这里的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环语句<br />循环语句使用for和while关键字。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for (uint i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    // 执行10次循环</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint i = 10;</span><br><span class="line"></span><br><span class="line">while (i &gt; 0) &#123;</span><br><span class="line">    // 执行10次循环</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h3><p>结构体表示一种自定义数据类型，可以包含多个字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Person &#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = Person(&quot;Alice&quot;, 20);</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为Person的结构体，它包含两个字段：name和age。然后我们创建了一个名为p的Person类型的实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    struct Person &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint age;</span><br><span class="line">        bool isAdult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person public alice;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        alice.name = &quot;Alice&quot;;</span><br><span class="line">        alice.age = 30;</span><br><span class="line">        alice.isAdult = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setAge(uint age) public &#123;</span><br><span class="line">        alice.age = age;</span><br><span class="line">        if (age &gt;= 18) &#123;</span><br><span class="line">            alice.isAdult = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            alice.isAdult = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为Person的结构体，包含三个字段：name（字符串类型）、age（无符号整数类型）和isAdult（布尔类型）。合约还包含一个名为alice的公共状态变量，其类型为Person，可以用来存储一个人的姓名、年龄和成年状态。合约还定义了一个名为setAge的函数，用于设置alice的年龄，并根据年龄计算其成年状态。</p><h3 id="映射"><a class="markdownIt-Anchor" href="#映射"></a> 映射</h3><p>映射表示一种将键映射到值的数据结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mapping(address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">balances[0x1234567890123456789012345678901234567890] = 100;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为balances的映射，它将地址映射到无符号整型。然后我们将地址0x1234567890123456789012345678901234567890的值设置为100。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为balances的映射，将每个地址映射到一个无符号整数值上，表示该地址的余额。合约还定义了两个函数：</p><ul><li>deposit：允许发送以太币到合约地址，并将其存入发送方的余额中。</li><li>withdraw：允许发送方从其余额中取出指定数量的以太币。<br />在deposit和withdraw函数中，合约使用了msg.sender来引用当前交易的发送方地址，将其余额增加或减少，并使用require函数来确保余额不会变为负数。如果检查失败，函数会抛出一个错误消息，并停止执行。</li></ul><p>映射是Solidity中的一项强大功能，可用于创建各种数据结构，如哈希表、关联数组等。在实际开发中，映射通常会更加复杂，并使用更高级的技术来确保其安全性和正确性</p><h3 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h3><p>Solidity中的事件是一种机制，用于在合约执行期间将通知发送给区块链上的其他应用程序。事件通常用于跟踪合约执行的状态变化，如交易成功或失败，合约状态更改等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">event Transfer(address indexed from, address indexed to, uint value);</span><br><span class="line"></span><br><span class="line">function transfer(address to, uint value) public returns (bool) &#123;</span><br><span class="line">    emit Transfer(msg.sender, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为Transfer的事件，它包含三个参数：from、to和value。然后我们在transfer函数中调用Transfer事件，记录转账操作。</p><p>另一个简单的事件示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Example &#123;</span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint amount);</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint amount) public &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Amount must be greater than zero&quot;);</span><br><span class="line">        require(msg.sender.balance &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        payable(to).transfer(amount);</span><br><span class="line">        emit Transfer(msg.sender, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为Transfer的事件，它有三个参数：from（地址类型，表示发送方地址）、to（地址类型，表示接收方地址）和amount（无符号整数类型，表示转账金额）。合约还定义了一个名为transfer的函数，用于从当前发送方地址向指定地址转移指定数量的以太币，并触发Transfer事件以通知其他应用程序。</p><p>在调用transfer函数时，合约会检查发送方余额是否足够，如果足够，则转移以太币并触发事件。其他应用程序可以监听Transfer事件，并根据其参数值更新其状态或执行其他操作。</p><p>事件是Solidity中的一项强大功能，可用于在合约执行期间与其他应用程序进行通信，如向前端Web应用程序发送通知、向后端服务器发送数据等。在实际开发中，事件通常会更加复杂，并使用更高级的技术来确保其安全性和正确性。</p><h2 id="solidity高级语法"><a class="markdownIt-Anchor" href="#solidity高级语法"></a> Solidity高级语法</h2><h2 id="模块化"><a class="markdownIt-Anchor" href="#模块化"></a> 模块化</h2><p>Solidity支持模块化，即将合约拆分为多个文件，每个文件可以包含一个或多个合约。</p><p>导入文件<br />在Solidity中，可以使用import关键字导入其他文件中定义的合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &quot;./MyContract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AnotherContract &#123;</span><br><span class="line">    MyContract c = MyContract(0x1234567890123456789012345678901234567890);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码从文件MyContract.sol中导入了名为MyContract的合约，然后我们在AnotherContract合约中创建了一个MyContract类型的实例。</p><h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3><p>Solidity支持合约的继承，即一个合约可以从另一个合约继承其状态变量和函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract ParentContract &#123;</span><br><span class="line">    uint public a = 123;</span><br><span class="line"></span><br><span class="line">    function foo() public pure returns (uint) &#123;</span><br><span class="line">        return 456;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ChildContract is ParentContract &#123;</span><br><span class="line">    function bar() public view returns (uint) &#123;</span><br><span class="line">        return a + foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个合约，ParentContract和ChildContract。ChildContract继承了ParentContract的状态变量a和函数foo。</p><h3 id="抽象合约"><a class="markdownIt-Anchor" href="#抽象合约"></a> 抽象合约</h3><p>在Solidity中，抽象合约是一种不能直接实例化的合约，它只提供了一组接口（函数签名），而没有实现任何功能。抽象合约可以被认为是一个纯虚基类，只定义了一些需要被实现的方法。</p><p>抽象合约通常用于定义通用的接口，以便其他合约可以继承它并实现接口中定义的方法。这使得合约更易于模块化，并使代码更加可读和易于维护。</p><p>以下是一个简单的抽象合约示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">abstract contract PaymentGateway &#123;</span><br><span class="line">    function deposit(uint amount) public virtual;</span><br><span class="line">    function withdraw(uint amount) public virtual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为PaymentGateway的抽象合约，它有两个函数接口：deposit和withdraw。这个合约不能被直接实例化，但可以被其他合约继承并实现这些接口。</p><p>以下是一个继承了PaymentGateway抽象合约并实现了其接口的示例合约：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Bank is PaymentGateway &#123;</span><br><span class="line">    mapping(address =&gt; uint) private balances;</span><br><span class="line"></span><br><span class="line">    function deposit(uint amount) public override &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Amount must be greater than zero&quot;);</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public override &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为Bank的合约，它继承了PaymentGateway抽象合约，并实现了其中定义的接口。Bank合约还定义了一个名为getBalance的函数，用于返回调用方的余额。</p><p>抽象合约是Solidity中的一个重要概念，它使得代码更加模块化和可重用。在实际开发中，可以使用抽象合约来定义通用的接口，并让其他合约继承它并实现这些接口，从而大大简化代码的开发和维护。</p><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>Solidity支持接口，即仅定义函数签名而不提供实现的抽象合约。接口可以被其他合约实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface MyInterface &#123;</span><br><span class="line">    function foo() external returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyContract is MyInterface &#123;</span><br><span class="line">    function foo() public override returns (uint) &#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为MyInterface的接口，它包含一个名为foo的函数。然后我们在MyContract合约中实现了foo函数。</p><h3 id="消息"><a class="markdownIt-Anchor" href="#消息"></a> 消息</h3><p>Solidity中有一些特殊的变量，它们称为“消息变量”，包含有关当前交易的信息。</p><p>msg.sender：当前交易的发送方地址。<br />msg.value：当前交易中发送的以太币数量。<br />msg.data：当前交易中传递的数据。<br />msg.sig：当前交易中函数调用的签名。</p><h3 id="内联汇编"><a class="markdownIt-Anchor" href="#内联汇编"></a> 内联汇编</h3><p>Solidity支持内联汇编，即在Solidity代码中直接嵌入汇编代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function getGasPrice() public view returns (uint) &#123;</span><br><span class="line">    uint gasPrice;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        gasPrice := tx.gasprice</span><br><span class="line">    &#125;</span><br><span class="line">    return gasPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用内联汇编获取当前交易的Gas价格。</p><h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3><p>Solidity是一门高度安全的编程语言，旨在防止智能合约中的漏洞。以下是Solidity中常用的安全性特性：</p><p>访问控制：Solidity提供了modifier关键字，用于在函数执行前检查某个条件是否满足。<br />溢出和下溢：Solidity提供了安全的数学库SafeMath，用于执行加、减、乘、除等操作时检查是否存在溢出或下溢。<br />资源管理：Solidity中的状态变量和存储变量有不同的访问权限，防止恶意合约访问和修改合约状态。<br />防重入攻击：Solidity提供了nonReentrant修饰符，用于防止合约被重复调用，从而避免恶意合约攻击。<br />示例合约<br />以下是一个简单的Solidity合约，它模拟了一个简单的银行账户系统，支持存款、取款和查询余额功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Bank &#123;</span><br><span class="line">    mapping(address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">    event Deposit(address indexed from, uint value);</span><br><span class="line">    event Withdrawal(address indexed to, uint value);</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        require(msg.value &gt; 0, &quot;Deposit amount must be greater than 0&quot;);</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;);</span><br><span class="line">        require(amount &lt;= balances[msg.sender], &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">        emit Withdrawal(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint) &#123;</span><br><span class="line">        return balances[account];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个名为<code>Bank</code>的合约，它包含一个名为<code>balances</code>的映射，用于存储每个地址的余额。合约还定义了三个函数：</p><ul><li><code>deposit</code>：允许发送以太币到合约地址，并将其存入发送方的余额中。</li><li><code>withdraw</code>：允许发送方从其余额中取出指定数量的以太币。</li><li><code>balanceOf</code>：允许查询指定地址的余额。</li></ul><p>合约还使用了事件<code>Deposit</code>和<code>Withdrawal</code>，用于记录每个存款和取款操作的发起方和数量。</p><p>这只是一个简单的示例合约，但它涵盖了Solidity中许多基本概念和语法。在实际开发中，合约通常会更加复杂，需要更高级的语法和技术来确保其安全性和正确性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Solidity是一种基于以太坊区块链的智能合约编程语言，它具有类似于JavaScript和C++的语法和特性。&lt;/p&gt;
&lt;h2 id=&quot;solidity入门语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#solidity入门语法&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Solidity" scheme="https://t8840.github.io/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://t8840.github.io/posts/9daba997/"/>
    <id>https://t8840.github.io/posts/9daba997/</id>
    <published>2023-02-26T14:04:00.000Z</published>
    <updated>2023-02-26T14:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#测试&quot;&gt;&lt;/a&gt; 测试&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="测试开发" scheme="https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Test" scheme="https://t8840.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="https://t8840.github.io/posts/d9ef328/"/>
    <id>https://t8840.github.io/posts/d9ef328/</id>
    <published>2023-02-26T14:02:52.000Z</published>
    <updated>2023-02-26T14:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python是一种高级、解释型的编程语言，广泛用于Web开发、数据科学、人工智能、自动化等各个领域。下面分别介绍Python的入门和高级语法。</p><h2 id="python基础语法介绍"><a class="markdownIt-Anchor" href="#python基础语法介绍"></a> Python基础语法介绍</h2><h3 id="变量和数据类型"><a class="markdownIt-Anchor" href="#变量和数据类型"></a> 变量和数据类型</h3><p>在Python中，可以使用变量来存储值，并且不需要提前声明变量类型。Python支持多种数据类型，包括整数、浮点数、布尔值、字符串、列表、元组、字典等。</p><p>以下是一些变量和数据类型的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 整数类型</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = -<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数类型</span></span><br><span class="line">z = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔值类型</span></span><br><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串类型</span></span><br><span class="line">c = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表类型</span></span><br><span class="line">d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组类型</span></span><br><span class="line">e = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典类型</span></span><br><span class="line">f = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3><p>Python支持多种运算符，包括算术运算符、比较运算符、逻辑运算符、位运算符等。以下是一些运算符的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 算术运算符</span></span><br><span class="line">x = <span class="number">5</span> + <span class="number">3</span></span><br><span class="line">y = <span class="number">5</span> - <span class="number">3</span></span><br><span class="line">z = <span class="number">5</span> * <span class="number">3</span></span><br><span class="line">a = <span class="number">5</span> / <span class="number">3</span></span><br><span class="line">b = <span class="number">5</span> % <span class="number">3</span></span><br><span class="line">c = <span class="number">5</span> ** <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line">d = <span class="number">5</span> == <span class="number">3</span></span><br><span class="line">e = <span class="number">5</span> != <span class="number">3</span></span><br><span class="line">f = <span class="number">5</span> &gt; <span class="number">3</span></span><br><span class="line">g = <span class="number">5</span> &lt; <span class="number">3</span></span><br><span class="line">h = <span class="number">5</span> &gt;= <span class="number">3</span></span><br><span class="line">i = <span class="number">5</span> &lt;= <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line">j = <span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line">k = <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line">l = <span class="keyword">not</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位运算符</span></span><br><span class="line">m = <span class="number">5</span> &amp; <span class="number">3</span></span><br><span class="line">n = <span class="number">5</span> | <span class="number">3</span></span><br><span class="line">o = <span class="number">5</span> ^ <span class="number">3</span></span><br><span class="line">p = ~<span class="number">5</span></span><br><span class="line">q = <span class="number">5</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">r = <span class="number">5</span> &gt;&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="控制流语句"><a class="markdownIt-Anchor" href="#控制流语句"></a> 控制流语句</h3><p>Python支持多种控制流语句，包括if语句、for循环、while循环等。以下是一些控制流语句的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># if语句</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is positive&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is negative&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x is zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while循环</span></span><br><span class="line">z = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> z &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line">    z += <span class="number">1</span></span><br><span class="line">```    </span><br><span class="line"><span class="comment">### 函数</span></span><br><span class="line">在Python中，可以使用<span class="keyword">def</span>语句定义函数。函数可以接受参数并返回值。以下是一个函数的示例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">result = add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出8</span></span><br></pre></td></tr></table></figure><h3 id="模块和包"><a class="markdownIt-Anchor" href="#模块和包"></a> 模块和包</h3><p>Python中的模块是一个包含Python定义和语句的文件，可以通过import语句导入。Python中的包是一个包含多个模块的目录。</p><p>以下是一个模块和包的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 模块</span></span><br><span class="line"><span class="comment"># mymodule.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模块</span></span><br><span class="line"><span class="keyword">import</span> mymodule</span><br><span class="line">mymodule.greeting(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 输出Hello, Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包</span></span><br><span class="line"><span class="comment"># mypackage/mymodule.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用包</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> mymodule</span><br><span class="line">result = mymodule.add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出8</span></span><br></pre></td></tr></table></figure><h2 id="python高级语法介绍"><a class="markdownIt-Anchor" href="#python高级语法介绍"></a> Python高级语法介绍</h2><h3 id="迭代器和生成器"><a class="markdownIt-Anchor" href="#迭代器和生成器"></a> 迭代器和生成器</h3><p>Python中的迭代器是一个可以迭代访问的对象，例如列表、元组、字典等。Python中的生成器是一种更加高效的迭代器，使用yield语句生成值。</p><p>以下是一个迭代器和生成器的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 迭代器</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_iterator = <span class="built_in">iter</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_iterator))  <span class="comment"># 输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator():</span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 输出1, 2, 3</span></span><br><span class="line">```    </span><br><span class="line"><span class="comment">### 装饰器</span></span><br><span class="line">Python中的装饰器是一种用于修改函数或类的行为的语法。装饰器本质上是一个函数，可以在不修改原函数或类的情况下修改其行为。</span><br><span class="line"></span><br><span class="line">以下是一个装饰器的示例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;After the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_function()  <span class="comment"># 输出Before the function is called. Hello, World! After the function is called.</span></span><br></pre></td></tr></table></figure><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><p>在Python中，可以使用try语句和except语句来处理异常。当程序出现异常时，Python会跳转到最近的except语句，并执行其中的代码。</p><p>以下是一个异常处理的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: division by zero&quot;</span>)</span><br><span class="line">```    </span><br><span class="line"><span class="comment">### 多线程和多进程</span></span><br><span class="line">在Python中，可以使用多线程和多进程来实现并发编程。多线程是指在一个程序中同时执行多个线程，多进程是指在一个程序中同时运行多个进程。</span><br><span class="line"></span><br><span class="line">以下是一个多线程和多进程的示例：</span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_letters</span>():</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&quot;abcdefghij&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(letter)</span><br><span class="line"></span><br><span class="line">thread1 = threading.Thread(target=print_numbers)</span><br><span class="line">thread2 = threading.Thread(target=print_letters)</span><br><span class="line"></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">return</span> number ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    results = pool.<span class="built_in">map</span>(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(results)  <span class="comment"># 输出[1, 4, 9, 16, 25]</span></span><br><span class="line">```    </span><br><span class="line"><span class="comment">### 类和面向对象编程</span></span><br><span class="line">Python是一种面向对象编程语言，支持类和对象的概念。可以使用<span class="keyword">class</span>语句来定义类，使用对象来访问类中的属性和方法。</span><br><span class="line"></span><br><span class="line">以下是一个类和面向对象编程的示例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类和面向对象编程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, my name is &quot;</span> + self.name + <span class="string">&quot; and I am &quot;</span> + <span class="built_in">str</span>(self.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line">person1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">person1.greet()  <span class="comment"># 输出Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure><h3 id="lambda函数"><a class="markdownIt-Anchor" href="#lambda函数"></a> Lambda函数</h3><p>Lambda函数是一种匿名函数，可以使用lambda关键字定义。Lambda函数通常用于简单的操作，例如对列表进行排序或筛选。</p><p>以下是一个Lambda函数的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Lambda函数</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">squared_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(squared_numbers)  <span class="comment"># 输出[1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出[2, 4]</span></span><br></pre></td></tr></table></figure><h3 id="生成式"><a class="markdownIt-Anchor" href="#生成式"></a> 生成式</h3><p>Python中的生成式是一种用于生成列表、集合或字典的简便语法。生成式通常比使用循环来生成相同的结果更加简洁和可读。</p><p>以下是一个生成式的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 生成式</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">squared_numbers = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="built_in">print</span>(squared_numbers)  <span class="comment"># 输出[1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br><span class="line">even_numbers = [x <span class="keyword">for</span> x <span class="keyword">in</span> numbers <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出[2, 4]</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>本文介绍了Python的入门和高级语法，包括基本语法、数据类型、控制流、函数、模块和包、迭代器和生成器、装饰器、异常处理、多线程和多进程、类和面向对象编程、Lambda函数以及生成式。Python是一种功能强大的编程语言，具有简单易学、可读性高等特点，在数据科学、机器学习、Web开发等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python是一种高级、解释型的编程语言，广泛用于Web开发、数据科学、人工智能、自动化等各个领域。下面分别介绍Python的入门和高级语法。&lt;/p&gt;
&lt;h2 id=&quot;python基础语法介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pyt</summary>
      
    
    
    
    <category term="编程语言" scheme="https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="https://t8840.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Go入门</title>
    <link href="https://t8840.github.io/posts/3e80a85d/"/>
    <id>https://t8840.github.io/posts/3e80a85d/</id>
    <published>2023-02-26T13:54:26.000Z</published>
    <updated>2023-02-26T13:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go语言基础语法介绍"><a class="markdownIt-Anchor" href="#go语言基础语法介绍"></a> Go语言基础语法介绍</h2><h3 id="安装和环境配置"><a class="markdownIt-Anchor" href="#安装和环境配置"></a> 安装和环境配置</h3><p>首先，你需要下载并安装Go语言环境。可以从官方网站（<a href="https://golang.org/dl/%EF%BC%89%E4%B8%8A%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%8F%AF%E8%A2%AB%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8%E3%80%82">https://golang.org/dl/）上下载并安装，安装完成后设置环境变量，使其可被命令行使用。</a></p><p>Go语言的Hello World程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序包含了一个main函数，该函数调用了fmt包的Println函数，将&quot;Hello, World!&quot;打印到控制台。</p><h3 id="变量和类型"><a class="markdownIt-Anchor" href="#变量和类型"></a> 变量和类型</h3><p>Go语言是一种静态类型的语言，也就是说变量的类型在编译时就确定了。Go语言有多种基本数据类型，包括bool、int、float、string等，同时还有结构体和数组等复合类型。<br />变量可以使用var关键字来声明，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line">i = 42</span><br></pre></td></tr></table></figure><p>可以使用:=语法来简化变量声明和赋值的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br></pre></td></tr></table></figure><h3 id="控制流语句"><a class="markdownIt-Anchor" href="#控制流语句"></a> 控制流语句</h3><p>Go语言的控制流语句包括if、for、switch和select等。<br />if语句的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for语句可以用来循环执行一段代码，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句可以根据某个表达式的值进行多个分支选择，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression &#123;</span><br><span class="line"><span class="keyword">case</span> value1:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> value2:</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数和方法"><a class="markdownIt-Anchor" href="#函数和方法"></a> 函数和方法</h3><p>Go语言中函数和方法是非常重要的概念。函数是一组指定输入和输出的代码，可以独立地调用。方法是与特定类型相关联的函数。<br />函数的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(parameter1 <span class="keyword">type</span>, parameter2 <span class="keyword">type</span>)</span></span> returnType &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> someValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiverType)</span></span> methodName(parameter1 <span class="keyword">type</span>, parameter2 <span class="keyword">type</span>) returnType &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> someValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组和切片"><a class="markdownIt-Anchor" href="#数组和切片"></a> 数组和切片</h3><p>Go语言中的数组是一种固定长度的数据结构，定义一个数组的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>切片是一种动态长度的数据结构，它可以根据需要自动扩容。定义一个切片的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="结构体和指针"><a class="markdownIt-Anchor" href="#结构体和指针"></a> 结构体和指针</h3><p>Go语言中的结构体是一种自定义类型，可以包含多个字段，定义一个结构体的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>基本的结构体示例</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;name: <span class="string">&quot;Alice&quot;</span>, age: <span class="number">30</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br><span class="line">在上面的示例中，我们定义了一个名为Person的结构体，包含name和age两个字段。然后我们创建了一个Person类型的变量p，并为其赋值，最后打印p。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 匿名结构体示例</span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">    p := struct &#123;</span></span><br><span class="line"><span class="string">        name string</span></span><br><span class="line"><span class="string">        age  int</span></span><br><span class="line"><span class="string">    &#125;&#123;</span></span><br><span class="line"><span class="string">        name: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">        age:  30,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    fmt.Println(p)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个匿名结构体，并为其赋值，最后打印该结构体。</p><ol start="3"><li>嵌套结构体示例</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    street  <span class="type">string</span></span><br><span class="line">    city    <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    age     <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;</span><br><span class="line">        name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        age:  <span class="number">30</span>,</span><br><span class="line">        address: Address&#123;</span><br><span class="line">            street:  <span class="string">&quot;Main St&quot;</span>,</span><br><span class="line">            city:    <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">            country: <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为Address的结构体，包含street、city和country三个字段。然后我们定义了一个名为Person的结构体，包含name、age和address三个字段，其中address字段类型为Address。然后我们创建了一个Person类型的变量p，并为其赋值，其中address字段又包含了一个Address类型的值。最后打印p。</p><ol start="4"><li>匿名字段结构体示例</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(p.<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为Person的结构体，包含两个匿名字段，分别为string和int类型。然后我们创建了一个Person类型的变量p，并为其赋值。我们可以通过.访问匿名字段的值，例如p.string表示访问string字段的值。最后打印p和p.string。</p><p>指针是一种特殊的变量类型，它存储了一个变量的内存地址，可以使用&amp;符号来获取一个变量的地址，使用*符号来获取指针所指向的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">p = &amp;i</span><br><span class="line">*i = <span class="number">42</span></span><br></pre></td></tr></table></figure><h3 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h3><p>Go语言是一种天生支持并发和并行的语言。<br />Go语言中的goroutine是一种轻量级的线程，可以在同一个进程中同时运行多个goroutine。<br />Go语言中的channel是一种可以在不同goroutine之间进行通信的机制。</p><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p>Go语言中的错误处理非常重要。Go语言中的函数通常会返回一个错误值，如果函数执行过程中出现了错误，就会返回一个非空的错误值。可以使用if语句来检查是否出现了错误。</p><h3 id="包和模块"><a class="markdownIt-Anchor" href="#包和模块"></a> 包和模块</h3><p>Go语言中的包是一种组织代码的机制，一个包可以包含多个文件。包可以使用import语句来导入其他包中的代码。Go语言中的模块是一种用来管理代码版本和依赖关系的机制，可以使用go mod命令来管理模块。</p><h2 id="go语言高级语法介绍"><a class="markdownIt-Anchor" href="#go语言高级语法介绍"></a> Go语言高级语法介绍</h2><h3 id="接口和多态"><a class="markdownIt-Anchor" href="#接口和多态"></a> 接口和多态</h3><p>Go语言中的接口是一种约束，可以指定一个类型需要实现哪些方法。可以使用接口来实现多态。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, animal := <span class="keyword">range</span> animals &#123;</span><br><span class="line">fmt.Println(animal.Speak())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Dog和Cat都实现了Animal接口的Speak方法，所以它们都可以存储在Animal类型的切片中。</p><h3 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h3><p>Go语言中的反射机制可以让程序在运行时动态地获取类型信息和调用方法。反射可以让程序更加灵活，但也会带来一些性能损失。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.14</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，reflect.ValueOf函数可以获取变量x的反射对象，可以使用Type方法获取x的类型信息，使用Float方法获取x的值。</p><h3 id="并发编程"><a class="markdownIt-Anchor" href="#并发编程"></a> 并发编程</h3><p>Go语言的并发编程非常强大，可以使用goroutine和channel来实现。例如：</p><ol><li>goroutine示例<br />goroutine是Go语言中的轻量级线程，可以在一个程序中同时运行多个goroutine。使用goroutine可以轻松地实现并发执行的任务，而无需显式地管理线程或协程。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> printNumbers() <span class="comment">// 启动一个goroutine</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Main function execution&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">6</span> * time.Second) <span class="comment">// 主函数等待6秒钟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，printNumbers()函数被启动为一个goroutine，同时main()函数继续执行，因此可以看到输出交错进行。</p><ol start="2"><li>channel示例<br />channel是Go语言中用于goroutine之间通信的机制。channel是一个类型化的管道，可以通过它发送和接收值。channel的发送和接收操作都是阻塞的，这使得goroutine可以安全地通信。</li></ol><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        c &lt;- i <span class="comment">// 发送数据到channel</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c) <span class="comment">// 关闭channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123; <span class="comment">// 循环从channel中接收数据</span></span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 创建一个channel</span></span><br><span class="line">    <span class="keyword">go</span> producer(c)      <span class="comment">// 启动一个生产者goroutine</span></span><br><span class="line">    consumer(c)         <span class="comment">// 消费者从channel中接收数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，producer()函数将1到5的整数发送到channel中，然后关闭channel。consumer()函数从channel中接收数据并将其打印出来。注意到在main()函数中没有显式地等待生产者和消费者的执行，但是由于channel是阻塞的，因此它们的执行顺序是正确的。</p><h3 id="匿名函数和闭包"><a class="markdownIt-Anchor" href="#匿名函数和闭包"></a> 匿名函数和闭包</h3><p>Go语言支持匿名函数和闭包，这使得代码更简洁、易于阅读和维护。闭包是一个函数值，它引用了函数体外部的变量。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;x =&quot;</span>, x) <span class="comment">// 匿名函数引用外部变量 x</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer语句"><a class="markdownIt-Anchor" href="#defer语句"></a> defer语句</h3><p>defer语句可以用于在函数返回前执行某些代码。defer语句通常用于清理资源或解锁锁定的资源。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>) <span class="comment">// 在函数返回前执行 fmt.Println(&quot;world&quot;)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>Go语言的接口使得代码更具可扩展性和可复用性。接口是一种类型，定义了一组方法，任何实现了这些方法的类型都可以作为该接口的实例。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="type">float64</span></span><br><span class="line">    Perimeter() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width  <span class="type">float64</span></span><br><span class="line">    height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*r.width + <span class="number">2</span>*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Shape = Rectangle&#123;width: <span class="number">10</span>, height: <span class="number">20</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area:&quot;</span>, s.Area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Perimeter:&quot;</span>, s.Perimeter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;go语言基础语法介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go语言基础语法介绍&quot;&gt;&lt;/a&gt; Go语言基础语法介绍&lt;/h2&gt;
&lt;h3 id=&quot;安装和环境配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="编程语言" scheme="https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Go" scheme="https://t8840.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
