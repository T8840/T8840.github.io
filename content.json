{"meta":{"title":"Neal's World","subtitle":"","description":null,"author":"Neal.Wang","url":"https://t8840.github.io","root":"/"},"pages":[{"title":"","date":"2023-09-13T06:44:16.336Z","updated":"2023-09-13T06:44:16.336Z","comments":true,"path":"package.json","permalink":"https://t8840.github.io/package.json","excerpt":"","text":"{\"name\":\"ariasakablog\",\"version\":\"1.0.17\",\"description\":\"SpeedUp!\",\"main\":\"index.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"author\":\"\",\"license\":\"ISC\"}"},{"title":"","date":"2023-09-13T06:44:16.329Z","updated":"2023-09-13T06:44:16.329Z","comments":true,"path":"manifest.json","permalink":"https://t8840.github.io/manifest.json","excerpt":"","text":"{\"name\":\"Ariasakaの小窝\",\"short_name\":\"Ariasakaの小窝\",\"theme_color\":\"var(--lyx-theme)\",\"background_color\":\"var(--lyx-theme)\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"/img/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"/img/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/img/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/180.png\",\"sizes\":\"180X180\",\"type\":\"image/png\"},{\"src\":\"/img/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"},{\"src\":\"/img/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/img/256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"/img/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"bangumis","date":"2022-07-16T02:35:32.000Z","updated":"2023-09-13T06:44:16.120Z","comments":true,"path":"bangumis/index.html","permalink":"https://t8840.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-09-13T06:44:16.116Z","comments":true,"path":"about/index.html","permalink":"https://t8840.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-03T12:48:08.000Z","updated":"2023-09-13T06:44:16.121Z","comments":true,"path":"categories/index.html","permalink":"https://t8840.github.io/categories/index.html","excerpt":"","text":""},{"title":"朋友圈","date":"2022-01-29T07:23:17.000Z","updated":"2023-09-13T06:44:16.124Z","comments":true,"path":"fcircle/index.html","permalink":"https://t8840.github.io/fcircle/index.html","excerpt":"","text":"🎣 钓鱼 与主机通讯中…… var fdataUser = { apiurl: '' }"},{"title":"fontawesome对照","date":"2022-11-25T00:16:09.000Z","updated":"2023-09-13T06:44:16.124Z","comments":true,"path":"fontawesome/index.html","permalink":"https://t8840.github.io/fontawesome/index.html","excerpt":"","text":"window.parent.postMessage(object,'*'); document.getElementById('ifm').scroll(0,document.getElementById('ifm').document.body.scrollHeight);"},{"title":"小空调","date":"2022-11-24T23:37:35.000Z","updated":"2023-09-13T06:44:16.326Z","comments":true,"path":"kongtiao/index.html","permalink":"https://t8840.github.io/kongtiao/index.html","excerpt":"","text":""},{"title":"Go","date":"2023-02-15T04:00:00.000Z","updated":"2023-09-13T07:40:14.850Z","comments":true,"path":"go/index.html","permalink":"https://t8840.github.io/go/index.html","excerpt":"","text":""},{"title":"声明","date":"2022-07-10T03:13:49.000Z","updated":"2023-09-13T06:44:16.327Z","comments":true,"path":"license/index.html","permalink":"https://t8840.github.io/license/index.html","excerpt":"","text":"Copyright© LYX 2022 声明 | 版权协议 为了保持文章质量，并保持互联网的开放共享精神，保持页面流量的稳定，综合考虑下本站的所有原创文章均采用cc协议中比较严格的创作共用-非商业性-禁止演绎 4.0 国际标准。这篇文章主要想能够更加清楚明白的介绍本站的协议标准和要求。方便您合理的使用本站的文章。 本站无广告嵌入和商业行为。违反协议的行为不仅会损害原作者的创作热情，而且会影响整个版权环境。强烈呼吁您能够在转载时遵守协议。遵守协议的行为几乎不会对您的目标产生负面影响，鼓励创作环境是每个创作者的期望。 博客的分类介绍 经验分享包含原创内容，原创内容的非商用转载必须为完整转载且标注出处的带有超链接功能的完整url链接（需能点击）或访问原文之类字样的超链接。 转载内容为转载内容，均标注了出处。建议使用原链接打开，尊重原作者。所有转载内容尽可能为完整转载（如果有部分内容有问题可能会由部分删减和补充）并进行样式调整以适合本博客。如果转载该部分内容需要联系原作者。 你可以做什么？ 只要您遵守本页的许可，您可以自由地共享文章的内容 — 在任何媒介以任何形式复制、发行本作品。并且无需通知作者。 你需要遵守什么样的许可？ 署名 您必须标注内容的来源，您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接提升阅读体验）。 禁止商用 本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用、禁止在转载页面中插入广告（例如谷歌广告、百度广告）、禁止阅读的拦截行为（例如关注公众号、下载App后观看文章）。 禁止演绎 分享全部内容（无修改） 您需要在文章开头部分（或者明显位置）标注原文章链接（建议使用超链接） 分享部分截取内容或者衍生创作 目前本站全部原创文章的衍生品禁止公开分享和分发。如有更好的修改建议，可以在对应文章下留言。如有衍生创作需求，可以在评论中联系。 什么内容会被版权保护 包括但不限于： 文章封面图片 文章标题和正文 站点图片素材（不含主题自带素材） 例外情况 本着友好互相进步的原则，被本站友链收录的博客允许博客文章内容的衍生品的分享和分发，但仍需标注出处。 本着互联网开放精神，您可以在博客文章下方留言要求授权博文的衍生品的分享和分发，标注您的网站地址。 作者原创代码及网站源代码协议 网站所有代码采用MIT协议，如有不同，作者会进行标注 随便扒站吧！ 网站本身有关 本站已开启存储桶全站加速，接入了灵天盾CDN，请刷流量的耗子尾汁！！！"},{"title":"正念","date":"2023-02-15T04:00:00.000Z","updated":"2023-09-13T06:44:16.331Z","comments":true,"path":"mindfulness/index.html","permalink":"https://t8840.github.io/mindfulness/index.html","excerpt":"","text":"何谓正念 正念冥想是培养执行控制的理想心理工具，包含两大方面:觉察当下和接纳情绪！ 正念分为三大类: 专注力 正念觉察 慈悲冥想 练习正念 保持正念去做所有事，认知隔离放下。 不再企图采取行动摆脱或避免不想要的体验，而是接触它承认它的存在，然后转移到当下的事情上，不再习惯性的把自己放在世界的中心，而是采纳观察的我，这样的我有着不断变化的体验，可以与其体验相分离。 认知隔离是指接纳想法本质上只是词语和感觉，并不是想法所表述的东西。认知隔离让我们避免听信想法和感觉并据此采取行动。我们不是努力改变或消除这些想法和感觉，只是放下。"},{"title":"友链","date":"2022-07-03T12:40:57.000Z","updated":"2023-09-13T06:44:16.328Z","comments":true,"path":"links/index.html","permalink":"https://t8840.github.io/links/index.html","excerpt":"","text":"🎣 钓鱼 冰糖红茶 “冰糖红茶”博客魔改组织的大佬们 小冰【冰】 做个有梦想的人！ Akilar【糖】 期待您的光临！ 张洪Heo【红】 分享设计与科技生活 贰猹【茶】 用这生命中的每一秒，给自己一个不后悔的未来 我的信息Butterfly & MengDfluidvolantishtml12345- name: Ariasakaの小窝 link: https://yisous.xyz avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg descr: 人有悲欢离合 月有阴晴圆缺 siteshot: https://vercel.yisous.xyz/img/siteshot.png123456- &#123; title: &#x27;Ariasakaの小窝&#x27;, intro: &#x27;人有悲欢离合 月有阴晴圆缺&#x27;, link: &#x27;https://yisous.xyz/&#x27;, image: &#x27;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&#x27;&#125;123456- title: Ariasakaの小窝 avatar: https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg url: https://yisous.xyz/ screenshot: https://yisous.xyz/img/siteshot.png keywords: 个人博客 description: 人有悲欢离合 月有阴晴圆缺1&lt;a href=&quot;https://yisous.xyz&quot;&gt;&lt;img src=&quot;https://bu.dusays.com/2022/12/15/639a9ebbbc1ad.jpg&quot; alt=&quot;avatar&quot;&gt;Ariasakaの小窝&lt;/a&gt; 推荐标签衡量标准1.网站没有不良内容 2.文章质量较高 3.文章较多/或者质量过硬 如何申请友链？ 点下面的按钮！ 快速添加友链"},{"title":"","date":"2023-09-13T06:44:16.330Z","updated":"2023-09-13T06:44:16.330Z","comments":true,"path":"messageboard/index.html","permalink":"https://t8840.github.io/messageboard/index.html","excerpt":"","text":"说说你的建议吧... 你也可以私发我的邮件lyxof2010@yisous.xyz寻求帮助或者提供建议。 隐藏/显示弹幕（缓解卡顿） document.title = '留言板 | Ariasakaの小窝';"},{"title":"敲木鱼","date":"2022-11-25T00:16:09.000Z","updated":"2023-09-13T06:44:16.333Z","comments":true,"path":"muyu/index.html","permalink":"https://t8840.github.io/muyu/index.html","excerpt":"","text":"功德：0 功德+100 .muyu-layout { background: black; display: flex; width: 100%; border-radius: 20px; position: relative; justify-content: center; height: 90vh; align-items: center; } #muyu-box img { width: 250px; } #jishu-box{ top: 55px; position: absolute; } #muyu-box p { color: white; opacity: 0; font-size: 25px; } #jishu-box p { color: white; font-size: 30px; } var gongde = document.getElementById(\"gongde\"); var muyu = document.getElementById(\"muyu\"); var jishu = document.getElementById(\"jishu-box\"); var mp3Url = \"/music/muyu.mp3\"; var player = new Audio(mp3Url); var num = 0; muyu.addEventListener(\"click\", function () { num+=100; player.load(); player.play(); muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500); gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600); jishu.innerHTML = \"功德：\"+num+\"\"; });"},{"title":"Python","date":"2023-02-15T04:00:00.000Z","updated":"2023-09-13T07:40:58.965Z","comments":true,"path":"python/index.html","permalink":"https://t8840.github.io/python/index.html","excerpt":"","text":""},{"title":"分站","date":"2022-08-04T03:38:05.000Z","updated":"2023-09-13T06:44:16.335Z","comments":true,"path":"othersite/index.html","permalink":"https://t8840.github.io/othersite/index.html","excerpt":"","text":"一些博主搭建的其它的站点： PS：划掉的表示已挂 域名 用处 搭建原因 yisous.xyz 博客，也是主站（默认无www） 分享一些东西 oj.yisous.xyz OnlineJudge系统 用于自己练习信奥赛题目其实是搞来象征意义的 status.yisous.xyz 网站状态监控 用于监控网站的状态，基于uptimeRobot mc.yisous.xyz Minecraft服务器 用来联机玩，类似于粉丝服那种，还没弄好 tc.yisous.xyz Typecho测试站 看看typecho怎么样，搞来玩的，已经由Wordpress迁移至当前的Typecho，未来服务器文档之后可能会换用 yisous.tk/lyxop.xyz 短链接生成器 制作短链接，使用本站域名，技术有限，所以很丑 bbs.yisous.xyz LYXの论坛 交流一些事情，也可以闲聊，还没弄说是交流其实还是搞来象征意义搞来玩的 博主的一些域名 域名 用处 yisous.xyz 主要使用的域名，当时看到dynadot14块一年就买了，这个名字就是念起来顺口 lyxop.xyz 注册拿来给副站用的，使用blog.lyxop.xyz进入主站。由于域名续费太贵，所以打算以后换成yisous.tk，其余一样 ariasaka.top 在硅云白嫖的一个域名，后续可能会作为主域名使用 lyxoff2233.eu.org 以前的eu.org域名，还不错，后面要拿来想办法用一用 lyxofficial.eu.org 图一乐域名 yisous.tk 20年为了搭树莓派服搞的域名，可是树莓派没多久就被我超坏了，现在就买不起了，后来这个域名过期，现在又弄回来作为副站使用，使用blog.yisous.tk进入主站，www和根域名主站用于提供短域名服务（已挂）。 注意：本博客强制HTTPS，旧电脑可能会出现问题。 #article-container a:not(.post-meta__tags):not(img):not(a[data-fancybox]):hover{ border-radius: 6px; background-color: #425aef; text-decoration: none!important; color:#fff!important; border:none; box-shadow: #dadada 0 0 8px 2px; } #article-container a:not(.post-meta__tags):not(.headerlink):not(a[data-fancybox]){ /* padding:0 2px; */ /* text-decoration: 1px solid #425aef; */ /* text-decoration: underline; */ border-bottom: 2px solid #425aef; color:var(--font-color); padding:4px }"},{"title":"好听的音乐","date":"2022-07-14T08:37:40.000Z","updated":"2023-09-13T06:44:16.332Z","comments":true,"path":"musics/index.html","permalink":"https://t8840.github.io/musics/index.html","excerpt":"","text":"好听的歌 歌曲排行榜 博主会每隔一段时间将自己近期爱听的歌排行在下面 2022-7 咕咕咕…"},{"title":"标签","date":"2022-07-03T12:51:29.000Z","updated":"2023-09-13T06:44:16.342Z","comments":true,"path":"tags/index.html","permalink":"https://t8840.github.io/tags/index.html","excerpt":"","text":""},{"title":"说说","date":"2023-09-13T06:44:16.340Z","updated":"2023-09-13T06:44:16.340Z","comments":true,"path":"speaks/index.html","permalink":"https://t8840.github.io/speaks/index.html","excerpt":"","text":"function doSpeaks() { document.title = '说说 | Ariasakaの小窝'; bbtalk.init({ appId: \"\", appKey: \"\", serverURLs: '', pageSize:1919810 }) } document.addEventListener('DOMContentLoaded', (e) => { doSpeaks(); }) document.addEventListener('pjax:complete', (e) => { doSpeaks(); })"},{"title":"工具","date":"2022-07-13T07:23:02.000Z","updated":"2023-09-13T06:44:16.343Z","comments":true,"path":"tools/index.html","permalink":"https://t8840.github.io/tools/index.html","excerpt":"","text":"镜像站常用的PyPi/npm/SDK镜像站 TUNA 清华大学开源镜像站 豆瓣PYPI源 豆瓣PYPI镜像站 jsDelivr jsDelivr静态资源加速（GFW已墙） unpkg 另一个静态资源加速CDN（没墙） 资源下载类好用的资源下载/收录站 MSDN,我告诉你 微软MSDNED2K镜像收录站 唧唧Down 下载B站视频 无损生活 免费下载全网绝大部分无损音乐 百度网盘简易下载助手 特别好用的bd网盘破解器（不知道为什么公众号分享很怕敏感词） 日常工具常用日常工具 计时器 闹钟网计时器 图片系列关于图片的工具 Bigjpg 高清修复图片与降噪 waifu2x 高清修复图片与降噪，性能貌似好一点 jpgrm 高清修复图片与降噪 Sheilds 制作Github项目徽章 极简壁纸 海量高清壁纸美图&二次元图片 常用测试网站测试一些基础功能 还没做完呢 你瞅啥？还妹做完呢！"},{"title":"网站更新日志","date":"2022-07-02T11:56:00.000Z","updated":"2023-09-13T06:44:16.345Z","comments":true,"path":"update/index.html","permalink":"https://t8840.github.io/update/index.html","excerpt":"","text":"Acryple v1.0.0 2022-10-23 经过了深思熟虑，博客主题独立啦！ 现在的主题叫做Acryple，具体见： 引用站外地址 博客正式独立主题啦！ Ariasakaの小窝 目前博客有： 更好的右键菜单 留言弹幕 博客设置（功能贼多大家自己看） 不错的UI，至今为止主css(style.css)有3k行 一些小功能比如公祭日弹窗自动欢迎等 大概就是这些了。 Acryple v1.0.110 2022-12-13 加入pwa 全站采用存储桶加速，可惜并没有卵用 很多资源转为了白嫖eleme 抛弃metingjs，目前aplayer的歌曲托管在eleme npm镜像中 友链添加随机头像 博客设置画饼的三个功能仍未修复 qwq 修复一些bug 大改swiper，参考自Leonus 完成Build101的大部分饼 修复了朋友圈爬取bug sw换回cyfan 套上了灵天盾亚太CDN 因为性能问题，移除了文章日历 给导航栏加上滚动动画（画饼） bb布局重构（画饼） 分类标签栏bug修复（画饼） 语雀云端写作（因bug已回滚） gulp（因bug已回滚） 文章进度显示（画饼） 修复pjax的bug 右键菜单功能完善 Acryple v1.0.101 2022-12-06 （PS：部分画大饼 壮举：适配pjax！！！ 修复黑幕的bug 修复评论弹幕dom错误，溢出的bug 弹幕换用swiper方案，并且优化样式 首页bb增加天数显示，以及换用swiper(预计) 修复一些bug（e.g.aplayer、博客设置 优化部分动画/样式 完善博客控制面板，仍有部分未完工 修复部分文章页面溢出的bug 悼念某人，banner换图 pace换用xlenco的胶囊方案 由于未知特性删除了pjax的加载动画，首次保留 部分资源换用缤纷云 换用空梦的sw 不断优化加载速度ing… 修复首页轮播bug(预计) 评论样式修改，预计添加用户tag功能 更换背景没有时效限制了 欢迎文本 左右栏切换 弹幕开关设置自动显隐 落樱特效 aplayer显隐功能 明暗模式自动切换、固定导航栏功能（预计） 边栏样式修改 修复点赞第一赞没反应的bug 修复ghactions部署没有npm缓存的bugtnnd我等十几分钟安装依赖等几个月了，结果是顺序反了 目前朋友圈后端出现了bug，导致不更新，请静待修复 Acryple v1.0.100 2022-12-04 修复部分bug（不，特性 优化部分动画/样式 修改右键菜单 重写博客设置，并将 rightside 的部分功能移动到博客设置中，灵感来源于ichika（未完工 支持隐藏 ASide 了 短暂变灰 修复公祭日js的bug 修复右键菜单在主页也能开启阅读模式的bug 优化手机端阅读体验，去卡片化 优化latex样式 修复部分分辨率下无导航栏的bug aplayer的体验更好了 优化部分样式，适配部分还未适配的黑暗模式 加了一个字体 重写分类和标签、归档页的样式，来源于ichika 优化页脚查看体验 优化网站性能 支持全屏 css 5k+ qpzc 解封辣！！！ 究极跳号？！CRT18:?! Acryple v1.0.92 修复部分bug（不，特性 优化部分样式 更改了博客设置的部分主题色 pages页面在Acrylic主题下的背景得到了改善 更改加载页面背景 重新进行部分断点 把博客api\\服务全部迁移到了另一个github账号~~(垃圾桶)~~上 优化搜索UI 对butterfly4.5.1进行了选择性同步(优化繁体字库) 疫情退退退awa Acryple v1.0.91 修复部分bug（不，特性 为APlayer进行完善 添加早报、木鱼、空调页面，参考Chuckle 更改关于页面，参考安知鱼的教程 尝试npm全站静态化，最终失败放弃qwq 优化sw，加载速度略有提升 新增文章统计 优化部分样式 Acryple v1.0.81 2022-11-23 修复部分bug（不，特性 优化性能问题，对弹幕进行了节流 添加APlayer，可惜没有pjax qwq 优化弹幕（更洪化了） 调整网站布局 修改一些样式 PS：在1.0.51偷偷加了一号字号你们发现没有(doge) Acryple v1.0.51 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 换用Twikoo-magic表情包 为了OI添加 KaTeX\\textbf{ \\KaTeX} KATE​X 修复跳转链接因原有bug被迫使原页面刷新的bug Acryple v1.0.14 2022-11-10 修复部分bug（不，特性 优化性能问题（但是好像还是没毛提升 增加浏览器过期提醒以及banIE，参考chuckle以及b站 增加fps显示 评论表情添加颜文字 修复手机端侧边栏bug PS：作为一个萌新OIer依然没有考虑发oi文 ╮(╯▽╰)╭ 以前的更新日志哔哩哔哩 (゜-゜)つロ 干杯！ 2022 07-02 终于弄好网站了，庆祝一下🎉 Gitalk不知道为什么不显示出来… 07-03 小更新，修改细节 作者的Html实在太菜了，效果并不好 07-04 大更新 修改了很多ui 07-05 大更新 修改细节UI和友链部分，增加吐槽部分 07-06 小更新，做好一些功能并且写了第一篇文章 07-08 大更新，更改首页布局，增加首页分区 07-09 小更新，修改细节，适配手机端，修复bug，说说由Artitalk换为BBtalk 07-14 前面几天忘记写更新了，更新了很多UI和功能。。。 07-18 前面几天又忘记写更新了小小修改了一些布局，把鸽了很久的博客写完了并且还加了萌百的黑幕，没有你知道的太多了差评 07-22 前面几天又双忘记写更新了折腾了很多，加了自己的域名，把你知道的太多了弄出来了，并且修复了很多js的bug，把unpkg换成fastly.jsdelivr或者elemecdn，提升速度（竟然有人加了我友链，怎么知道这个网站的？） 08-12 前面几天又双叒忘记写更新了还是折腾了很多，按照冰糖红茶大佬们的方法加了不少东西，比如那个人潮汹涌模拟器（主页的）、文章点赞、无缝跳转等等，换成jsdelivr加速，同时也在最大化利用GoormIDE，不过在险些没有数据之后就尽可能迁移到了其它没有风险的平台。 08-25 最近在糖果屋群友们的建议和帮助下修改了很多功能,以后每隔一段时间都会写详细的日志而不是像前面简单概括了。 留言板的弹幕是真的像b站视频弹幕了，过一段时间修复了bug之后放教程 新增博客设置，做了一个极简风的主题，支持更换主题色，也可以换回之前的主题，可以禁用模糊效果和开启硬件加速提升性能 修复了部分排版bug，对safari进行了一些适应，感谢Apple Store和洪哥的帮助。 增加了hover的缩放效果，有层次感 优化动画 修复留言弹幕、右键菜单的bug并且把新版的代码更新到文章中 优化细节样式 新增最新文章标记 总算部署好朋友圈了！leancloud国内版垃圾！"},{"title":"量化交易","date":"2023-02-15T04:00:00.000Z","updated":"2023-09-13T06:44:16.344Z","comments":true,"path":"trade/index.html","permalink":"https://t8840.github.io/trade/index.html","excerpt":"","text":""},{"title":"Web3","date":"2023-02-15T04:00:00.000Z","updated":"2023-09-13T06:44:16.346Z","comments":true,"path":"web3/index.html","permalink":"https://t8840.github.io/web3/index.html","excerpt":"","text":""},{"title":"早报","date":"2022-11-24T23:37:35.000Z","updated":"2023-09-13T06:44:16.347Z","comments":true,"path":"zaobao/index.html","permalink":"https://t8840.github.io/zaobao/index.html","excerpt":"","text":""}],"posts":[{"title":"GO-Gin.md","slug":"GO-Gin-md","date":"2023-10-06T14:23:11.000Z","updated":"2023-10-06T14:23:11.000Z","comments":true,"path":"posts/f7f486e4/","link":"","permalink":"https://t8840.github.io/posts/f7f486e4/","excerpt":"","text":"Doc DOC Render Deploy Doc","categories":[],"tags":[]},{"title":"WEB3-ETH-AccountAbstraction","slug":"WEB3-ETH-AccountAbstraction","date":"2023-09-30T23:10:28.000Z","updated":"2023-09-30T23:10:28.000Z","comments":true,"path":"posts/a3149765/","link":"","permalink":"https://t8840.github.io/posts/a3149765/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WEB3-StarknetID","slug":"WEB3-StarknetID","date":"2023-09-30T12:37:49.000Z","updated":"2023-09-30T12:37:49.000Z","comments":true,"path":"posts/27de3def/","link":"","permalink":"https://t8840.github.io/posts/27de3def/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WEB3-StarknetCairo","slug":"WEB3-StarknetCairo","date":"2023-09-30T08:18:06.000Z","updated":"2023-09-30T08:18:06.000Z","comments":true,"path":"posts/c22297a/","link":"","permalink":"https://t8840.github.io/posts/c22297a/","excerpt":"","text":"Introduction Doc Github Prepare Rust Environment Command Run Cairo code directly: 1cargo run --bin cairo-run -- --single-file /path/to/file.cairo","categories":[],"tags":[]},{"title":"WEB3-OpenzeppelinCairo","slug":"WEB3-OpenzeppelinCairo","date":"2023-09-30T07:36:11.000Z","updated":"2023-09-30T07:36:11.000Z","comments":true,"path":"posts/fc0767c2/","link":"","permalink":"https://t8840.github.io/posts/fc0767c2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WEB3-Openzeppelin","slug":"WEB3-Openzeppelin","date":"2023-09-30T07:33:54.000Z","updated":"2023-09-30T07:33:54.000Z","comments":true,"path":"posts/ec819f3b/","link":"","permalink":"https://t8840.github.io/posts/ec819f3b/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WEB3-SolanaContract","slug":"WEB3-SolanaContract","date":"2023-09-23T01:11:55.000Z","updated":"2023-09-23T01:11:55.000Z","comments":true,"path":"posts/8a6c712f/","link":"","permalink":"https://t8840.github.io/posts/8a6c712f/","excerpt":"","text":"HelloWorld Contract Code Review Hello World Contract Code Review From：Github 123456789use borsh::&#123;BorshDeserialize, BorshSerialize&#125;; use solana_program::&#123; account_info::&#123;next_account_info, AccountInfo&#125;, entrypoint, entrypoint::ProgramResult, msg, program_error::ProgramError, pubkey::Pubkey, &#125;; In the first section, the program imports some other codes. From code above, we can see that the program mainly use borsh and solana_program. Borsh is a tool used to serialize and deserialize data. Solana_program is a tool for program to interact with Solana chain. In Rust, these libraries are uploaded to crate. To import them, you just simply including these in cargo.toml as dependencies. Then, it can be installed through cargo command. Then, you can just simply import them as code above. 12345/// Define the type of state stored in accounts #[derive(BorshSerialize, BorshDeserialize, Debug)]pub struct GreetingAccount &#123; /// number of greetings pub counter: u32, &#125; Now, the program defines a struct called GreetingAccount. This is used to store a public variable called counter, which is a variable used to trace number of hellos a client has sent to this program. Public variable means it can be publicly accessed by simply calling it. This struct has inherited the functions of BorshSerailize, BorshDeserialize and Debug. It means any functions of these 3 can also be used by GreetingAccount. In Solana, this kind of changing variables need to be stored in a separate account. So, a user needs to provide a storage account for the program to store these data into. We would get into this shortly. Now, let’s move to the main logic of the contract. 1234567// Declare and export the program&#x27;s entrypointentrypoint!(process_instruction); // Program entrypoint&#x27;s implementationpub fn process_instruction( program_id: &amp;Pubkey, // Public key of the account the hello world program was loaded into accounts: &amp;[AccountInfo], // The account to say hello to _instruction_data: &amp;[u8], // Ignored, all helloworld instructions are hellos) In Solana, every program needs to define an entry point. All Solana program takes 3 parameters in entry point: (1) public key of the program, (2) a list of accounts that the program can write to and (3) instruction data. (1) above is easy to understand. It basically is the program id of your program. (2) is a bit confusing. So, as mentioned above, your program needs some accounts for them to keep track of some changing data. In this case, the changing data is the counter variable. If you need more than one accounts, the account info would be put in as an array and pass to the program. For (3), we may ignore instruction data as all instructions are just simply hello. Now, let’s move to ProgramResult: 123-&gt; ProgramResult&#123;msg!(&quot;Hello World Rust program entrypoint&quot;); // Iterating accounts is safer then indexing let accounts_iter = &amp;mut accounts.iter(); // Get the account to say hello to let account = next_account_info(accounts_iter)?; Then, the program result would be the major logic. After the welcome message, the first thing the program does is to make the accounts array iterable. So that the program can go through the array by using next_account_info() function. Again, this program only needs one account. So, we just need the first element of the account info array. 12345// The account must be owned by the program in order to modify its data if account.owner != program_id &#123; msg!(&quot;Greeted account does not have the correct program id&quot;); return Err(ProgramError::IncorrectProgramId); &#125; As mentioned earlier, the program has to be owner of the account in order to amend any data in it. So, you need to check if the account owner points to the program. Otherwise, return an error message. 123456// Increment and store the number of times the account has been greetedlet mut greeting_account = GreetingAccount::try_from_slice(&amp;account.data.borrow())?; greeting_account.counter += 1; greeting_account.serialize(&amp;mut &amp;mut account.data.borrow_mut()[..])?; msg!(&quot;Greeted &#123;&#125; time(s)!&quot;, greeting_account.counter); Ok(()) &#125; Now, grab the data from the account provided by the user and use try_from_slice() to deserialize it. try_from_slice() is a function defined in BorshDeserialize. Now, increment the counter variable from the account by 1. Then, serialize the updated counter variable and put it back to the account. Lastly, the program call the updated counter variable from the account and print it out. Hello World Contract API From:GitHub Run The Program 1234567891011git clone https://github.com/solana-labs/example-helloworld.gitcd example-helloworld/npm installsolana addresssolana balance address # if balance not enough ,need to get airdropnpm run build:program-rustsolana program deploy dist/program/helloworld.sonpm run start # Can see the hello result Program Flow So, let’s go through main.ts first. Its main() function in main.ts looks like below: 1234567891011121314async function main() &#123; console.log(&quot;Let&#x27;s say hello to a Solana account...&quot;); // Establish connection to the cluster await establishConnection(); // Determine who pays for the fees await establishPayer(); // Check if the program has been deployed await checkProgram(); // Say hello to an account await sayHello(); // Find out how many times that account has been greeted await reportGreetings(); console.log(&#x27;Success&#x27;);&#125; So, it basically outline the flow of the program: Establish connection to cluster; Get ready to pay lamport; Say hello; print number of hellos. You may notice that there is a checkProgram() function too. However, in this passage, I would skip this part as I want to focus more on how a client program interact with a Smart Contract. Ok. Now, let’s go through each step one by one: Establish connection to cluster 123456789101112131415161718192021222324252627282930313233//utils.tsasync function getConfig(): Promise&lt;any&gt; &#123; // Path to Solana CLI config file const CONFIG_FILE_PATH = path.resolve( os.homedir(), &#x27;.config&#x27;, &#x27;solana&#x27;, &#x27;cli&#x27;, &#x27;config.yml&#x27;, ); const configYml = await fs.readFile(CONFIG_FILE_PATH, &#123;encoding: &#x27;utf8&#x27;&#125;); return yaml.parse(configYml); &#125;export async function getRpcUrl(): Promise&lt;string&gt; &#123; try &#123; const config = await getConfig(); if (!config.json_rpc_url) throw new Error(&#x27;Missing RPC URL&#x27;); return config.json_rpc_url; &#125; catch (err) &#123; console.warn( &#x27;Failed to read RPC url from CLI config file, falling back to localhost&#x27;, ); return &#x27;http://localhost:8899&#x27;; &#125; &#125;//helloworld.tsexport async function establishConnection(): Promise&lt;void&gt; &#123; const rpcUrl = await getRpcUrl(); connection = new Connection(rpcUrl, &#x27;confirmed&#x27;); const version = await connection.getVersion(); console.log(&#x27;Connection to cluster established:&#x27;, rpcUrl, version); &#125; So, main logic of establish connection is situated in helloworld.ts. It utilize a function in util.ts called getRpcUrl() to look for current config info. getRpcUrl() calls another function within utils.ts named getconfig() to get the information in ~/.config/solana/cli/config.yml. If you open this file in your local environment, it looks something like this: 12345678cat /root/.config/solana/cli/config.yml --- json_rpc_url: &quot;http://127.0.0.1:8899&quot; websocket_url: &quot;&quot; keypair_path: /root/wallet/wallet1.json address_labels: &quot;11111111111111111111111111111111&quot;: System Program So, it basically stores all your config info. Now, getRpcURL() function tries to read the json_rpc_url parameter and return it as a result. This parameter basically indicates which cluster your environment is connected to. In above case, you are connected to a local cluster. If it is empty, it would throw error and it would return local cluster value by default. Finally, establishConnection() function would capture this value and establish connection to the cluster. Get ready to pay lamport This step is executed in the establishedPayer() function in helloworld.ts. Solana is just like other Blockchain. You need to pay fee for a transaction. In this client program, it will call for airdrop if the account is not sufficient to pay for the transaction. Now, we will go through the related code in 2 parts: 1234567891011export async function establishPayer(): Promise&lt;void&gt; &#123; let fees = 0; if (!payer) &#123; const &#123;feeCalculator&#125; = await connection.getRecentBlockhash(); // Calculate the cost to fund the greeter account fees += await connection.getMinimumBalanceForRentExemption(GREETING_SIZE); // Calculate the cost of sending transactions fees += feeCalculator.lamportsPerSignature * 100; payer = await getPayer(); &#125; So, the first part just calculate the lamport needed to send the hello transaction. So, we can get an airdrop if fund is insufficient. Getpayer() function is an function imported from util.ts which is used to return the keypair of your account. Code of getpayer() is as per below: 12345678910111213export async function getPayer(): Promise&lt;Keypair&gt; &#123; try &#123; const config = await getConfig(); if (!config.keypair_path) throw new Error(&#x27;Missing keypair path&#x27;); return await createKeypairFromFile(config.keypair_path); &#125; catch (err) &#123; console.warn( &#x27;Failed to create keypair from CLI config file, falling back to new random keypair&#x27;, ); return Keypair.generate(); &#125; &#125; Then, second part of estabilishdPayer() function is simple. Just request an airdrop if its balance is insufficient to fund the transaction and a log message at the end: 123456789101112131415let lamports = await connection.getBalance(payer.publicKey); if (lamports &lt; fees) &#123; // If current balance is not enough to pay for fees, request an airdrop const sig = await connection.requestAirdrop( payer.publicKey, fees - lamports, ); await connection.confirmTransaction(sig); lamports = await connection.getBalance(payer.publicKey); &#125;console.log( &#x27;Using account&#x27;, payer.publicKey.toBase58(), &#x27;containing&#x27;, lamports / LAMPORTS_PER_SOL, &#x27;SOL to pay for fees&#x27;, ); Say hello So, now the we move to the most interesting part. So, let’s take a look: 12345const GREETING_SEED = &#x27;hello&#x27;; greetedPubkey = await PublicKey.createWithSeed( payer.publicKey, GREETING_SEED, programId, ); The above code is placed in helloworld.ts. As mentioned in previous post, user needs to feed an account to the program to store the counter variable. The above code is written exactly to serve this purpose. It uses a function imported from web3.js named createWithSeed(). This is a way to generate a public key using a seed word (i.e. “hello” from above example) and a program ID. The program ID mentioned would also be the owner of this account so the program can amend data in this account at will. You can find some more details of this function in its doc. So, now, we can use the greetedPubkey to send an instruction to instruct the program to update the account. 12345678910111213141516export async function sayHello(): Promise&lt;void&gt; &#123; console.log( &#x27;Saying hello to&#x27;, greetedPubkey.toBase58() ); const instruction = new TransactionInstruction(&#123; keys: [&#123;pubkey: greetedPubkey, isSigner: false, isWritable: true&#125;], programId, data: Buffer.alloc(0), // All instructions are hellos &#125;); await sendAndConfirmTransaction( connection, new Transaction().add(instruction), [payer], ); &#125; The code above is used to construct an instruction to interact with the program. After a greeting message, it sends a transaction with keys about account info, programId and data to the cluster. These information is exactly matched with entrypoint of the program as mentioned in previous post. The keys array in it mainly indicates the account parameters. Because if you remember, a program cannot call for account data. It can only relies on client to provide such information. Finally, the instruction is sent out using sendAndConfirmTransaction() function imported from web3.js. print number of hellos It is all worked in reportGreetings() function in helloworld.ts. It first get account info using connection.getAccountInfo() function provided by web3.js and extract the information from the account, deserialise it and print it out. Major code is as below: 1234567891011121314151617export async function reportGreetings(): Promise&lt;void&gt; &#123; const accountInfo = await connection.getAccountInfo(greetedPubkey); if (accountInfo === null) &#123; throw &#x27;Error: cannot find the greeted account&#x27;; &#125; const greeting = borsh.deserialize( GreetingSchema, GreetingAccount, accountInfo.data, ); console.log( greetedPubkey.toBase58(), &#x27;has been greeted&#x27;, greeting.counter, &#x27;time(s)&#x27;, ); &#125; The most important part in above code is how we use borsh.deserialize() function to deserialise. In borsh deserialisation, you will create an object to store the deserialsed values. In here, the object is called greeting. In order to construct this object, you need a class to define properties of this object (i.e. GreetingAccount in code above). Also, you need to define a Schema to map the deserialised data to the object (i.e. GreetingSchema in above code) and data to be deserialised. If you remember from previous post, the data structure to be deserialized is like this: 1234GreetingAccount &#123; pub counter: u32, &#125; So, the GreetingSchema code would be as below: 123/** * Borsh schema definition for greeting accounts */ const GreetingSchema = new Map([ [GreetingAccount, &#123;kind: &#x27;struct&#x27;, fields: [[&#x27;counter&#x27;, &#x27;u32&#x27;]]&#125;],]); Easy. Right? Just map GreetingAccount to a struct type data structure as above. Now, let’s take a look of GreetingAccount class: 1234567/** * The state of a greeting account managed by the hello world program */class GreetingAccount &#123; counter = 0;constructor(fields: &#123;counter: number&#125; | undefined = undefined) &#123; if (fields) &#123; this.counter = fields.counter; &#125; &#125; &#125; So, borsh.deserialize() function will pass the deserialised data to the class to construct a new object. So, what the class does is just give it a counter property and set to 0 by default. Then, it contains a constructor which would create an object once the data arrives. After that, it read the data and put it back into counter variable. More Contract https://github.com/solana-labs/solana-program-library","categories":[{"name":"WEB3","slug":"WEB3","permalink":"https://t8840.github.io/categories/WEB3/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"https://t8840.github.io/tags/Solana/"}]},{"title":"SolanaAPI","slug":"WEB3-SolanaAPI","date":"2023-09-21T08:58:54.000Z","updated":"2023-09-21T08:58:54.000Z","comments":true,"path":"posts/4ad83bb9/","link":"","permalink":"https://t8840.github.io/posts/4ad83bb9/","excerpt":"","text":"solana-api id.json 私钥导入 id.json import Demo Doc: https://github.com/solana-developers/web3-examples TX 1234567891011121314151617181920212223// Create transactionconst tx = new web3.Transaction(&#123; ...blockhashInfo,&#125;);// console.log(tx)// Add our hello world program instructiontx.add( new web3.TransactionInstruction(&#123; programId: pg.PROGRAM_ID, keys: [], data: Buffer.from([]), &#125;));// Sign transactiontx.sign(pg.wallet.keypair);// Send the transaction to the Solana clusterconst txHash = await pg.connection.sendRawTransaction(tx.serialize());console.log(txHash);// this txHash can view in","categories":[{"name":"WEB3","slug":"WEB3","permalink":"https://t8840.github.io/categories/WEB3/"}],"tags":[{"name":"WEB3","slug":"WEB3","permalink":"https://t8840.github.io/tags/WEB3/"}]},{"title":"VUE-Admin.md","slug":"VUE-Admin-md","date":"2023-09-20T13:13:50.000Z","updated":"2023-09-20T13:13:50.000Z","comments":true,"path":"posts/637719b9/","link":"","permalink":"https://t8840.github.io/posts/637719b9/","excerpt":"","text":"Vue Admin Framework","categories":[],"tags":[]},{"title":"Vue.md","slug":"Vue-md","date":"2023-09-20T13:13:36.000Z","updated":"2023-09-20T13:13:36.000Z","comments":true,"path":"posts/fe80f986/","link":"","permalink":"https://t8840.github.io/posts/fe80f986/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TOOL-Telegram","slug":"TOOL-Telegram","date":"2023-09-18T08:49:06.000Z","updated":"2023-09-18T08:49:06.000Z","comments":true,"path":"posts/ae5fc1f2/","link":"","permalink":"https://t8840.github.io/posts/ae5fc1f2/","excerpt":"","text":"TG Bot Bot Application Auto Increasing Bot TG Search bot list https://tgbots.io/ TG Usage Telegrams使用知识库：https://github.com/tgnav/tgwiki","categories":[],"tags":[]},{"title":"PYTHON-Cpython","slug":"PYTHON-Cpython","date":"2023-09-17T20:21:18.000Z","updated":"2023-09-17T20:21:18.000Z","comments":true,"path":"posts/503e93da/","link":"","permalink":"https://t8840.github.io/posts/503e93da/","excerpt":"","text":"PyObject 底层任何类型创建都会使用到PyObject PyObject是由2部分组成：引用计数（ob_refcnt)和一个指针(ob_type) Python/C API Python###_From@@@ C的类型创建Python类型：如PythonFloat_FromDouble 对象创建 分配内存的过程。 PyObject的创建对象过程很有意思： __new__与__init创建的机制原理可以在 tp_new和tp_init中找到答案：https://www.cnblogs.com/traditional/p/13410961.html 123456789101112131415static PyObject *type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)&#123; //当我们创建一个类的实例对象的时候，会去调用元类的__call__方法，所以是这里的tp_call //比如Girl(&quot;古明地觉&quot;, 16) 等价于 type.__call__(Girl, &quot;古明地觉&quot;, 16) //所以走到了这一步 //调用__new__方法， 拿到其返回值 obj = type-&gt;tp_new(type, args, kwds); if (type-&gt;tp_init != NULL) &#123; //调用__init__，将返回值obj传递给__init__中的self，并在里面设置属性 int res = type-&gt;tp_init(obj, args, kwds); return obj;&#125; 对象的行为 引用计数 print(sys.getrefcount(int)) 是一行 Python 代码，用于获取整数类型对象的引用计数 垃圾回收","categories":[],"tags":[]},{"title":"PYTHON-Interpreter","slug":"PYTHON-Interpreter","date":"2023-09-17T07:18:57.000Z","updated":"2023-09-17T07:18:57.000Z","comments":true,"path":"posts/4a7fb4fe/","link":"","permalink":"https://t8840.github.io/posts/4a7fb4fe/","excerpt":"","text":"Python Interpreter Python 解释器（Python Interpreter）由 Python 编译器（Python Compiler）和 Python 虚拟机（Python Virutal Machine）两部分组成。 当我们通过 Python 命令执行 Python 代码时，Python 编译器会将 Python 代码编译为 Python 字节码（bytecode）；随后 Python 虚拟机会读取并逐步执行这些字节码。 Python Compiler Python 编译器的实现和其他语言类似，包含了词法分析 Lexical，语法分析 Syntax Analysis 和语义分析 Semantic Analysis 等步骤. Python Virutal Machine 参考：https://www.cnblogs.com/traditional/p/13513799.html","categories":[],"tags":[]},{"title":"PYTHON-Thread","slug":"PYTHON-Thread","date":"2023-09-17T07:15:57.000Z","updated":"2023-09-17T07:15:57.000Z","comments":true,"path":"posts/f63e54df/","link":"","permalink":"https://t8840.github.io/posts/f63e54df/","excerpt":"","text":"threading 123456789101112131415161718192021# multi_threaded.pyimport timefrom threading import ThreadCOUNT = 50000000def countdown(n): while n&gt;0: n -= 1t1 = Thread(target=countdown, args=(COUNT//2,))t2 = Thread(target=countdown, args=(COUNT//2,))start = time.time()t1.start()t2.start()t1.join()t2.join()end = time.time()print(&#x27;Time taken in seconds -&#x27;, end - start) multiprocessing 1234567891011121314151617from multiprocessing import Poolimport timeCOUNT = 50000000def countdown(n): while n&gt;0: n -= 1if __name__ == &#x27;__main__&#x27;: pool = Pool(processes=2) start = time.time() r1 = pool.apply_async(countdown, [COUNT//2]) r2 = pool.apply_async(countdown, [COUNT//2]) pool.close() pool.join() end = time.time() print(&#x27;Time taken in seconds -&#x27;, end - start) GIL","categories":[],"tags":[]},{"title":"PYTHON-Net","slug":"PYTHON-Net","date":"2023-09-17T07:15:26.000Z","updated":"2023-09-17T07:15:26.000Z","comments":true,"path":"posts/5c947c4e/","link":"","permalink":"https://t8840.github.io/posts/5c947c4e/","excerpt":"","text":"Http Socket","categories":[],"tags":[]},{"title":"TEST-Playwright","slug":"TEST-Playwright","date":"2023-09-17T02:49:10.000Z","updated":"2023-09-17T02:49:10.000Z","comments":true,"path":"posts/d2249d63/","link":"","permalink":"https://t8840.github.io/posts/d2249d63/","excerpt":"","text":"Install pip install method 12pip install playwrightplaywright install Usage Element Locate and Operation Element Locate Find Single Element：querySelector(engine=body) Find Multi Elements：querySelectorAll(engine=body) Find Single Element and Auto Wait：waitForSelector(engine=body) Compare Locate Selector By的8种定位方式，实际为4种 id、name、tag name、class name（java和pythona将该4种都归为CSS） xpath、link text、partial link text、css selector W3C标准规定的webDriver协议为5种定位方式 CSS、Link text、Partial link text、Tag name、XPath Playwright将选择器汇总为3种 CSS、XPATH（支持逻辑表达式和函数）、TEXT The Playwright Selector Rule: CSS：ID选择器、类选择器、元素选择器、属性选择器、通配选择器、层次选择器。 XPath：XML路径语言，通过“路径标识符”，导航XML文档的，在类XML种（HTML）也可以使用。 Text： 结构化内容（html，xml，json）使用模糊匹配（忽略大小写，忽略前后空格，搜索子字符串）及精确匹配、非结构化内容使用正则匹配 Common Element Operation 下拉选择框：selectOpion、value、label、index 文件上传：setInputFiles、单个文件、多个文件、拖放上传 鼠标点击：click、dbclick 鼠标拖动：down、up 鼠标移动：move 触摸屏幕：tag 键盘按键：press 截屏、录屏：screenshot、recordVideo Mock API Doc","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"TEST-VirusCheck","slug":"TEST-VirusCheck","date":"2023-09-16T22:34:33.000Z","updated":"2023-09-16T22:34:33.000Z","comments":true,"path":"posts/722d40c2/","link":"","permalink":"https://t8840.github.io/posts/722d40c2/","excerpt":"","text":"Online Check 以下是一些常见的在线检测病毒的网站： VirusTotal（https://www.virustotal.com）：VirusTotal 是一个非常受欢迎的在线多引擎病毒扫描服务。它能够通过使用多个杀毒引擎来检测文件的恶意性，并提供关于文件安全性的报告。 Jotti’s malware scan（https://virusscan.jotti.org）：Jotti’s malware scan 是另一个流行的在线病毒扫描服务。它使用多个杀毒引擎来扫描文件，并提供与恶意软件相关的详细信息。 Hybrid Analysis（https://www.hybrid-analysis.com）：Hybrid Analysis 是一个集成了多个安全工具和杀毒引擎的在线恶意软件分析平台。它可以对文件、URL 和 IP 地址进行全面的安全分析。 MetaDefender（https://metadefender.opswat.com）：MetaDefender 是一个集成了多个杀毒引擎的在线文件扫描服务。它提供了对文件的安全性评估和恶意软件检测。 Google Safe Browsing（https://safebrowsing.google.com）：Google Safe Browsing 是由 Google 提供的服务，可以检测恶意软件和不安全的网站。它可以帮助用户识别和避免访问潜在的恶意网站。","categories":[],"tags":[]},{"title":"PYTHON-Funtion","slug":"PYTHON-Funtion","date":"2023-09-16T22:23:41.000Z","updated":"2023-09-16T22:23:41.000Z","comments":true,"path":"posts/81c90c6b/","link":"","permalink":"https://t8840.github.io/posts/81c90c6b/","excerpt":"","text":"higher-order function closure decorator 装饰器是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的闭包原理实现的。 装饰器的优势并不在于它提供了动态修改函数的能力，而在于它把影响函数的装饰行为移到了函数头部，降低了代码的阅读与理解成本 为了充分发挥这个优势，装饰器特别适合用来实现以下功能。 (1) 运行时校验：在执行阶段进行特定校验，当校验通不过时终止执行。 适合原因：装饰器可以方便地在函数执行前介入，并且可以读取所有参数辅助校验。 代表样例：Django 框架中的用户登录态校验装饰器 @login_required。 (2) 注入额外参数：在函数被调用时自动注入额外的调用参数。 适合原因：装饰器的位置在函数头部，非常靠近参数被定义的位置，关联性强。 代表样例：unittest.mock 模块的装饰器 @patch。 (3) 缓存执行结果：通过调用参数等输入信息，直接缓存函数执行结果。 适合原因：添加缓存不需要侵入函数内部逻辑，并且功能非常独立和通用。 代表样例：functools 模块的缓存装饰器 @lru_cache。 (4) 注册函数：将被装饰函数注册为某个外部流程的一部分。 适合原因：在定义函数时可以直接完成注册，关联性强。 代表样例：Flask 框架的路由注册装饰器 @app.route。 (5) 替换为复杂对象：将原函数（方法）替换为更复杂的对象，比如类实例或特殊的描述符对象）。 适合原因：在执行替换操作时，装饰器语法天然比 foo = staticmethod(foo) 的写法要直观得多。 代表样例：静态类方法装饰器 @staticmethod。 (1) 基础与技巧 装饰器最常见的实现方式，是利用闭包原理通过多层嵌套函数实现 在实现装饰器时，请记得使用 wraps() 更新包装函数的元数据 wraps() 不光可以保留元数据，还能保留包装函数的额外属性 利用仅限关键字参数，可以很方便地实现可选参数的装饰器 (2) 使用类来实现装饰器 只要是可调用的对象，都可以用作装饰器 实现了 call 方法的类实例可调用 基于类的装饰器分为两种：“函数替换”与“实例替换” “函数替换”装饰器与普通装饰器没什么区别，只是嵌套层级更少 通过类来实现“实例替换”装饰器，在管理状态和追加行为上有天然的优势 混合使用类和函数来实现装饰器，可以灵活满足各种场景 (3) 使用 wrapt 模块 使用 wrapt 模块可以方便地让装饰器同时兼容函数和类方法 使用 wrapt 模块可以帮你写出结构更扁平的装饰器代码 (4) 装饰器设计技巧 装饰器将包装调用提前到了函数被定义的位置，它的大部分优点也源于此 在编写装饰器时，请考虑你的设计是否能很好发挥装饰器的优势 在某些场景下，类装饰器可以替代元类，并且代码更简单 装饰器和装饰器模式截然不同，不要弄混它们 装饰器里应该只有一层浅浅的包装代码，要把核心逻辑放在其他函数与类中","categories":[],"tags":[]},{"title":"PYTHON-Pattern","slug":"PYTHON-Pattern","date":"2023-09-16T17:20:41.000Z","updated":"2023-09-16T17:20:41.000Z","comments":true,"path":"posts/c1a6ff49/","link":"","permalink":"https://t8840.github.io/posts/c1a6ff49/","excerpt":"","text":"单例设计模式 假设你在开发一个程序，它的所有配置项都保存在一个特定文件中。在项目启动时，程序需要从配置文件中读取所有配置项，然后将其加载进内存供其他模块使用。 由于程序执行时只需要一个全局的配置对象，因此你觉得这个场景非常适合使用经典设计模式：单例模式（singleton pattern）。 下面的代码就应用了单例模式的配置类 AppConfig： 12345678910111213141516171819202122class AppConfig: &quot;&quot;&quot;程序配置类，使用单例模式&quot;&quot;&quot; _instance = None def __new__(cls): if cls._instance is None: inst = super().__new__(cls) # 省略：从外部配置文件读取配置 ... cls._instance = inst return cls._instance def get_database(self): &quot;&quot;&quot;读取数据库配置&quot;&quot;&quot; ... def reload(self): &quot;&quot;&quot;重新读取配置文件，刷新配置&quot;&quot;&quot; ...``` 在 Python 中，实现单例模式的方式有很多，而上面这种最为常见，它通过重写类的 __new__ 方法来接管实例创建行为。当 __new__ 方法被重写后，类的每次实例化返回的不再是新实例，而是同一个已经初始化的旧实例 cls._instance： c1 = AppConfig() c2 = AppConfig() c1 is c2 ➊ True 123❶ 测试单例模式，调用 AppConfig() 总是会产生同一个对象基于上面的设计，如果其他人想读取数据库配置，代码需要这样写： from project.config import AppConfig db_conf = AppConfig().get_database() 重新加载配置 AppConfig().reload() 123456虽然在处理这种全局配置对象时，单例模式是一种行之有效的解决方案，但在 Python 中，其实有一种更简单的做法——预绑定方法模式。预绑定方法模式（prebound method pattern）是一种将对象方法绑定为函数的模式。要实现该模式，第一步就是完全删掉 AppConfig 里的单例设计模式。因为在 Python 里，实现单例压根儿不用这么麻烦，我们有一个随手可得的单例对象——模块（module）。当你在 Python 中执行 import 语句导入模块时，无论 import 执行了多少次，每个被导入的模块在内存中只会存在一份（保存在 sys.modules 中）。因此，要实现单例模式，只需在模块里创建一个全局对象即可： class AppConfig: “”“程序配置类，使用单例模式”“” def __init__(self): ➊ # 省略：从外部配置文件读取配置 ... _config = AppConfig() ➋ 12345❶ 完全删掉单例模式的相关代码，只实现 __init__ 方法❷ _config 就是我们的“单例 AppConfig 对象”，它以下划线开头命名，表明自己是一个私有全局变量，以免其他人直接操作下一步，为了给其他模块提供好用的 API，我们需要将单例对象 _config 的公有方法绑定到 config 模块上： file: project/config.py _config = Config() get_database_conf = _config.get_database reload_config = _config.reload 1之后，其他模块就可以像调用普通函数一样操作应用配置对象了： from project.config import get_databse_conf db_conf = get_databse_conf() reload_config() 通过“预绑定方法模式”，我们既避免了复杂的单例设计模式，又有了更易使用的函数 API，可谓一举两得。","categories":[],"tags":[]},{"title":"PYTHON-Class","slug":"PYTHON-Class","date":"2023-09-16T17:09:23.000Z","updated":"2023-09-16T17:09:23.000Z","comments":true,"path":"posts/24fbf1e4/","link":"","permalink":"https://t8840.github.io/posts/24fbf1e4/","excerpt":"","text":"面向对象 类与实例的数据，都保存在一个名为 dict 的字典属性中 灵活利用 dict 属性，能帮你做到常规做法难以完成的一些事情 使用 @classmethod 可以定义类方法，类方法常用作工厂方法 使用 @staticmethod 可以定义静态方法，静态方法不依赖实例状态，是一种无状态方法 使用 @property 可以定义动态属性对象，该属性对象的获取、设置和删除行为都支持自定义 @property 无描述符时，实现属性校验功能 在下面的代码里，我实现了一个 Person 类： 123456789class Person: def __init__(self, name, age): self.name = name self.age = age``` Person 是个特别简单的数据类，没有任何约束，因此人们很容易创建出一些不合理的数据，比如年龄为 1000、年龄不是合法数字的 Person 对象等。为了确保对象数据的合法性，我需要给 Person 的年龄属性加上一些正确性校验。使用 @property 把 age 定义为 property 对象后，我可以很方便地增加校验逻辑： class Person: … @property def age(self): return self._age @age.setter def age(self, value): &quot;&quot;&quot;设置年龄，只允许 0～150 之间的数值&quot;&quot;&quot; try: value = int(value) except (TypeError, ValueError): raise ValueError('value is not a valid integer!') if not (0 &lt; value &lt; 150): raise ValueError('value must between 0 and 150!') self._age = value 1通过在 age 属性的 setter 方法里增加校验，我最终实现了想要的效果： p = Person(‘piglei’, ‘invalid_age’) ➊ … ValueError: value is not a valid integer! p = Person(‘piglei’, ‘200’) ➋ … ValueError: value must between 0 and 150! p = Person(‘piglei’, 18) ➌ p.age 18 12345678910❶ age 值不能转换为整型❷ age 值不在合法的年龄范围内❸ age 值符合要求，对象创建成功粗看上去，上面使用 @property 的方案还挺不错的，但实际上有许多不如人意的地方。使用属性对象最大的缺点是：很难复用。假如我现在开发了一个长方形类 Rectangle，想对长方形的边长做一些与 Person.age 类似的整型校验，那么我根本无法很好地复用上面的校验逻辑，只能手动为长方形的边长创建多个 @property 对象，然后在每个 setter 方法里做重复工作： class Rectangle: @property def width(self): ... @width.setter def width(self): ... @property def height(self): ... @height.setter def height(self): ... 1234567891011121314151617181920212223242526272829如果非得基于 @property 来实现复用，我也可以继续用类装饰器（class decorator）或元类（metaclass）在创建类时介入处理，把普通属性自动替换为 property 对象来达到复用目的。但是，这种方案不但实现起来复杂，使用起来也不方便。而使用描述符，我们可以更轻松地实现这类需求。不过在用描述符实现字段校验前，我们先了解一下描述符的基本工作原理。## 面向对象高级特性Python 使用 MRO 算法来确定多重继承时的方法优先级super() 函数获取的并不是当前类的父类，而是当前 MRO 链条里的下一个类Mixin 是一种基于多重继承的有效编程模式，用好 Mixin 需要精心的设计元类的功能相当强大，但同时也相当复杂，除非开发一些框架类工具，否则你极少需要使用元类元类有许多更简单的替代品，比如类装饰器、子类化钩子方法等通过定义 __init_subclass__ 钩子方法，你可以在某个类被继承时执行自定义逻辑## 抽象类抽象类提供了一种更灵活的子类化机制，我们可以通过定义抽象类来改变 isinstance() 的行为通过 @abstractmethod 装饰器，你可以要求抽象类的子类必须实现某个方法## Mixin 的概念Mixin 即 Mix-in，常被译为“混入”，是一种编程模式，在 Python 等面向对象语言中，通常它是实现了某种功能单元的类，用于被其他子类继承，将功能组合到子类中。利用 Python 的多重继承，子类可以继承不同功能的 Mixin 类，按需动态组合使用。当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 Mixin 类。举个例子定义一个简单的类： class Person: def init(self, name, gender, age): self.name = name self.gender = gender self.age = age 123456我们可以通过调用实例属性的方式来访问：``` p = Person(&quot;小陈&quot;, &quot;男&quot;, 18)print(p.name) # &quot;小陈&quot;``` 然后我们定义一个 Mixin 类： class MappingMixin: def getitem(self, key): return self.dict.get(key) def __setitem__(self, key, value): return self.__dict__.set(key, value) 这个类可以让子类拥有像 dict 一样调用属性的功能 我们将这个 Mixin 加入到 Person 类中： class Person(MappingMixin): def init(self, name, gender, age): self.name = name self.gender = gender self.age = age 现在 Person 拥有另一种调用属性方式了： p = Person(“小陈”, “男”, 18) print(p[‘name’]) # “小陈” print(p[‘age’]) # 18 再定义一个 Mixin 类，这个类实现了 __repr__ 方法，能自动将属性与值拼接成字符串： class ReprMixin: def repr(self): s = self.class.name + ‘(’ for k, v in self.dict.items(): if not k.startswith(‘_’): s += '{}={}, ‘.format(k, v) s = s.rstrip(’, ') + ‘)’ # 将最后一个逗号和空格换成括号 return s 利用 Python 的特性，一个类可以继承多个父类： class Person(MappingMixin, ReprMixin): def init(self, name, gender, age): self.name = name self.gender = gender self.age = age 这样这个子类混入了两种功能： p = Person(“小陈”, “男”, 18) print(p[‘name’]) # “小陈” print(p) # Person(name=小陈, gender=男, age=18) - 总结 Mixin 实质上是利用语言特性，可以把它看作一种特殊的多重继承，所以它并不是 Python 独享，只要支持多重继承或者类似特性的都可以使用，比如 Ruby 中 include 语法，Vue 等前端领域也有 Mixin 的概念。 但 Mixin 终归不属于语言的语法，为了代码的可读性和可维护性，定义和使用 Mixin 类应该遵循几个原则： Mixin 实现的功能需要是通用的，并且是单一的，比如上例中两个 Mixin 类都适用于大部分子类，每个 Mixin 只实现一种功能，可按需继承。 Mixin 只用于拓展子类的功能，不能影响子类的主要功能，子类也不能依赖 Mixin。比如上例中 Person 继承不同的 Mixin 只是增加了一些功能，并不影响自身的主要功能。如果是依赖关系，则是真正的基类，不应该用 Mixin 命名。 Mixin 类自身不能进行实例化，仅用于被子类继承。 ## 元类 ### __init_subclass__","categories":[],"tags":[]},{"title":"TEST-Pytest","slug":"TEST-Pytest","date":"2023-09-16T16:28:13.000Z","updated":"2023-09-16T16:28:13.000Z","comments":true,"path":"posts/eedd2024/","link":"","permalink":"https://t8840.github.io/posts/eedd2024/","excerpt":"","text":"pytest 是一个开源的第三方单元测试框架，第一个版本发布于 2009 年。同 unittest 比起来，pytest 功能更多，设计更复杂，上手难度也更高。但 pytest 的最大优势在于，它把 Python 的一些惯用写法与单元测试很好地融合了起来。因此，当你掌握了 pytest 以后，用它写出的测试代码远比用 unittest 写的简洁。 为了更好地展示 pytest 的能力，下面我试着用它来写单元测试。 假设 Python 里的字符串没有提供 upper() 方法，我得自己编写一个函数，来实现将字符串转换为大写的功能。 string_utils.py 123456789101112131415161718192021222324252627282930313233343536373839404142def string_upper(s: str) -&gt; str: &quot;&quot;&quot;将某个字符串里的所有英文字母由小写转换为大写&quot;&quot;&quot; chars = [] for ch in s: # 32 是小写字母与大写字母在 ASCII 码表中的距离 chars.append(chr(ord(ch) - 32)) return &#x27;&#x27;.join(chars) 为了测试函数的功能，我用 pytest 写了一份单元测试： 文件：test_string_utils.pyfrom string_utils import string_upperdef test_string_upper(): assert string_upper(&#x27;foo&#x27;) == &#x27;FOO&#x27;``` 相信你已经发现了，用 pytest 编写的单元测试代码与 unittest 有很大不同。 首先，TestCase 类消失了。使用 pytest 时，你不必用一个 TestCase 类来定义测试用例，用一个以 test 开头的普通函数也行。 其次，当你要进行断言判断时，不需要调用任何特殊的 assert&#123;X&#125;() 方法，只要写一条原生的断言语句 assert &#123;expression&#125; 就好。 正因为这些简化，用 pytest 来编写测试用例变得非常容易。 用 pytest 执行上面的测试文件，会输出以下结果：$ pytest test_string_utils.py===================== test session starts =====================platform darwin -- Python 3.8.1, pytest-6.2.2rootdir: /python_craftman/collected 1 itemtest_string_utils.py . [100%]====================== 1 passed in 0.01s ====================== 看上去一切顺利，string_upper() 函数可以通过测试。 但话说回来，就测试用例的覆盖率来说，我写的测试代码根本就不合格。因为我的用例只有输入字符全为小写的情况，并没有考虑到其他场景。比如，当输入字符串为空、输入字符串混合了大小写时，我们其实并不知道函数是否能返回正确结果。 为了让单元测试覆盖更多场景，最直接的办法是在 test_string_utils.py 里增加测试函数。 比如： from string_utils import string_upper def test_string_upper(): assert string_upper(‘foo’) == ‘FOO’ def test_string_empty(): ➊ assert string_upper(‘’) == ‘’ def test_string_mixed_cases(): assert string_upper(‘foo BAR’) == ‘FOO BAR’ 123456789101112131415❶ 新增两个测试函数 虽然像上面这样增加函数很简单，但 pytest 其实为我们提供了更好的工具。用 parametrize 编写参数化测试在单元测试领域，有一种常用的编写测试代码的技术：表驱动测试（table-driven testing）。当你要测试某个函数在接收到不同输入参数的行为时，最直接的做法是像上面那样，直接编写许多不同的测试用例。但这种做法其实并不好，因为它很容易催生出重复的测试代码。表驱动测试是一种简化单元测试代码的技术。它鼓励你将不同测试用例间的差异点抽象出来，提炼成一张包含多份输入参数、期望结果的数据表，以此驱动测试执行。如果你要增加测试用例，直接往表里增加一份数据就行，不用写任何重复的测试代码。在 pytest 中实践表驱动测试非常容易。pytest 为我们提供了一个强大的参数测试工具：pytest.mark.parametrize。利用该装饰器，你可以方便地定义表驱动测试用例。以测试文件 test_string_utils.py 为例，使用 parametrize 后的测试代码 import pytest from string_utils import string_upper @pytest.mark.parametrize( ‘s,expected’, ➊ [ (‘foo’, ‘FOO’), ➋ (‘’, ‘’), (‘foo BAR’, ‘FOO BAR’), ], ) def test_string_upper(s, expected): ➌ assert string_upper(s) == expected ➍ 123456789❶ 用逗号分隔的参数名列表，也可以理解为数据表每一列字段的名称❷ 数据表的每行数据通过元组定义，元组成员与参数名一一对应❸ 在测试函数的参数部分，按 parametrize 定义的字段名，增加对应参数❹ 在测试函数内部，用参数替换静态测试数据利用 parametrize 改造测试用例后，代码会变精简许多。接着，我们试着运行测试代码： $ pytest test_string_utils.py ================= test session starts ================= platform darwin – Python 3.8.1, pytest-6.2.2 rootdir: /python_craftman/ collected 1 item test_string_utils.py …F [100%] ======================= FAILURES ======================= __________ test_string_upper[foo BAR-FOO BAR] __________ s = ‘foo BAR’, expected = ‘FOO BAR’ @pytest.mark.parametrize( 's,expected', [ ('foo', 'FOO'), ('', ''), ('foo BAR', 'FOO BAR'), ], ) def test_string_upper(s, expected): assert string_upper(s) == expected E assert ‘FOO\\x00&quot;!2’ == ‘FOO BAR’ E - FOO BAR E + FOO&quot;!2 test_string_utils.py:25: AssertionError =============== short test summary info ================ FAILED test_string_utils.py::test_string_upper[foo BAR-FOO BAR] ============= 1 failed, 2 passed in 0.13s ============== 12345哐当！测试出错了。可以看到，在处理字符串 &#x27;foo BAR&#x27; 时，string_upper() 并不能给出预期的结果，导致测试失败。接下来我们尝试修复这个问题。在 string_upper() 函数的循环内部，我可以增加一条过滤逻辑：只有当字符是小写字母时，才将它转换成大写。代码如下所示： def string_upper(s: str) -&gt; str: “”“将某个字符串里的所有英文字母由小写转换为大写”“” chars = [] for ch in s: if ch &gt;= ‘a’ and ch &lt;= ‘z’: ① # 32 是小写字母与大写字母在 ASCII 码表中的距离 chars.append(chr(ord(ch) - 32)) else: chars.append(ch) return ‘’.join(chars) 123❶ 新增过滤逻辑，仅处理小写字母再次执行单元测试： ================== test session starts =================== platform darwin – Python 3.8.1, pytest-6.2.2 rootdir: /python_craftman/ collected 3 items test_string_utils.py … [100%] =================== 3 passed in 0.01s ==================== 12345678910111213这次，修改后的 string_upper() 函数完美通过了所有的测试用例。在本节中，我演示了如何使用 @pytest.mark.parametrize 定义参数化测试，避免编写重复的测试代码。下面，我会介绍 pytest 的另一个重要功能：fixture（测试固定件）。 使用 @pytest.fixture 创建 fixture 对象在编写单元测试时，我们常常需要重复用到一些东西。比如，当你测试一个图片操作模块时，可能需要在每个测试用例开始时，重复创建一张临时图片用于测试。这类被许多单元测试依赖、需要重复使用的对象，常被称为 fixture。在 pytest 框架下，你可以非常方便地用 @pytest.fixture 装饰器创建 fixture 对象。举个例子，在为某模块编写测试代码时，我需要不断用到一个长度为 32 的随机 token 字符串。为了简化测试代码，我可以创造一个名为 random_token 的 fixture的 conftest.py import pytest import string import random @pytest.fixture def random_token() -&gt; str: “”“生成随机 token”“” token_l = [] char_pool = string.ascii_lowercase + string.digits for _ in range(32): token_l.append(random.choice(char_pool)) return ‘’.join(token_l) 定义完 fixture 后，假如任何一个测试用例需要用到随机 token，不用执行 import，也不用手动调用 random_token() 函数，只要简单调整测试函数的参数列表，增加 random_token 参数即可： def test_foo(random_token): print(random_token) 之后每次执行 test_foo() 时，pytest 都会自动找到名为 random_token 的 fixutre 对象，然后将 fixture 函数的执行结果注入测试方法中。 假如你在 fixture 函数中使用 yield 关键字，把它变成一个生成器函数，那么就能为 fixture 增加额外的清理逻辑。比如，下面的 db_connection 会在作为 fixture 使用时返回一个数据库连接，并在测试结束需要销毁 fixture 前，关闭这个连接： @pytest.fixture def db_connection(): &quot;&quot;&quot;创建并返回一个数据库连接&quot;&quot;&quot; conn = create_db_conn() ➊ yield conn conn.close() ➋ ❶ yield 前的代码在创建 fixture 前被调用 ❷ yield 后的代码在销毁 fixture 前被调用 除了作为函数参数，被主动注入测试方法中以外，pytest 的 fixture 还有另一种触发方式：自动执行。 通过在调用 @pytest.fixture 时传入 autouse=True 参数，你可以创建一个会自动执行的 fixture。举个例子，下面的 prepare_data 就是一个会自动执行的 fixture： @pytest.fixture(autouse=True) def prepare_data(): # 在测试开始前，创建两个用户 User.objects.create(...) User.objects.create(...) yield # 在测试结束时，销毁所有用户 User.objects.all().delete() 无论测试函数的参数列表里是否添加了 prepare_data，prepare_data fixture 里的数据准备与销毁逻辑，都会在每个测试方法的开始与结束阶段自动执行。这类自动执行的 fixture，非常适合用来做一些测试准备与事后清理工作。 除了 autouse 以外，fixture 还有一个非常重要的概念：作用域（scope）。 在 pyetst 执行测试时，每当测试用例第一次引用某个 fixture，pytest 就会执行 fixture 函数，将结果提供给测试用例使用，同时将其缓存起来。之后，根据 scope 的不同，这个被缓存的 fixture 结果会在不同的时机被销毁。而再次引用 fixture 会重新执行 fixture 函数获得新的结果，如此周而复始。 pytest 里的 fixture 可以使用五种作用域，它们的区别如下。 (1) function（函数）：默认作用域，结果会在每个测试函数结束后销毁。 (2) class（类）：结果会在执行完类里的所有测试方法后销毁。 (3) module（模块）：结果会在执行完整个模块的所有测试后销毁。 (4) package（包）：结果会在执行完整个包的所有测试后销毁。 (5) session（测试会话）：结果会在测试会话（也就是一次完整的 pytest 执行过程）结束后销毁。 举个例子，假如你把上面 random_token fixture 的 scope 改为 session： @pytest.fixture(scope='session') def random_token() -&gt; str: ... 那么，无论你在测试代码里引用了多少次 random_token，在一次完整的 pytest 会话里，所有地方拿到的随机 token 都是同一个值。 因为 random_token 的作用域是 session，所以当 random_token 第一次被测试代码引用，创建出第一个随机值以后，这个值会被后续的所有测试用例复用。只有等到整个测试会话结束，random_token 的结果才会被销毁。 总结一下，fixture 是 pytest 最为核心的功能之一。通过定义 fixture，你可以快速创建出一些可复用的测试固定件，并在每个测试的开始和结束阶段自动执行特定的代码逻辑。 ### Pytest与Allure的结合 在安装allure之前，先确认电脑已经安装了jdk1.8+ 1. 下载allure allure的官网下载地址： https://github.com/allure-framework/allure2/releases 如果上边的地址不可以，就用下边的地址： https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/ 选择一个版本（windows下载.zip包就可以）： 下载完直接解压就好了（记住路径） 打开包，打到bin目录，找到allure.bat双击运行 2. 配置allure系统环境变量 【计算机--属性--高级系统设置--环境变量--系统变量--path--编辑】 环境变量添加刚才解压时allure的地址 放bin文件的路径 3.cmd窗口验证环境变量配置是否成功 检验环境变量配置成功：打开终端命令行，输入：allure 4.安装allure-pytest: pip install allure-pytest 5.运行用例时使用allure生成报告 运行 pytest.main(['--alluredir', 'report/result', 'testdemo.py']) 之后，生成的是json文件 6.查看测试报告 需要在终端运行命令：allure generate ./report/result -o ./report/html --clean 生成html文件 1， 配置文件中， addopts = -s --alluredir=./report/result--reruns 0 2，进入report上级目录，即点击一下你的项目名，在Terminal中执行命令","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"RUST-Test","slug":"RUST-Test","date":"2023-09-16T10:01:17.000Z","updated":"2023-09-16T10:01:17.000Z","comments":true,"path":"posts/4211dcac/","link":"","permalink":"https://t8840.github.io/posts/4211dcac/","excerpt":"","text":"The Test Library 1assert_cmd assert_cmd库 Uses the assert_cmd crate to test the output of a binary called “hello”. The test case verifies that executing the “hello” binary is successful and that the stdout (standard output) matches the expected string “Hello, world!\\n”. 12345678use assert_cmd::Command;#[test]fn work()&#123; let mut cmd = Command::cargo_bin(&quot;hello&quot;).unwrap(); cmd.assert().success(); cmd.assert().success().stdout(&quot;Hello, world!\\n&quot;);&#125;","categories":[],"tags":[]},{"title":"TEST-Burpsuite","slug":"TEST-Burpsuite","date":"2023-09-15T14:25:01.000Z","updated":"2023-09-15T14:25:01.000Z","comments":true,"path":"posts/c180da4e/","link":"","permalink":"https://t8840.github.io/posts/c180da4e/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TEST-Sqlmap","slug":"TEST-Sqlmap","date":"2023-09-15T14:01:40.000Z","updated":"2023-09-15T14:01:40.000Z","comments":true,"path":"posts/bc1e8349/","link":"","permalink":"https://t8840.github.io/posts/bc1e8349/","excerpt":"","text":"Sqlmap Install 1pip3 install sqlmap Usage 1","categories":[],"tags":[]},{"title":"PWD-Wordlist","slug":"PWD-Wordlist","date":"2023-09-15T10:16:49.000Z","updated":"2023-09-15T10:16:49.000Z","comments":true,"path":"posts/9f0d0a7a/","link":"","permalink":"https://t8840.github.io/posts/9f0d0a7a/","excerpt":"","text":"Hydra 12hydra -l root -P pwd.txt 3.91.39.130 mysql","categories":[],"tags":[]},{"title":"PWD","slug":"PWD","date":"2023-09-15T10:16:37.000Z","updated":"2023-09-15T10:16:37.000Z","comments":true,"path":"posts/17b6b9b8/","link":"","permalink":"https://t8840.github.io/posts/17b6b9b8/","excerpt":"","text":"MurmurHash3 Python 中使用的哈希算法是根据对象的类型不同而有所不同。具体来说，对于大多数内置类型（如整数、浮点数、字符串等），Python 使用 MurmurHash3 算法进行哈希。 MurmurHash3 是一种非加密的哈希函数，它具有快速计算和良好的散列性能。它被广泛应用于哈希表、数据结构和其他需要快速哈希操作的场景。 12345678910111213141516import mmh3data = b&quot;Hello, world!&quot; # 要哈希的数据# 计算32位哈希值hash_value_32 = mmh3.hash(data)print(&quot;32位哈希值: &quot;, hash_value_32)# 计算64位哈希值hash_value_64 = mmh3.hash64(data)print(&quot;64位哈希值: &quot;, hash_value_64)# 计算32位哈希值，并指定种子seed = 42hash_value_seed = mmh3.hash(data, seed)print(&quot;32位哈希值（指定种子）: &quot;, hash_value_seed)","categories":[],"tags":[]},{"title":"INFO-WebsiteSubDomain","slug":"INFO-WebsiteSubDomain","date":"2023-09-15T09:59:04.000Z","updated":"2023-09-15T09:59:04.000Z","comments":true,"path":"posts/c32d6646/","link":"","permalink":"https://t8840.github.io/posts/c32d6646/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"INFO-WebsiteFinger","slug":"INFO-WebsiteFinger","date":"2023-09-15T09:27:53.000Z","updated":"2023-09-15T09:27:53.000Z","comments":true,"path":"posts/daccb71/","link":"","permalink":"https://t8840.github.io/posts/daccb71/","excerpt":"","text":"Web-check Github OnlineUse Nmap Install 1yum install nmap Usage 1nmap IP","categories":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/categories/InfoCollect/"}],"tags":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/tags/InfoCollect/"}]},{"title":"INFO-Tool Summary","slug":"INFO-ToolSummary","date":"2023-09-15T07:30:52.000Z","updated":"2023-09-15T07:30:52.000Z","comments":true,"path":"posts/f3f81bd1/","link":"","permalink":"https://t8840.github.io/posts/f3f81bd1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"INFO-WebsiteDir","slug":"INFO-WebsiteDir","date":"2023-09-15T07:30:10.000Z","updated":"2023-09-15T07:30:10.000Z","comments":true,"path":"posts/a36ba747/","link":"","permalink":"https://t8840.github.io/posts/a36ba747/","excerpt":"","text":"Summary Gobuster：URI/DNS/WEB爆破 dirsearch：目录扫描/爆破 dirmap：目录扫描/爆破 jwt_tool：JSON Web Token Toolkit https://github.com/ticarpi/jwt_tool ffuf：高速web fuzz工具 https://github.com/ffuf/ffuf Arjun：HTTP参数扫描器 https://github.com/s0md3v/Arjun URLFinder：JS与URL快速提取检测 https://github.com/pingc0y/URLFinder ksubdomain：子域名爆破 https://github.com/knownsec/ksubdomain c-jwt-cracker：JSON Web Token Cracker Gobuster DownloadLink Usage Dirsearch Usage dirmap Install 1git clone https://github.com/H4ckForJob/dirmap.git &amp;&amp; cd dirmap &amp;&amp; python3 -m pip install -r requirement.txt Usage 1python3 dirmap.py -i https://target.com -lcf Commit The tool can use but the author haven’t update for a long time. And seems the tool is useless.","categories":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/categories/InfoCollect/"}],"tags":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/tags/InfoCollect/"}]},{"title":"XRAY","slug":"TEST-Xray","date":"2023-09-15T07:21:54.000Z","updated":"2023-09-15T07:21:54.000Z","comments":true,"path":"posts/bb10959b/","link":"","permalink":"https://t8840.github.io/posts/bb10959b/","excerpt":"","text":"Intro GitHub Doc Intall ReleaseAdrress Linux Intall 123wget https://github.com/chaitin/xray/releases/download/1.9.11/xray_linux_amd64.zipunzip xray_linux_amd64.zip./xray_linux_amd64 version Problem 1./xray_linux_amd64: error while loading shared libraries: libpcap.so.0.8: cannot open shared object file: No such file or directory Use Steps Basic-crawl 1./xray_linux_amd64 webscan --basic-crawler https://test.com --html-output xray-crawler-testphp.html Service Scan 1./xray_linux_amd64 servicescan --target https://test.com --html-output xray-crawler-testphp.html Xray + Burp","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"TOOL-RemoteAPPWebsite","slug":"TOOL-RemoteAPPWebsite","date":"2023-09-15T02:12:59.000Z","updated":"2023-09-15T02:12:59.000Z","comments":true,"path":"posts/58f8afd2/","link":"","permalink":"https://t8840.github.io/posts/58f8afd2/","excerpt":"","text":"APPETIZE WEBSITE Advantage It offer living demo, even you don’t need register use the demo app. And it offer user free use it most 50 minters","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://t8840.github.io/categories/TOOL/"}],"tags":[{"name":"TOOL TEST","slug":"TOOL-TEST","permalink":"https://t8840.github.io/tags/TOOL-TEST/"}]},{"title":"PYTHON-Encoding","slug":"PYTHON-Encoding","date":"2023-09-15T00:34:52.000Z","updated":"2023-09-15T00:34:52.000Z","comments":true,"path":"posts/6d2ab45f/","link":"","permalink":"https://t8840.github.io/posts/6d2ab45f/","excerpt":"","text":"Transfer Chinese There are many times that the output of python result contains Chinese ,that can’t show. So you need transfer it. 12345#.encode(&#x27;utf-8&#x27;)#.decode(&#x27;utf-8&#x27;)# For Example:print(&#x27;wifi scan result: &#123;&#125;&#x27;.format(i.ssid.encode(&#x27;utf-8&#x27;).decode(&#x27;gbk&#x27;)))","categories":[{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/tags/Python/"}]},{"title":"TOOL-VsCode","slug":"TOOL-VsCode","date":"2023-09-15T00:17:46.000Z","updated":"2023-09-15T00:17:46.000Z","comments":true,"path":"posts/8fe43100/","link":"","permalink":"https://t8840.github.io/posts/8fe43100/","excerpt":"","text":"Plugin AutoCompletePlugin","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://t8840.github.io/categories/TOOL/"}],"tags":[{"name":"TOOL","slug":"TOOL","permalink":"https://t8840.github.io/tags/TOOL/"}]},{"title":"TEST-Httprunner","slug":"TEST-Httprunner","date":"2023-09-15T00:12:34.000Z","updated":"2023-09-15T00:12:34.000Z","comments":true,"path":"posts/7ca05367/","link":"","permalink":"https://t8840.github.io/posts/7ca05367/","excerpt":"","text":"","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"INFO-Wechat","slug":"INFO-Wechat","date":"2023-09-15T00:08:12.000Z","updated":"2023-09-15T00:08:12.000Z","comments":true,"path":"posts/b12ebec1/","link":"","permalink":"https://t8840.github.io/posts/b12ebec1/","excerpt":"","text":"","categories":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/categories/InfoCollect/"}],"tags":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/tags/InfoCollect/"}]},{"title":"INFO-Wifi","slug":"INFO-Wifi","date":"2023-09-15T00:07:48.000Z","updated":"2023-09-15T00:07:48.000Z","comments":true,"path":"posts/5ebeb00b/","link":"","permalink":"https://t8840.github.io/posts/5ebeb00b/","excerpt":"","text":"WIFI Pywifi Use pywifi get around wifi information. Check the code in here:","categories":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/categories/InfoCollect/"}],"tags":[{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/tags/InfoCollect/"}]},{"title":"WEB3-Ton","slug":"WEB3-Ton","date":"2023-09-15T00:07:09.000Z","updated":"2023-09-15T00:07:09.000Z","comments":true,"path":"posts/f961dce1/","link":"","permalink":"https://t8840.github.io/posts/f961dce1/","excerpt":"","text":"http://ton.space Ton Wallet Tur Message 在 TON Blockchain 是怎么运作的？并且概述 Internal Message 以及 External Message 的不同尔尔，并且用 Tact 语言实作给你看！ https://youtu.be/oxmQ04h2uKE","categories":[],"tags":[]},{"title":"INFO-TelegramInfoCollect","slug":"INFO-Telegram","date":"2023-09-15T00:06:45.000Z","updated":"2023-09-15T00:06:45.000Z","comments":true,"path":"posts/86743e4d/","link":"","permalink":"https://t8840.github.io/posts/86743e4d/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RUST-Concurrency","slug":"RUST-Concurrency","date":"2023-09-14T23:59:58.000Z","updated":"2023-09-14T23:59:58.000Z","comments":true,"path":"posts/fd08b82f/","link":"","permalink":"https://t8840.github.io/posts/fd08b82f/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RUST-WEB","slug":"RUST-Web","date":"2023-09-14T23:59:03.000Z","updated":"2023-09-14T23:59:03.000Z","comments":true,"path":"posts/6a322aba/","link":"","permalink":"https://t8840.github.io/posts/6a322aba/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RUST-GUI","slug":"RUST-Gui","date":"2023-09-14T23:58:53.000Z","updated":"2023-09-14T23:58:53.000Z","comments":true,"path":"posts/ab044213/","link":"","permalink":"https://t8840.github.io/posts/ab044213/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RUST-NET","slug":"RUST-Net","date":"2023-09-14T23:58:44.000Z","updated":"2023-09-14T23:58:44.000Z","comments":true,"path":"posts/8d110714/","link":"","permalink":"https://t8840.github.io/posts/8d110714/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RUST-Basic","slug":"RUST-Basic","date":"2023-09-14T23:58:27.000Z","updated":"2023-09-14T23:58:27.000Z","comments":true,"path":"posts/4635b819/","link":"","permalink":"https://t8840.github.io/posts/4635b819/","excerpt":"","text":"Variable Data Type String Vec 1Vec::join Values Option Statement Symbol 12&#123;:?&#125;&#123;:#?&#125; Loop Statement Condition Statement Function Feature #[derive(Debug)] #[derive(Debug)] is an attribute in Rust used to automatically generate code that implements the Debug trait. The Debug trait is a built-in trait in Rust that provides a default way to format and print values for debugging purposes. By adding #[derive(Debug)] to a struct or an enum, the Rust compiler automatically generates the necessary code to implement the Debug trait. This allows us to use println! macro or other debugging tools to print and inspect the contents of the types. #[test] Function .unwrap() The .unwrap() method in Rust is used to extract the value from an Option or Result type. It returns the inner value if it exists or panics if it encounters a None or Err variant. std::env::args() std::env::args() is a function provided by the Rust standard library (std::env module) that returns an iterator over the command-line arguments passed to the program. The args() function returns an iterator of type std::env::Args, which represents the individual command-line arguments as strings. The first element of the iterator (std::env::Args) is always the name of the executable binary itself. Here’s an example of how to use std::env::args(): 12345678910use std::env;fn main() &#123; // Access the command-line arguments let args: Vec&lt;String&gt; = env::args().collect(); // Print the binary name and command-line arguments println!(&quot;Binary: &#123;&#125;&quot;, args[0]); println!(&quot;Arguments: &#123;:?&#125;&quot;, &amp;args[1..]);&#125; The output: 123$ ./my_program arg1 arg2 arg3Binary: ./my_programArguments: [&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;] clap 1234matches.values_of(&quot;text&quot;).unwrap();matches.values_of_lossy(&quot;text&quot;).unwrap();matches.is_present(&quot;omit_newline&quot;); Example: use clap=“3” 1234567891011121314151617181920212223242526272829303132use clap::&#123;App,Arg&#125;;fn main() &#123; let args = App::new(&quot;MyApp&quot;) .version(&quot;1.0&quot;) .author(&quot;jonhn&quot;) .help(&quot;A simple App&quot;) .arg( Arg::with_name(&quot;input&quot;) .short(&#x27;i&#x27;) .long(&quot;input&quot;) .value_name(&quot;FILE&quot;) .help(&quot;Sets the input file&quot;) .takes_value(true), ) .arg( Arg::with_name(&quot;output&quot;) .short(&#x27;o&#x27;) .long(&quot;output&quot;) .value_name(&quot;FILE&quot;) .help(&quot;Sets the output file&quot;) .takes_value(true), ) .get_matches(); println!(&quot;&#123;:#?&#125;&quot;,args); if let Some(input_file) = args.value_of(&quot;input&quot;) &#123; println!(&quot;Input file:&#123;&#125;&quot;,input_file); &#125; if let Some(output_file) = args.value_of(&quot;output&quot;) &#123; println!(&quot;output file:&#123;&#125;&quot;, output_file); &#125;&#125; std::fs std::error::Error","categories":[],"tags":[]},{"title":"RUST","slug":"RUST","date":"2023-09-14T23:58:15.000Z","updated":"2023-09-14T23:58:15.000Z","comments":true,"path":"posts/d7a76f14/","link":"","permalink":"https://t8840.github.io/posts/d7a76f14/","excerpt":"","text":"Install Example Run Demo Use rustc hello.rs 123fn main()&#123; println!(&quot;hello world&quot;)&#125; rustc hello.rs ./hello Use Cargo 123cargo new hellocd hellocargo run Test Demo mkdir tests vim tests/cli.rs 12345678use std::process::Command;#[test]fn work()&#123; let mut cmd = Command::new(&quot;ls&quot;); let res = cmd.output(); assert!(res.is_ok());&#125; cargo test Adding a project dependency","categories":[],"tags":[]},{"title":"LING-Infomation Salo","slug":"LING-InformationSalo","date":"2023-09-14T23:45:10.000Z","updated":"2023-09-14T23:45:10.000Z","comments":true,"path":"posts/78e9cc95/","link":"","permalink":"https://t8840.github.io/posts/78e9cc95/","excerpt":"","text":"We live in an Information Age, where computers have become an integral part of our daily lives. Personally, I work with a computer every day, constantly exploring and seeking out better programming tools like Python and other languages. It’s difficult for me to imagine a life without a computer, as I have realized that I spend a significant amount of time using one. Additionally, news apps have become a crucial source of information for us. However, it’s important to be aware that our reliance on technology and the influence of companies can sometimes impact our thoughts and perceptions. By presenting information in a controlled and easily digestible manner, companies can shape our understanding of the world. It’s essential to maintain critical thinking skills and seek diverse sources of information to ensure a well-rounded perspective. Please note that the impact of technology and media on our lives is a complex and multifaceted topic. It’s important to engage in thoughtful discussions and consider various viewpoints to gain a comprehensive understanding of the subject.","categories":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/categories/Mental/"}],"tags":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/tags/Mental/"}]},{"title":"Solana环境部署","slug":"WEB3-SolanaCommand","date":"2023-09-14T08:51:28.000Z","updated":"2023-09-14T08:51:28.000Z","comments":true,"path":"posts/aad447b0/","link":"","permalink":"https://t8840.github.io/posts/aad447b0/","excerpt":"","text":"安装 Cargo安装 二进制安装 Solana Cli 问题处理 Linux出现不支持AVX2指令的解决办法 [2023-09-14T08:41:31.273811400Z INFO solana_perf] AVX detected [2023-09-14T08:41:31.273825030Z ERROR solana_perf] Incompatible CPU detected: missing AVX2 support. Please build from source on the target Aborted (core dumped) 12- Check Your CPU: First, determine if your CPU has support for AVX2. This can be done using:For Linux: grep avx2 /proc/cpuinfo 123If you get output, your CPU supports AVX2. If you don&#x27;t get any output, it doesn&#x27;t.For macOS: sysctl -a | grep machdep.cpu.features 123456Look for AVX2 in the output.- Building From SourceIf your CPU does not support AVX2, the recommendation, as given by the error message, is to build Solana from source on the target machine. This way, the build process will optimize for the specific features that your CPU supports.Here&#x27;s a basic guide to building Solana from source:Clone the Solana repository: git clone https://github.com/solana-labs/solana.git cd solana 123Build Solana: cargo build --release ``` Once built, the Solana binaries will be available under the target/release directory. Upgrade or Change Your Hardware: If you're running on a cloud provider, consider changing your instance type to one that has AVX2 support. If you're on physical hardware and you require AVX2 support frequently, consider upgrading your CPU to a more recent one that supports AVX2. - Use Docker: If Solana provides a Docker image, you might be able to run Solana in a container. Docker containers can abstract away some of the hardware dependencies, although performance might be impacted. Remember that not having AVX2 support will not prevent Solana from running when built from source; it just means you won't be able to utilize some of the optimizations that the pre-built binaries might have.","categories":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/categories/Web3/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/tags/Web3/"}]},{"title":"Solana Anchor使用","slug":"WEB3-SolanaAnchor","date":"2023-09-14T07:20:58.000Z","updated":"2023-09-14T07:20:58.000Z","comments":true,"path":"posts/db86fce/","link":"","permalink":"https://t8840.github.io/posts/db86fce/","excerpt":"","text":"","categories":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/categories/Web3/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/tags/Web3/"}]},{"title":"Git","slug":"DEV-Git","date":"2023-09-14T07:02:28.000Z","updated":"2023-09-14T07:02:28.000Z","comments":true,"path":"posts/69c3279c/","link":"","permalink":"https://t8840.github.io/posts/69c3279c/","excerpt":"","text":"","categories":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/categories/Devops/"}],"tags":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/tags/Devops/"}]},{"title":"Nodejs环境配置","slug":"JS-NodejsEnv","date":"2023-09-14T06:59:05.000Z","updated":"2023-09-14T06:59:05.000Z","comments":true,"path":"posts/4fe94406/","link":"","permalink":"https://t8840.github.io/posts/4fe94406/","excerpt":"","text":"安装NVM 要安装 nvm（Node Version Manager），可以按照以下步骤进行： Linux安装nvm 打开终端。 在终端中运行以下命令来安装 nvm 的安装脚本： 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash 这将下载并运行 nvm 的安装脚本。 安装完成后，终端会显示一些说明信息。按照说明，在终端中运行以下命令来加载 nvm： 1source ~/.nvm/nvm.sh 或者，你可以重新打开一个新的终端窗口，nvm 将会自动加载。 现在，你可以使用 nvm 来安装和管理 Node.js 版本。例如，要安装最新版本的 Node.js，可以运行以下命令： 1nvm install node 这将安装最新的稳定版本的 Node.js。 验证安装是否成功，可以运行以下命令检查 Node.js 和 npm（Node 包管理器）的版本： 12node --versionnpm --version 这将显示已安装的 Node.js 和 npm 的版本号。 以上是在 Linux 或 macOS 系统上安装 nvm 的步骤。如果你使用的是 Windows 系统，可以尝试使用 nvm 的 Windows 版本（nvm-windows）。你可以在 nvm 的 GitHub 存储库上找到更多关于 nvm 的详细信息和使用说明。 安装yarn 1npm install -g yarn","categories":[{"name":"JS","slug":"JS","permalink":"https://t8840.github.io/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://t8840.github.io/tags/JS/"}]},{"title":"Trade","slug":"Trade","date":"2023-09-13T09:21:56.000Z","updated":"2023-09-13T09:21:56.000Z","comments":true,"path":"posts/bfdb6c62/","link":"","permalink":"https://t8840.github.io/posts/bfdb6c62/","excerpt":"","text":"","categories":[{"name":"Trade","slug":"Trade","permalink":"https://t8840.github.io/categories/Trade/"}],"tags":[{"name":"Trade","slug":"Trade","permalink":"https://t8840.github.io/tags/Trade/"}]},{"title":"开悟","slug":"LING-KaiWu","date":"2023-09-13T09:18:52.000Z","updated":"2023-09-13T09:18:52.000Z","comments":true,"path":"posts/f808b0ac/","link":"","permalink":"https://t8840.github.io/posts/f808b0ac/","excerpt":"","text":"前言 目录 01 人生一世最大的成就是什么？ 02 开悟最简单的第四种途径——当下顿悟 03 我见证了父亲的开悟时刻 04 开悟就是找到第三个“我”在哪里 05 捐出100万还要说谢谢 06 大脑的死穴 07 如何观察一只杯子由你的深度决定 08 大脑如何装下整个宇宙 09 开悟常在绝境处 10 大脑不死心灵不现（上） 11 大脑不死心灵不现（中） 12 大脑不死心灵不现（下） 有没有开悟?如何开悟？开悟之后是个怎样的状况？我们为什么要追求开悟？ 这是每一个修行人士都渴望了解的问题。 据说地球上开悟的人不到百万分之一，也就是说，一百万个人之中只有一个人开悟了，为何如此稀有？ 答案就是：开悟不是因为太难，而是因为太简单，简单到让你无法想象。就好像鱼儿生活在水中，因为朝夕相处，从而忽略了水的存在；就像我们每天呼吸的空气，因为免费提供，从而常常忘记空气的存在一样。 人类可以发明原子弹，登上月球，探索火星，因为人类有地球上最聪明的大脑。 但是开悟与大脑无关，与知识无关，与经验无关。要说困难，这就是唯一最难理解的地方。因此最简单的办法就是放弃所有大脑的努力，一旦如此，属于你的悟境立刻显现。 开悟是存在的，这一点毫无疑问。 我以自己十多年的修行经验和最后的体验成果，并以自己生命的最高荣誉发誓：不要有任何怀疑，开悟是百分之一千存在的，就好像我们每天睡觉的床，走路穿的鞋子一样真真切切，实实在在。 至于如何开悟？ 开悟之后究竟是个怎样的状况？ 本人将在天涯发帖，与广大爱好修行的人，一起分享这其中的无限秘密。 01 人生一世最大的成就是什么？ 莫言在东南亚大学的演讲中曾经提到：人类社会闹闹哄哄，乱七八糟，灯红酒绿，声色犬马，看上去无比的复杂，但认真一想，也不过是贫困者追求富贵，富贵者追求享乐和刺激，基本上就是这么一点事儿。 他还在演讲中提到，无论富人还是穷人一生中都面临四大诱惑：金钱、名利、权势、美色的诱惑。 莫言说的没有错，只是他说的还不够全面，他只说出了一半的真理。 还有一半的真理是什么呢？ 说是真理，只是针对大脑层面的人来说的，其实根本谈不上真正的真理，那么另一半所谓的真理究竟是什么呢？ 另一半的所谓真理就是：有非常稀有的人在满足物质、精神需求之后，苦苦追寻心灵的需求，他们渴望宁静、淡泊、安详、喜乐。（说明：本帖所说的心灵世界就是佛家所说的人所具有的‘佛性‘‘真我’，也就是开悟的状态） 他们在满足了物质层面、精神层面的需求之后，忽然觉得内心深处好像还有个小孩很饥饿，还有个小孩非常闹腾，因为他开始苏醒了，他也需要成长。 很多年前香港著名影星张国荣就是非常典型的案例：据说张国荣在跳楼自杀时，他的个人账户里有大约3亿美金的存款，这样说张国荣根本就不存在物质上的困惑，另外张国荣的事业也是风生水起，演戏、唱歌、电视剧样样火红，论成就、论成功也算是首屈一指，在精神层面，也算成功，那么他为什么还要选择自杀？ 因为张国荣在以上两方面都获得满足后，忽然内心的另外一个小孩苏醒了，那个小孩就是心灵小孩，他感到非常无助，他以前从来没有注意到在心灵深处还有个小孩，他一直以来都忽略了这个小孩的存在，要怎样才能让这个心灵小孩成长呢，要怎么样才能照顾好这个心灵小孩呢？要去哪里才能获得心灵小孩的奶粉呢？ 他太迷惑了，他禁不住心灵小孩的折腾，于是他选择极端的方式结束了自己和心灵小孩的生命。 要获得心灵层面的丰富人生绝对是比物质层面、精神层面的人生的满足还要奢侈一万倍的事情，因为这是完全不同的另外一种游戏，当一个人已经习惯了，已经熟悉了物质和精神层面的所有游戏，突然要去玩一种完全不同的游戏，结果只能是无所适从，结果只能是更加迷茫。 因为心灵层面的游戏不是靠计划、靠执行、靠努力、靠争取、靠奋斗能够获得的，相反，心灵层面的人生实现需要的是：不努力、不争取，需要的是放弃、放下。 心灵层面追求的是平凡，精神层面追求的是非凡，心灵层面追求的是淡定，精神层面追求的是激昂，心灵层面越努力越挫折，精神层面奋斗就可实现，心灵层面需要做减法，精神层面需要则要做加法。 差别实在太大，追求心灵层面的生活。生活在完全开悟的状态下，绝对是非常奢侈的，地球上不会到百万分之一的人有这种福气。 在物质上成功，在精神上成功，目前在中国都已经达到了5%，也就是说100个人中，至少有5个人可以在自己的人人生中通过努力奋斗实现财富和精神上的极大满足，但是只有百万分之一的人才有可能深入到心灵层面。 但是，无论我们物质上多么富有，事业上多么成功（精神层面），挫折感一直都在那里，我们总会重复生活的悲剧，在物质和精神面从来没有圆满的人生，只有充满挫折和困惑的人生。 要如何才能进入圆满的心灵层面呢，我们如何能够一窥开悟状态的美景呢？ 有三条途径： 第一， 通过静心，静心的方式有很多种，如瑜伽、打坐、禅修等，在这种静坐之中，慢慢让大脑里的各种思维安静下来，让自己的肉身彻底放松，然后就有机会打开心灵之门，大脑一直是个干扰，唯有大脑安静下来，心灵之门才可以打开，请问世人有几个可以让大脑安静下来的，据不完全统计，每秒钟我们的大脑就要处理几万个信息，如此多的信息冲击大脑，如此多的念头穿梭大脑，让大脑安静下来绝非易事。 第二， 通过专注，专注一直是一条通往心灵之门的非常好的道路，专注是一种注意力非常集中的努力，但是这样的努力其实一直都没有用，唯有在我们专注到极致时，然后在放下专注的那一瞬间，在放弃专注的所有努力后的那一瞬间，我们就有机会踏入心灵之门，专注的过程一定穷尽一切努力，这极致的努力只为最后那一刻突然地放下，在极致努力和忽然放下的间隙中，有一个机会，那就是大脑彻底绝望的空隙，我们便可以步入心灵之门。 第三， 通过爱，爱一直是直接进入心灵之门的最直接最短的距离。 但是遗憾的是我们在这个物质世界、在这个到处都鼓吹成功人生的励志世界，早已经失去了爱的能力。我们一直都害怕爱，我们一直都逃避爱，我们一直都糟蹋爱。 如果你爱鲜花，鲜花中就有心灵世界一切的美丽，如果你爱音乐，音乐中就有心灵世界一切的灵感，爱就是心灵世界里最好的礼物，一个活在心灵世界的人一定是个慈悲的人，一定是个友爱善良的人。 因此，追求财富容易，追求成功也容易，追求宁静、淡泊绝对不容易，因为宁静也好、淡泊也好压根就不是靠努力追求得来的。 那是一种遇见，因为心灵一直都在你自己的家里，只是因为你一直努力在外面打拼，忽略家里的宝藏而已。 突然有一天，你已经做出了你这一生所能付出的所有努力，你极度疲惫的回到家里，打开门，心灵就在家里满脸堆笑地恭候着您的光临。 02 开悟最简单的第四种途径——当下顿悟 曾经有三到五年的时间，我非常困惑，我几乎读遍了所有的禅宗公案，希望在其中寻找一个答案：什么是开悟？ 看着那些禅宗大师每时每刻停驻在开悟状态，十分羡慕，但是，我不知道，我也无法体验那样美妙无比的状态。 我甚至怀疑那样的状态是不是一种幻境，是不是一种秘而不宣的欺骗，也就是说所谓的开悟根本不存在。 那些看起来无比荒唐的禅宗公案：什么师傅用木棒敲一下徒弟脑袋，什么师傅大喝一声弟子，什么师傅把徒弟手指砍掉，然后弟子一瞬间开悟了。 然后我就想，好神奇啊，这么简单，我特么希望找个师傅把我打一顿，然后奇迹就发生了。 但是遗憾的是，奇迹一直没有在我身上发生。 直到有一天，我遇到一个其貌不扬的年纪不较大老师，是个女的，个子不高，长着一张圆圆的脸，不爱与人多交流。 那一天，我今生今世永远都不能忘记，我看到她在看一本《金刚经》，于是非常有兴趣上前请教：“某老师，您也喜欢《金刚经》呀，我也好喜欢，就是看不懂，《金刚经》里有句话说‘过去心不可得，现在心不可得，未来心不可得’，请问这句话究竟说的是什么？” 只见她头也不抬，也不吭声，突然之间，她迅速站起来，右手猛拍桌子，大吼一声“我凭什么告诉你！” 我猝不及防，被她这种完全出乎意料的反应吓呆了，我想我的魂魄可能在那一瞬间也被吓出体外了，脑袋里好像被掏空一样，干干净净，一无所有，完全丧失了所有的思考和应急反应。 就在我的大脑失去思考能力的时候，我在那一刻遇见了一种自己从未经历过的现象，当时我并不知道那种状态究竟是什么。 那一刻，周围异常的安静，我没有思考，也没有任何念头，虽然没有思考，没有念头浮现在大脑，我也不知道我在那里，根本就没有了我的存在，但是对周围却有一种异常清晰的觉知，也就是“没有觉知者但觉知正在进行，没有观察者但观察在发生”，内心异常的清明透彻，整个人除了丧失了思考能力之外，浑身上下非常敏锐。 我没有任何焦虑，没有任何担心，也没有兴奋，只是感知到异常的宁静，时间观念没有了，我停留在那一瞬间，好像永恒。 我就像一条清澈透底的小溪流，缓缓流淌，小溪映照着蓝天白云和两岸的美景，一切都是那样的和谐，我就是那样的透明清澈，一切都收纳与心中，不做任何评价，只是敏锐的保持一种全方位的觉知状态。 也好像一口波浪不惊的古井，安安静静地立在那里，所有来井边打水的人，我看得一清二楚，但是没有任何念头浮现，只是反射和观察。 我无比的震惊，我知道自己根本还没有准备好迎接这种生命的全新状况，我几乎用了将近一个月的时间才从那次震惊中适应过来。 我现在知道了，那就是完全脱离我们的身体和精神的另一种存在形式，我给这种生命的全新存在形态命名为心灵，也就是人处于开悟的状态。 这就是我经历开悟状态的一次奇遇。 也就是禅宗最喜欢的开悟方式：当下顿悟。 当下顿悟可以说是开悟最直接最快速也最简单的途径，但是在这之前，我们必须经历九九八十一难，经历所有能够经历的一切，思考所有能够思考的疑问，然后就在某个机缘巧合的时机，你就会遇见。 自从那次遭遇后，我忽然之间一下子明白了几乎所有的禅宗公案，那就是一通百通，原来他们都是用他们彼此之间能够理解的方式在交流，局外人根本听不懂。 就好比我们修行的人都是中国人，而人家开悟的人都是说俄罗斯语言一样，完全是两个不同地方的人，彼此说彼此国家的语言，怎么能够相互理解。 唯一的办法就是你必须成为俄罗斯人，然后，所有的一切你都明白了。 因为所有开悟的人在交流时，他们的语言都是来自心灵，而不是大脑，一个生活在大脑世界的人怎么可能理解一个生活在心灵世界的人？ 要想在某一天顿悟，现在你就需要做好充分的准备。 03 我见证了父亲的开悟时刻 我父亲患有老年糖尿病十多年，去年三月份因为糖尿病引起的多种并发症紧急住院，在医院住了大约三个月后，转入高危病房，然后一个星期后，所有的医生和人类现今发明的所有最先进的医药已经无能为力了，医生们终于承认无药可救了。 医生宣布，我父亲熬不过一周，赶快接回家。 由于父亲顽强的求生欲望，回家后用自己坚强的意志力坚持了15天，才离开这个他恋恋不舍的世界。 这15天里，我几乎是24小时寸步不离，我记得很清楚，回到家中的第四天晚上，昏迷中的父亲忽然神奇般地清醒过来，看看时间，是晚上2点半，而且父亲居然还能开口说话：“儿子，你怎么不把外面的人招呼进屋坐。” 我抬头看看窗外，没有人，于是问：“外面是谁呀，爸爸？” “外面是我。” 我在此慎重声明：本人没有任何杜撰、没有任何故弄玄虚，只是真实客观记录当时与父亲最真实的对话，我不是唯物主义，也不是唯心主义，我坚持分享我自己亲眼所见、亲耳所听、亲身体验的东西。 其实在这次对话之前，我早已经确切了解到人类的确是除了身体和精神之外，还有第三样东西的存在，有些人称之为灵魂，人的身体只是一个房子，父亲的身体早已经千疮百孔，他的灵魂离开自己这座危房也是情理之中的事情。 “这么晚了，你在外面干什么？”我没有一丁点的害怕，我迫切希望与父亲的灵魂来一次深层次的对话。 “我打算去旅游。”父亲的语言很清晰，很空灵，不像是从身体里发出来的，而且折磨父亲多日的剧烈疼痛好像已经停止了。 “你一个人去吗？” “还有你奶奶。”奶奶已经于2014年8月1号去世。 传说中一个人要离开人间，阴间有亲人来接，也大概是真的了。这是另外一种讽刺：历史常常是人为杜撰的，而传说恰恰是真的。 “你要去哪里呢？” “去很远很远的地方。” “那你什么时候回来？” “不回来了。”这是父亲的灵魂在与我告别。 “爸爸，你要不要准备点东西才出远门，衣服、零钱之类？” “我不需要了。”对于一个即将离开的灵魂，人世间的一切都是微不足道的。 “但是出远门，还是带点钱吧。” “我不需要了，钱财如粪土，孩子。” 父亲一辈子把钱看得比生命还重要，此时此刻，父亲居然说“钱财如粪土”，这是一种纯粹的了解，这是一种彻头彻尾的解脱。 活着的人有几个看得透“钱财如粪土”，为钱财，兄弟反目成仇者有之，夫妻对簿公堂者有之，正在活着的人远没有即将离开的人活得明白。这又是另外的一种讽刺。 “你不回来了吗？”我继续问。 “不回来了。” “留下妈妈，你放心吗？”我其实还想问：“爸爸，你还有儿女，孙子、外孙，你不留恋吗？” “那已经不关我的事，那是你的事情。” 我是家中的长子，父亲早在衡阳附一ICU病房里，在我去探望他的时候已经交代清楚：在他离开后，母亲的一切——生、养、死、葬，都由我一个人负责，另外我还要帮助姐姐和弟弟，让他们过上更好地生活。 对于父亲这样的安排，我觉得自豪，因为我非常清楚，只有在父亲内心深处觉得他的大儿子有能力承担这一切的时候，他才可能做这样的安排。 中国传统文化中有句话“长子当父”，我在父亲无能无力即将离开这个世界时，深刻领悟了这句话的内涵。 最终，我的所作所为，我想父亲会为我感到骄傲的：我承担了父亲三月份、四月份、五月份以及父亲在ICU病房五天时间里，每天一两万的所有费用。 当然，在我内心深处，我为父亲所花费的任何费用，都是无怨无悔的，因为姐姐和弟弟经济条件相对来说会弱一些，我从来没有任何念头说希望姐姐和弟弟分担一些，我作为家中长子，我乐意去承担，这是为人儿子义不容辞的责任。 听了父亲这些语言，我很清楚地知道，父亲此时与我的谈话，已经不是平常的父亲，父亲此时此刻已经开悟了，虽然短暂，但是在经历与死神搏斗的三个月时间后，居住在父亲身体里的那个心灵苏醒了。 父亲此时此刻的语言，都是在心灵苏醒之后，心灵清晰地关照自己，周围环境发出的语言。 父亲是如此平静，从容，一改往日狂躁的心情，父亲继续说：“你要把你妈妈照顾好，我这一辈子，最对不起的是你妈妈。” 这句话，依照父亲的性格，平时是不可能说出口的，因为父亲属于超级大男子主义，几十年以来，一直都在欺负妈妈，根本就没有妈妈发表任何意见的机会。 第一次， 父亲表现出对妈妈的公正，我知道，这时的父亲正处于开悟状态。 这里需要多说几句，很多人有种误会，以为智慧、宁静、从容、慈悲等品质是开悟的特征，其实不然，开悟本身没有任何特性，这些东西如慈悲、爱、宁静等还是属于大脑层面，只是人一旦开悟后，在开悟的关照下，我们的身体，我们的精神会表现得更好而已。 我反复强调: 开悟就是当下的觉知和关照而已。 开悟就像一面镜子，当我们的身体来到镜子面前，看到脸上脏兮兮，我们自然会去洗脸，当我们的思维来到镜子面前，看到自己的思想狭隘，自然会嘲笑自己一样。 开悟就是那个质检员，时刻检阅我们的身体，我们的精神，从而会让我的身体和精神呈现出更好品质。 我和父亲的对话大约半个小时，之后父亲再次陷入昏迷，直到离开这个世界。 一个即将离开的人就是一个彻底解脱的人，因为他是真的知道，很多东西他再也抓不住了，在他意识到他什么东西都抓不住的时候，一定有某一个时刻来临，那个时刻就是他真正开悟的时刻。 我说过人的一生都会有机会开悟，只是时间早晚的问题，所谓大师，佛陀，只是他们停留在开悟的状态时间比凡人要久一些，无他。 请仔细阅读这段话： 这里需要多说几句，很多人有种误会，以为智慧、宁静、从容、慈悲等品质是开悟的特征，其实不然，开悟本身没有任何特性，这些东西如慈悲、爱、宁静等还是属于大脑层面，只是人一旦开悟后，在开悟的关照下，我们的身体，我们的精神会表现得更好而已。 我反复强调: 开悟就是当下的觉知和关照而已。 开悟就像一面镜子，当我们的身体来到镜子面前，看到脸上脏兮兮，我们自然会去洗脸，当我们的思维来到镜子面前，看到自己的思想狭隘，自然会嘲笑自己一样。 开悟就是那个质检员，时刻检阅我们的身体，我们的精神，从而会让我的身体和精神呈现出更好品质。 这段话是重中之重，也是所有的核心所在。能理解这段话，你离开悟不远了。 04 开悟就是找到第三个“我”在哪里 开悟一直都被无数修行人当做最高的成就，并且将开悟赋予了无数多神奇的特性，仿佛一个人一旦开悟，便能眼观六路耳听八方，便能够上看一千年，下看一千年。 其实不然，开悟其实什么也没有，开悟最终的结果只为寻找那个一直跟随我们的透明人、隐形人而已。 人一直都是由三个“我“组成，身体我，大脑我和心灵我。 身体我很容易找，因为看得见摸得着，这个人长的帅不帅，身材好不好，身体是不是很健康，一看便知，因此绝大多数世人都把时间花在喂养身体我上面，吃喝拉撒成了他们一生最主要的追求。 大脑我也很容易感知，我们学习、我们讨论，我们思考、我们辩论、我们高兴、我们生气，都是很容易被感知的，那个念头在头脑中升起，我们很容易抓住。因此一部分人在满足物质需求后，开始追求精神的升华。 唯独第三个我很难找到。 何也？ 因为第三个我——心灵我是透明的，是隐形的。 佛曰：无我相，无人相，无众生相，无寿者相，即为是也。 佛又曰：一切有为法，如梦幻泡影，如雾亦如电，应作如是观。 此两句，不知难住了多少修行人，苦苦修行，苦苦参悟，最终不得要领。 绕来绕去，始终停留在大脑层次的理解，以为通过大脑的理解，便可以参透其中奥秘，其实这样越努力，越迷失。 因为心灵是没有大脑的状态，企图通过思考、通过比较、通过分析、通过讨论、通过记忆、通过背诵、通过熟读经典，就觉得自己可以找到心灵我，恰恰是努力的方向错了，大脑越努力，最后越纠结，因为大脑如何做到“无我相，无人相，无众生相，无寿者相”，大脑只要一动，就是“有我相，有人相，有众生相，有寿者相”，这样不就是走进了死胡同吗，心灵要的是“无”，但是大脑一运作就是“有”，如何破解这个难题，根本无解。 放弃一切大脑的努力，立即杀死大脑，心灵马上就呈现出来。 问题是如何杀死大脑呢？ 如何达到没有大脑的状态呢？ 禅宗大师们最喜欢的两种游戏就是： 第一，制造混乱，制造不合逻辑的情景。因为大脑能够理解符合逻辑的事情，不符合逻辑的事情，大脑就会短路，大脑就会死机，在大脑短路和时机的那一瞬间，大脑就暂时休眠了，心灵就有机会出现。 禅宗大师喜欢玩的第二种游戏就是当头喝棒，在弟子们完全没有预兆的情况下，突然之间做出荒唐的举动，大脑来不及反应，猝不及防，此时大脑也会死机。与第一种游戏效果一样。 我们不妨看一则禅宗公案： 马祖禅师到怀让禅师那儿学道，每天都坐禅，而且很用功。 有一次怀让禅师问马祖：“你坐禅是为了什么？” 马祖说：“为了成佛呀！” 怀让就拿了一块砖磨了起来，马祖觉得很奇怪，问他磨砖做什么？ 怀让说：“把它磨成镜子。” 马祖很是疑惑，说：“磨砖怎能磨成镜子呢？” 怀让答：“磨砖既不成镜，坐禅又怎么成得了佛呢？” 你看，这就是师傅在制造一个荒唐的情景，让徒弟看到完全不合逻辑的地方，从而让徒弟有机会放弃大脑，哪怕只有一秒钟。 成佛也好，开悟也好，不在于坐。在于能否放弃大脑，没有执着、没有挂碍，不在于坐的姿势好不好、坐得久不久、腿痛不痛，这是毫不相关的。 如果像马祖那样不断地打坐，马祖可能成不了马祖，也开不了悟。一旦他明白砖头磨不成镜子，打坐也成不了佛，对打坐的执着就放下了。 第三个我很难直接描绘，但不是不能描绘，打比方、象征、类比、讲故事等都是非常好的方法。 一旦找到第三个我，其实会让人很失望，如果之前怀有很高的期待，一定会失望。 第三个我是透明的，无色无味、无形无影，没有任何特异功能。 第三个我只是当下的“不观照的观照，不观察的观察”，因为第三个我的苏醒，就像一个严格的质检员，认真观照每一句说出口的话，每一个闪过头脑的念头，从而赋予了我们说出去的话和头脑中出现的思维不同的品质而已。 也就是第三个我的苏醒，在客观上能够让第一个我——物质我，第二个我——精神我表现得更好，而这里的难点在于：第三个我并不提出任何改正的建议，他只是一束光，三百六十度照亮思维的误区和思维的狭隘，从而让思维自己去做调整而已。 第三个我只是一面一尘不染的镜子而已，他很安静，只是当下反应和观照，无他。 05 捐出100万还要说谢谢 下面是一个非常有趣的故事，但你不一定懂： 有一个得道的大师，因为远近闻名，前来听他布道的信徒络绎不绝，很快，大师的道场就显得非常拥挤，于是，大师计划建造一个大一点的道场。 大师根本没有钱，因为大师并没有把时间和精力放在赚钱上，他的布道是免费的，他生活在智慧里面。 有一个非常富有商人，知道这件事，于是决定捐赠100万来帮助大师建成新房子。富商手里提着100万现金准备交给大师。 大师说：“好的，你放下。” 富商把钱给了大师，但是他非常不满意大师的态度，因为他是给了一笔很大数目的钱，整整100万，现在一个人全年的生活费都只需要一万元，而大师甚至都没有谢谢他。 “那个袋子里有100万。”富商提醒道。 “在此之前你已经告诉过我了。”大师说。 “就算我是一个富有的商人，100万也算一笔不小的钱。”富商继续说。 “你是不是想要我为此谢谢你？”大师说。 “出于礼貌，你应该谢谢。”富商说。 “为什么我应该感谢你呢？”大师说，“相反，你应该谢谢我。” 富商很生气，觉得大师太怪异，简直不可理喻，同时他觉得自己是个冤大头，自己很傻很天真。 这是什么逻辑？ 捐钱的要感谢接受捐赠的，这简直太荒谬了。 大多数人看不懂这个故事，这就对了，生活在大脑层面的人永远无法懂得这个故事深意，因为大脑是狡猾的、是精于算计的，大脑能理解符合逻辑的事情，但是如果某件事不符合逻辑，大脑立刻像白痴一样，立刻短路，因为从任何一个角度来说，都不可能让一个捐出 100 万的富商去感谢一个接受捐赠的人，这完全不符合逻辑。 当代社会是一个充满交易、算计、掠夺的糟糕时代。我们的大脑已经被训练得无比聪明，我们做任何一件事都会在大脑中进行精心算计，算算做某件事的性价比。 慈善活动变成了秀场和生意场；爱心基金变成了偷税漏税的遮羞布；美色权力变成了交易的廉价筹码；还有哪件事不是一场交易呢？ 在这个处处都充满交易的时代，几乎所有的关系都变了味，什么干爹、什么干妈，什么兄弟、什么同乡，统统围绕着利益在转动。 这一切都是大脑的诡计，故事中的富商一直在算计，100万的投入可以为自己赢得多少美誉，可以为自己树立一个多么崇高的形象，但是大师甚至连一声谢谢都没有，这太无理了，这对富商来说，对一个精明的大脑来说简直不可理喻。 但是大师是完全脱离大脑的，他生活在心灵世界中，他没有算计，他没有期待，在他的世界里没有交易，他所有的布道全是免费的，他只有一颗救世度人的慈悲心，他希望建一个更大的道场，他纯粹是希望有更多的人得到感召，得到救赎，他不需要任何回报，他每时每刻都在感谢那些远道而来的客人，他感谢他们对自己的信任，他感谢他们对真理的追求和对真理的敬重。 大师生活在一个洋溢的世界中，他的心灵是如此清澈，因而他的智慧是如此丰富，他需要不停地分享和给与，他不得不去分享，他不得不去给与，分享得越多，给与的越多，他的心灵就愈加清澈透明。 他就好像一座深不见底古井，如果没有人源源不断地把井水打走，全新的井水就无法涌进来，当有越来越多人到他这口古井打水，他的井水就会更加清凉，干净。他将换发更加强大的活力，他将每时每刻都生活在鲜活中，因此大师需要感谢那些前来不断取水的人。 大师在不断给予，但是无时不刻都心怀感激，感谢那些前来接受洗礼的人，感谢那些信任自己并一直陪伴他的人。因为他们的存在，他的生命才如此洋溢、他的生命才如此鲜活。 大师一直都在感谢那些前来接受布道的人。 因此大师说：“你应该谢谢我。” 显然，富商不明白大师的意思，一个大脑世界的人和一个心灵世界人站在一起，根本无法对话，因为大脑和心灵完全是一个不同的世界。 大脑是索取的，心灵则观照出奉献的一面； 大脑是算计的，心灵则观照出分享的一面； 大脑是精明的，心灵则观照出天真的一面； 大脑是复杂的，心灵则观照出简单的一面； 大脑是浑浊的，心灵是清澈的… 当大师说：“你应该谢谢我。”大师是站在自己的角度，是站在心灵层次的角度说这句话的，因此他不需要对富商说谢谢，相反富商需要对大师说一声谢谢。 因为大师的缘故，他的100万建成了一个更大的道场，将有更多的人收益，大师完成富商功德的传递，在这件事上，大师只是一个媒介，大师只是一个桥梁，富商通过大师完成了自己无上功德的奉献。 而且因为大师的接受，这样就完成了富商生命的真正流动，富商不再是一个守财奴，他的生命也开始流动了，而流动恰恰是生命的真正意义所在。 因此给予者应该感谢，感谢那些接受馈赠的人。 有一次，夫人在整理衣服时，发现很多旧衣服，无论质量、款式、做工等都不错，但是衣柜已经无法装下那么多，男人们要清楚，女人的衣柜总是嫌小，夫人的衣服已经塞满了整个衣柜，需要清理，但是这么多还算不错的旧衣服如何处理呢？ 夫人一直纠结这个事，送给别人吧，觉得很难为情，毕竟是自己穿过的衣服；但是扔掉吧，心里又觉得十分可惜，女人就是这样的动物，衣柜里永远都缺一件衣服，但是旧衣服又从来都舍不得扔掉。 送给别人，担心伤害别人，于是很纠结。 不久，老家来了两个亲戚，闲聊中间，夫人拿出她的收藏，她小心翼翼地试探，拿出几件衣服给她们试穿，结果她们很喜欢，夫人就顺势送给了她们，她们很高兴，夫人更是高兴，高兴她们能够喜欢，高兴她们能够接受，夫人心中充满了感激。 感激她们没有嫌弃，感激她们能够快乐接受，感谢她们完成了一次生命的传递和流动。 因此馈赠者应该感谢，接受者才是真正的天使。 但是一旦某项馈赠包含了某种期待、同时在给予时一直在期望回报时，这样的给予将一文不值。这样的给予就是一种侮辱，是一种亵渎，是可不原谅的。 给予就必须是无私的，无所求的，必须是心怀感激的，否则就收起我们那一颗虚伪的面孔，做回一个拥有精明头脑的人。 大多数人看不懂这个故事，这就对了，生活在大脑层面的人永远无法懂得这个故事深意，因为大脑是狡猾的、是精于算计的，大脑能理解符合逻辑的事情，但是如果某件事不符合逻辑，大脑立刻像白痴一样，立刻短路，因为从任何一个角度来说，都不可能让一个捐出100万的富商去感谢一个接受捐赠的人，这完全不符合逻辑。 06 大脑的死穴 大约在我28岁到30岁那几年，对于禅文化特别着迷，遗憾的是，自己根本看不懂，于是乎较上劲了，我根本不相信会有我看不懂得书籍，这一本看不懂就换一本，这位大师写的看不懂就换另一个大师写的，前前后后总共阅读了大约300本左右关于禅文化的书籍。 结果是越看越糊涂，越看越不明白。 随便举一个禅宗公案： 司马头陀在大伪山找到了一块风水宝地，他想找个有道行的人来开辟道场。于是来到百丈禅师处选拔人才。待大众聚齐，司马头陀手举净瓶说：“这不是净瓶，谁能说出这是什么？” 在场大众茫然不知所答。 这时，从后面挤上来一个脏兮兮的杂务僧说：“我可以试试吗？” “可以啊”！司马头陀说。 杂务僧接过净瓶，放地上，猛地飞起一脚，将净瓶踢出墙外。 司马头陀大笑说：“这才是大伪山真正的主人啊！” 请大家说说：司马头陀和杂务僧的奇怪动作，在向对方传递什么信息？其中又暗藏了什么玄机呢？ 如果你看到这个公案，看到上面的提问，于是在大脑里一直思索，寻找答案，那么你就上当了，在大脑层面，你将永远找不到答案。 正如我当年陷入困境一样，对于大师级别的对话或者大师之间发出的奇怪行为，总是企图在大脑层面寻找答案，无异于缘木求鱼，越努力越挫折，因为答案不在脑袋里。 谜底就是：答案在心灵层面，如果无法跳跃到心灵层面，上面的公案，你一辈子都不可能明白。 对于大脑来说，可以学会逻辑分析、技巧方法等，这些都没有问题，但是对于不合符合逻辑的语言和行为，大脑就会疯掉。 而心灵恰恰相反，心灵是没有逻辑的，心灵是一种跳跃，是一种领悟，一种非逻辑。 公案一开始，司马头陀就提出了一个不符合逻辑的问题：“这不是净瓶，这是什么？” 一个不符合逻辑的问题，大脑如何分析，如何能够给出答案，但是司马头陀是一个得道的大师，这一点没有疑问，他是从心灵层面、从本质出发而提出这个问题。 是一个师傅，但是他需要借由这个非逻辑问题来甄别，面前几百号门徒，究竟哪一个已经完成了跳跃。 绝大多数保持沉默，说明绝大多数还停留在大脑层面，那个飞跃、那个质变还没有发生。他们依然执着于寻找一个合理的答案，他们依然停留在大脑层面，他们依然没有深度，他们还没有锐变。 一个脏兮兮的杂务僧从后台走出来，在修行的道路上似乎总是这样，越平凡的人实现跳跃越容易。一个毫不起眼的杂务僧他的内在已经突破了，那个质变已经在他的内在发生了，他知道司马头陀的问题是荒谬的、甚至是愚蠢的，根本是没有答案的，既然没有答案，又何必浪费口舌。 于是，他一脚就踢飞了那个净瓶。直接粉碎了大脑的所有执着，当绝大多数门徒在那一霎那间，肯定有一个片刻，这个片刻大脑是不能思考的片刻，如果对于某些已经准备好的门徒来说，这个片刻是千金难买的，只要这个片刻，大脑短路的短暂片刻，那些已经准备好的门徒完全可以借由这个片刻对心灵世界，对自己的核心本质有一个电光火石般的瞥见。 对于司马头陀和杂务僧来说，完全没有问题，他们实现了心灵层面的交流，他们彼此都懂对方。 大师之间的交流都是这样，看似荒唐，实则彼此心心相映。 心灵层面发出的问题，必须由非逻辑方式解决。一个不遵循逻辑出牌的师傅他需要看到一个同样不按逻辑出牌的高徒。 那个问题就是一个阴谋，一个试探，如果你按逻辑出牌，那就证明你还没有锐变，你还在大脑层面思索答案，你就不是他要寻找的人。 心灵层面发出的问题，必须由非逻辑方式解决。一个不遵循逻辑出牌的师傅他需要看到一个同样不按逻辑出牌的高徒。 07 如何观察一只杯子由你的深度决定 某天下午，与几位老友喝茶，面前放着一只青花器茶杯，所谓老友就是小区里上了年纪的几个老大哥，他们退休后闲暇时间最爱到我办公室喝上几杯，而且每次来都喜欢带上几本国学或者佛学方面的经典，与我一起探讨。 无论他们带多少本国学巨著抑或带上多么经典的佛学经书，也不管他们有多大年纪，在我看来，他们还基本上不入门。因为一个有悟性的人，一个受到国学、佛学浸染的人，一举一动、一言一行都会表现出与众不同的端倪，一个真正有深度的人是根本藏不住的。这与他们的年龄和手中的书毫无关系。 况且佛学经典根本不是用来读的，读佛经完全是扯蛋，所有的佛学经典是一种体验科学，需要体验、感悟和升华，是需要用“悟”去感受的。越是依赖大脑，离佛经越远，佛学不是来自大脑，而是来自心灵层面，用大脑去读心灵层面的智慧，这本身就是一个笑话。 歌后王菲经常换老公，世人各有评说，但是其中有一个人，评价最为深刻，就是的陈道明，他说过一句话：“王菲过去所经历的每一个男人，最多停留在精神层面，没有一个达到心灵层面，但是王菲已经是一个处于心灵层面的人，于是内在的渴望迫使她去不停寻找那个可以和他匹配的男人。” 不用说陈道明绝对是一个有深度的男人，因为只有一个老子一样的人物才可以读懂老子。 两位老大哥开始向我推荐国学经典和佛学，并不停背诵其中经典的句子，我礼貌地点点头，我看到了某种可爱，同时也看到了某种虚荣，为了让他们安静下来，我开玩笑问：“两位老哥，仔细看看你们面前的茶杯，你们看到了什么？” 一个说：“茶杯不错，花纹很别致，做工精细，属于上等茶杯。” 另一个说：“这个茶杯颜色饱满，用材考究，用来泡茶，味道纯正。” 还有吗？我继续问，虽然两位大哥继续补充了一些，但基本上停留在上面层次。 一个茶杯，不同深度的人来观察，观察到的结果会相差非常遥远。 首先说花纹，上等茶杯的花纹必定是经过大师级的人经过精心描绘而成，大师出品必是精品，大师在描绘花纹的过程，不仅注意力高度集中，而且会充分投入了他的情感和灵魂，一个大师绝不会允许自己手下的作品粗制滥造，好比一个优秀的歌唱家，唱歌不仅不能跑调，最为关键的是歌声中必定饱含情感和人生的领悟，听者才会心有戚戚。 一个饱含了大师心血和情感的花纹，虽然静静地刻在杯子上，没有一颗敏锐的心是无论如何也感受不到的。 再说烧制杯子的经过，一只小小的茶杯，如果是纯手工制作，必是经过能工巧匠的精心打磨，反复烧制而成，大家都知道，茶杯的烧制过程不可能一次成型，需要反复烧制，在烧制的过程中，每时每刻都需要小心翼翼，犹如看护一个襁褓中婴儿，不得有些许的大意，从这个方面说，一个茶杯又融入了更多能人的精魂。 最后说说制作这杯子的材料。 一个好的茶杯，选材非常考究，需从天地间去精挑细选，然后反复搅拌、揉搓，谁也不知道这块从天地间攫取的材料，已经存在了多少年，或许与地球同岁，这样，这块材料毫无疑问必定承载了日月星辰的灵气，人类历史的兴衰更替。 这就是真理，当真理说出口的那一刹那，几乎所有的人都会立即感觉到。 因此，我说面前的茶杯是一个有生命的精灵。 两位老大哥终于安静下来。 地球上的人是分层次的，从来没有往深处探索的人，不可能有深度，有的人活一辈子活的非常表浅，就像看一只杯子，怎么看都只能看到外在的表象。 活在物质层面的人最可怜，一生劳碌； 活在精神层面的人最折腾，一生困惑； 唯有升华到心灵层面的人，才可以找到生命的真谛：安详、宁静，淡定、满足、喜乐。 08 大脑如何装下整个宇宙 有一个大学教授去请教一位高僧：“什么是道？” 高僧没有直接作答，只是将教授带到屋后的百花园中，当教授再次问：“请问高僧，道是什么？”时，高僧立即打断教授的问话：“别说话，请享受这里的百花香，你闻到花香了吗？” 教授深深呼吸一口气，然后说：“好香。” 高僧：“这就是道，关于道，我没有更多可说的了。” 那个教授呆在那里，比以前更加困惑了。 事情就是这样，一个教授带着满脑袋的知识去请教高僧，他企图获得某些概念上、知识上的认知，但是这与道完全就是风马牛不相及的事情，知识越多的人，离道越远，头脑越聪明的人，知识越渊博的人离道越远。 教授是一个完全活在大脑层面的人，而高僧则是生活在另一个世界中：心灵世界。 两个不同世界的人其实很难对话，“道”是没有头脑的一种状况，道是一种体验、一种实证，没有时间、没有空间概念的存在感。是一种一个片刻接着一个片刻的存在的状态。大脑如何去理解，大脑无法理解这种状态，大脑需要一个概念，需要一个定义、需要一个记忆，离开概念，离开记忆，大脑就会发疯。 道和大脑生来就是势不两立的冤家。 道不可言说，只可以启发，只可以意味，但是究竟什么样的人可以被启发呢？什么样的人才能被点亮呢？ 那些完全抛弃大脑的人才可以被启发，才可以被点亮。 问题的难点在于：我们从来没有尝试过，过一种完全没有思考活动的生活，头脑中没有任何念头，没有任何努力的状态。我们已经习惯于依赖大脑，没有大脑，我们甚至不知道下一步该干嘛？ 我们不知道往哪里走，因为我们已经习惯做大脑的奴隶，我们采取的每一个行动，说的每一句话，都要经过大脑的处理。 否则，我们要去哪里，我们该怎样表达？ 完全放弃大脑几乎不可想象。 然而，道也好，存在也好，真我也好，心灵也好，恰恰是没有大脑的状态，这样一件极简单的事情，因为大脑的干扰变得极为复杂和困难，好像没有谁可以完全脱离大脑而存在。 我们照样来看一个很美的故事： 有一天，亚里斯多德正在海边散步，他看到一个人拿着一支汤匙在舀海水，舀到他在海堤边挖好的一个洞。 亚里斯多德因为有自己的问题要操心，他一边思考，一边延着海边散步，他一步一步走向那个怪人。 那个奇怪的人一直都非常聚精会神，这让亚里斯多德产生了很大的好奇心：“他在做什么啊？” 他无法克制住自己的好奇心，但是那个怪人依然那么聚精会神，完全没有注意到他的到来。 怪人又他走到海边去，舀满一汤匙的海水，再带着海水到堤防边，把它灌入洞中，然后再走到海边去……，如此不知疲倦地往返。 最后，亚里斯多德不得不说：“等一下！这位老先生，我并不想打扰你，但是您在做什么啊？您这样做真的让我感到非常迷惑。” 那个怪人说：“你没看见吗，我正打算用整个大海中的水来填满那个海堤坝边上的洞。” 学富五车、才高八斗的亚里斯多德实在忍不住，终于笑了出来，他说：“你真是个笨蛋，这怎么可能呢？你没看见整个海洋有多么的广大，而你那个洞是多么渺小，你居然想得出来，你要用一支汤匙把整个海洋舀到这个洞？你简直疯了，你这样只是在浪费生命！你是个疯子，赶快回家休息去吧！” 令亚里士多德发狂的事情发生了，那个怪人，笑得比亚里斯多德还要大声，还说：“你说得没错，我要回家了，因为我的工作已经完成了。” 亚里斯多德说：“你这话是什么意思？，你已经完成了你的工作？” 怪人说：”尊敬的大哲学家，你可知道，你一直在做和我一样愚蠢的事情，甚至比我还愚蠢。你现在就看看你的头，看看你的大脑，他是不是它比我的那个洞还小很多呢。我愚蠢到要将整个大海都装到我的那个小洞里，而你，聪明的大哲学家，你看看整个宇宙，整个存在，它是不是比海洋还要辽阔，而你，居然企图将他们装到你的大脑中。” 那个怪人放肆大笑，而且越笑越大声，而那个哲学家，那个亚里斯多德却早已经傻在那里，完全忘记了自己刚才大脑还在不停思索的问题。 在一个真人面前，博学的哲学家一直都是个笑话，大脑如何装得下整个宇宙？ 因为这个问题在哲学家看来简直就是无稽之谈，荒谬透顶，根本就是浪费时间考虑这个问题。 哲学家一直都某个狭隘领域里的偏执狂，但是他们却又特别喜欢装得什么都懂，这样就很麻烦。 大脑如何装下整个宇宙，在哲学范围内，哲学家会被这个问题折磨到死，然而换一个角度，答案如此简单。 好比曾经有一个云游和尚，面对大家夸下海口，他说：“三天之内，我有能力让村前的那座大山走到我的面前来。“ 三天之后，奇迹没有出现，而这个云游和尚直接走到大山面前，大声说“既然山不过来，那我就过去，这样大山还不是一样在我眼前吗？” 心灵是灵活的，大脑是僵硬的，心灵的选择是无限的，大脑的选择非常局限，大脑的选择永远超不出大脑的储存。 大脑如何装下整个宇宙，我们需要换一种模式，换一种看问题的角度。 就好像另一个问题：我们到达月球最快的方式是什么？ 答案是：闭上眼睛，意念一动立刻到达，比光速还快。 闭上眼睛，大脑一瞬间就可以装下整个宇宙了。 09 开悟常在绝境处 一万个人就有一万条通往开悟的道路，开悟好比一个圆的中心，从四面八方任何一个点开始，只要朝圆点开始前进，都可以到达这个圆点。 能够最终到达圆点的人无疑都是他所在领域里最顶尖的高手。 卖油翁可以成为开悟者，当他离地三尺，将油准确无误地滴入地面一个瓶口很少的瓶子里，而且一滴不漏，那一刻，他就是一个开悟者； 伯昏无人站在悬崖边，而且半只脚悬在半空，准确无误地射中百米开外的铜钱时，那一刻，他就是一个开悟者； 开悟对任何人都是开放的，他就在那里，只要你迈开腿向他出发，你就可以到达。从出发点到达圆点的每一步都是修行。 我们看一个故事： 曾经有一个医术非常高明的医生，常常手到病除，但是尽管如此，还是有不少病人因为病入膏肓，无力回天，因此这位医生每天在面对病人时，内心都有都惧怕死亡的阴影。 有一次，这位医生又出去出诊，路上，他碰到一位云游僧，医生于是就请示道：“请教大师，什么叫开悟？” 云游僧回答道：“施主，实在抱歉，我目前的修行还不能告诉你什么是开悟，但有一点可以确信的是，一旦你开悟之后，你就不用担心什么了，如果你真心想得到答案，你就去找一个师傅，他会给你答案。” 于是在云游僧的指示下，医生前往参访南隐禅师。 医师找到南隐禅师后，开门见山说明来意，并请求开示。 南隐禅师道：“开悟很简单，你既然身为一个医师，就应该好好对待你的病人，那就是你的开悟！” 医师似懂非懂。 他前后拜访了南隐禅师三次，南隐禅师总是对他说道：”一位医生不该把时间每天消磨在寺院里，快回家照顾你的病患去，治病救人就是你的最终开悟。” 医师非常不解，他很困惑，心想：这种开示，怎能袪除怕死的心呢？因此，当他第四次参访时，就抱怨道：“有位云游僧告诉过我，人一旦开悟之后就不会有任何担心。而每次这里，你总是要我照顾我的病患者。难道这就是所谓的开悟？” “你四年来，自己觉得有什么变化吗？。”南隐禅师说。 “我还是很担心我眼前的病人，虽然每次我都会尽力去救治，但是那个担心总是没有办法消除。“医生说。 这时一条狗恰好从南隐禅师的禅房前走过。 禅师于是问：“你觉得一条狗会担心吗？” 医生顿住，觉得有些被侮辱，但是他还是很理性地回答：“没有，师傅。” 禅师继续逼问：“很好，以后你可以不再过来了，狗就是你最好的老师。” 医生很是困惑，但是禅师已经闭上眼睛，不再说话。 这位医生继续行医，兢兢业业，但是从没忘记向狗学习如何不担心，直到临终，他终于悟透禅师的话机。 为何狗不担心呢？很简单，因为狗终其一生都活在无知无识中，自然不担心。 人又如何能够活在无知无识之中，从而没有任何担心呢？ 又如何理解南隐禅师一方面告诉医生，去救助你的病人吧，你可以得安心。一方面有告诫医生去向狗学习吧，你可以得安心。 救助病人是不可能无知无识的，这前后如此矛盾，难怪医生需要一生去参悟。 领悟这一点，需要一个跳跃，一个包容，而不是用一种非此即彼的思维，谁说矛盾不可以共存？谁说魔鬼天使不可以共处？ 一个包容，让两者共同存在，让无知无识与有知有识同时存在，做到这一点，你就可以看到开悟其实就在眼前。 我曾说过，任何领域里最顶尖的高手都是开悟者。 看云飞第一次在星光大道唱《父亲的草原母亲的河》，如此动情，如此感人，唱哭了台下多少评委，感动了电视机前多少观众。 那一刻，云飞就是一个开悟者，云飞不在了，空气中只有他的歌，云飞和这首歌合二为一；这就是无知无识；同时云飞不可能不在，他在那一刻，只不过是将他的人生、他的情感、他的思想、他的感受完全融入到歌声中而已，这就是有知有识。 毫不夸张地说，任何行业里最出色的作品都是在这种状态下创作出来。 我经常说一句话：一个真正美的女人是不知道自己很美的，一个真正很帅的男人也是不知道自己很帅的。 这非常有趣，需要很好地领悟。 本文中的这位高明的医生直到临终才领悟禅师的开市，因为只有他来到了那个点，也就是本文开头所说的那个圆点，他才可以明白。 当他在全心全意地去善待他的病人时，全心全意意味着完全地付出、意味着废寝忘食；而同时自己又完全忘记自己的所作所为，他并没有那个自己善待病人的观念在，即从有心到无心，从有我到无我，从有生到无生，他便脱离了生死挂碍了，他也完成了自己一生的修行。 10 大脑不死心灵不现（上） 精神病，一个多么可怕的名词，然而这却是几个世纪以来人类最无知的定义，这个世界其实没有精神病，被我们定义为所谓的精神病患者只不过是他们的思维和情绪被困在某一个狭窄的空间里暂时走不出来而已，他们只是一时的执念，他们只是一群暂时被困在大脑世界里某个狭窄角落里的人。 具有讽刺意味的是目前绝大多数心理医生也是生活在大脑层面的人，他们自己也是一个不折不扣的精神病患者，只不过他们生活的大脑空间稍微宽敞一些。 从这个意义上讲，我们每一个生活在大脑层面的人，都是某种程度的精神病，区别只在那个空间的大小。 打个比方就是：被我们称为精神病患者的，他们居住的可能是地下室只有3个平米大小的笼房，精神病医生可能居住的是三房一厅，普通大众居住的大约就是两房一厅。所有的区别就是那个空间的大小，但是层次却是一样，大家都在精神层面，大脑层面，当我们嘲笑那些所谓的精神病患者时，殊不知，我们只是五十步笑一百步而已。 本文就探讨什么是大脑世界，什么是心灵世界，我将亲自带你去心灵世界走一遭，因为我去过那个地方。 大脑世界是一种知道、一种累积，一种记忆；大脑世界里一切东西都是陈旧的、过去的，大脑是一个知识仓库，是一个人生经验的百货超市。 而心灵世界是一种信任，一种流动、一种洞察，心灵世界没有过去、没有未来，只有当下，当下一切都是鲜活的、活泼的、灵动的。 心灵世界与大脑世界是两个完全不同的世界。 大脑最擅长的就是分析、总结、归纳，然后企图去理解，大脑最擅长逻辑和思考。 而心灵是一种当下的反应、一个观照、是一束光，大脑世界的一切活动都在心灵之光的照耀下遍体通透。 心灵不遵循任何逻辑，也没有逻辑，心灵与大脑是完全相反的两个世界。 大脑世界是混乱的，纠结的，是相互矛盾的，大脑不可能不纠结，因为这个世界上从来没有两颗相同的大脑，不同的大脑有不同的知识，不同的经验、不同的文化、不同的传统、不同习俗。地球上遍地都是不同的大脑、到处都是固执的大脑。 所以大脑之间的斗争从来就没有停止过。 而心灵世界是清澈的、单纯的、流动的，心灵从不记忆，因为心灵不需要记忆，心灵是当下的反应，是一面一尘不染的镜子，是清澈透明的湖水，心灵从来不累积任何东西，心灵是一种即刻反应，是一种物来则应，事过不留的当下观照，心灵只是反应，即刻反应，心灵世界就是一个片刻接一个片刻，完全活在当下，他不属于过去，也不属于未来，它只属于当下。所以心灵世界是轻松的，因为没有任何负担，没有任何垃圾。 这对于那些从来没有这种体验的人来说，从来没有跨进心灵大门的人来说，这种状态实在是太陌生了，几乎很难理解，甚至无法理解。 但心灵的确就在那里，不管你了解还是不了解，他就在那里，它只属于那些跳进他怀抱的人。 心灵世界属于人类进化过程中相对高级的世界，对于绝大多数人来，他们根本就不知道还有心灵世界的存在，这样对绝大多数众生来说，就有很大的困难，如果你压根就不知道有心灵世界的存在，那你如何探索你的心灵，你又如何成长你的心灵？ 因为不了解某样东西，甚至压根就不知道某样东西的存在，你如何去开发他？又如何去发展他，这很困难。 企图用大脑去分析心灵，去理解心灵那是徒劳的，根本不可能，大脑不可能理解心灵，两个不同世界人如何沟通，而且这里的关键恰恰是：大脑必须停止一切思考、停止一切分析，停止一切企图理解的努力，大脑必须彻底安静，彻底死掉后，心灵世界才会出现。 这一点，大脑很难接受，绝大多数人终其一生也看不见心灵世界的出现，根本原因就在这里：大脑太努力了，以为通过大脑的思考和分析就可以进入心灵世界，就可以了解心灵世界，这是缘木求鱼，方向错了，越努力，离目标越远。 进入心灵世界恰恰需要的是不努力，不折腾，进入心灵世界必须抛弃大脑所有的努力，大脑必须彻底休息，彻底安静，不能有一丝念头，因为心灵就是没有大脑的世界。 这是一件让人几乎绝望的事情。但是对于那些去过心灵世界的人来说，却易如反掌，就在当下立即马上可以进入心灵世界。 我见过太多两眼空洞，内心绝望的道士、和尚和那些自称很有修为的修士，他们其实什么也没达成，他们停留在大脑的世界里，没有任何进步，他们困在大脑里，那个突破，没有发生，那个锐变没有发生。他们被困住了，找不到方向，他们继续努力，结果越来越远。 11 大脑不死心灵不现（中） 我父亲死后，家里长辈要求请和尚为父亲念经超度，和尚来了，见到我就跑了，因为我一瞬间就看透他们了，他们是假和尚，他们身上的那个跳跃根本就没有发生。 于是我自己为父亲念经，我为父亲念落地经，何谓落地经，就是处理好父亲生前担心任何事情，而且做得比父亲要求的更好。 心灵与大脑天生就是一对冤家，他们势不两立，心灵就像大海中的隐藏在海水中的岛屿，唯有海水退去，岛屿才会显现，海水就是大脑，岛屿就是心灵。 看得见海水，岛屿就是被淹没状态，岛屿露出来，海水必须退出。 一个消失，另一个才会出现，他们不可能同时出现，大脑至始至终都是一个干扰，大脑越努力，好比海水涨得越高，心灵就越藏得更深。 我走过这一条路，所以我很熟悉这一片海，我知道在某一片海水之下的确存在一个神秘的岛屿。 我们看一则故事，帮助领会： 有一个小沙弥跟随一个师傅修行了好几年，他一直有个怀疑，怀疑心灵世界的存在，因为几乎所有的修行都是针对心灵世界而修炼的，于是，某一天，他终于鼓起勇气问师傅：“师傅，我一直有个怀疑，我不相信有心灵世界的存在，这就是我这几年没有长进的原因，因为我怀疑是否有那么一个叫心灵世界的存在？” 小沙弥有问题很正常，怀疑心灵世界的存在也很正常，毕竟这个所谓的心灵世界看不见，摸不着，所以小沙弥一直很困惑，也因此他一直没有任何突破。 修行绝对是一场信仰的革命，没有信仰、没有绝对的信任是不可能有突破、有锐变的。 就像一颗橡树种子，如果不相信自己可以长成一颗参天大树，他将永远只能是颗种子，只有彻底地信任，然后奋不顾身地投入大地的怀抱，只有这样锐变才会发生，奇迹才会发生，这棵橡树种子终究是可以长成一棵大树的，原来的种子必须死去，新的生命才会开始，这就是两难所在，种子永远看不见自己成为橡树的那一刻，因为在这之前，种子必须死去。 如果在锐变之前自己根本就看不到自己锐变后的那一种状态，又如何勇敢地去行动，所以除了信任没有第二个办法。 上升到心灵层次也是同样的道理，上升到心灵层次，大脑必须死掉，彻底地死掉，否则永远也见不到、体验不到心灵世界的无限美景。 小沙弥一直停留在大脑层面，他的大脑一刻不停都在运转，他在怀疑，怀疑就是大脑的标志。 师傅没有说话，把小沙弥带到一间非常黑暗的房间，告诉小沙弥，房角有一块石头，小沙弥不相信，他说：“师傅，屋子这么黑，我看不见，我不相信角落里有石头。” 师傅点燃一只蜡烛，屋子里立刻光明起来，东边屋角放着一块大大的石头。 很多东西并不是你不相信，他就不存在。相信是大脑的诡计，需要很多的证据，很的多见证人，大脑才愿意相信，而心灵是信任，信任是绝对的接纳，信任是一种跨越，一个跳跃，中间不需要证据和见证人的过渡，是直接融入。 这就是我们上升到心灵世界面临的巨大的困难：我们一直习惯了由大脑主宰我们，我们被大脑统治了很久很久，我们已经变成了大脑的奴隶，我们太依赖我们的大脑了，如果大脑不发出指令，我们根本就不会采取任何行动。 12 大脑不死心灵不现（下） 我们如何翻身变成大脑的主人呢？这太困难了，奴隶翻身做主人，这是一个伟大的颠覆，这不是每一个人都可以实现的颠覆。 我们要清晰地认识到：大脑本身就是一个干扰，一个障碍，只有绕开大脑，才能进入心灵世界。 干掉大脑，让大脑死掉、让大脑休克，让大脑停止一切，心灵立刻就显现了，就这么简单。 去过心灵世界的所有师傅都有一个非常简便的办法帮助后来者干掉大脑：那就是人为地制造混乱、制造荒谬，创造一个完全不合逻辑的契机，让后来者的大脑在某一瞬间短路。 大脑一旦遇到无法思考的事情、一旦遇到不符合逻辑的事情，大脑就会短路，大脑就会休克，在大脑短路和休克的瞬间，心灵会出现，这样我们就可以对心灵世界有一个短暂的瞥见，就像师傅点亮一盏蜡烛一样，当蜡烛点燃的那一瞬间，墙角的石头立刻显现，当大脑短路的那一瞬间，心灵就会立刻显现，虽然很短暂，但是有一个瞥见，这样至少我们有那么一个瞬间真正且感知到：心灵是确实存在的。 我们再看一个故事： 有一个徒弟跟随师父很多年，徒弟很用功，但是没有用，一直没有本质上变化，有一天，天上没有月亮也没有星星，他带着很多问题再一次去师傅的禅房，因为他一直在大脑层面用工，所以有很多问题，心灵层面从来不会有问题，这是一个很显著的标志，心灵层面一切都很清澈透明，一切都非常祥和宁静，心灵不会产生任何问题，只有大脑才会有问题，而且很多。 这个小和尚带着很多问题去找师傅，师傅正在静坐，那么的安详，那么的宁静，徒弟过来了，师傅开口说话了：“外面那么黑，进来吧。” 外面那么黑是一个隐喻，是一个双关语，天上没有月亮也没有星星，当然很黑，同时他是在暗示徒弟，你生活在黑暗中，徒弟一直在黑暗中，一直在无明中挣扎，师傅非常清楚，一个生活在心灵层面的人，师傅一眼就能看出来。 徒弟走进去，他不敢打扰师傅，静静坐在旁边，很久很久，徒弟坐不住了，夜已经很深了，他不想打搅师傅，他起身要离开，师傅再一次说：“外面很黑，我给你点一盏灯吧。” 于是师傅把灯点亮。徒弟刚接过灯，师傅突然把灯吹灭了。 师傅吹灭灯火来得那么突然，来得那么不和情理，这太荒唐了，那一瞬间，徒弟的大脑一定会短路，这不符合逻辑，这简直太不可思议，徒弟无法思考，既然天这么黑，师傅给自己点一盏灯是符合逻辑的，但是点亮灯火后又立即吹灭，这不符合逻辑，脑袋无法承受这荒唐的行为，大脑无法思考这完全不符合逻辑的行为，于是大脑短路了。 就在徒弟的大脑一片空白的瞬间，他见到了另一个世界，这个世界是他一直都在梦寐以求的——心灵世界，只要一个瞥见就足够了，因为他一直在寻找，现在他寻找的就在眼前，他内心所有的怀疑消失了，他顿悟了老师的一片苦心，在那一瞬间，徒弟升华了，那个锐变，那个跳跃发生了，他顿时泪流满面，感激不尽。 制造混乱、制造荒唐一直都是师傅常用的手段。如果你懂，就能立刻领悟无数个看似荒唐不经的禅宗公案，师傅们几乎都用相似的手法。 无论是棒打、吆喝、吐口水，这只是形式上的不同，目的都是一个，让你那该死的大脑短路，哪怕只有一瞬间。 我也曾辛辛苦苦地一路走过来，我也遭遇过师傅的当头棒喝，附注：这个对我当头大喝一个传奇人物，后面有机会我还会提到她。因为我已经辛辛苦苦准备了三五年，那一声大吼来得正是时候。正是师傅的那一声大吼，直接将心灵世界在我面前展开，我直接跳进了心灵世界，我激动得三天没有睡觉，我像个疯子一样浑身发抖，泪流满面，我以自己最直接的体验，可以负责地说：请不要怀疑心灵世界的存在，如果有任何怀疑，那就是大脑进入了干扰状态，大脑一旦介入，一切便前功尽弃，心灵世界永不得见。 因为走过这条路，所以我很清楚，从我们的身体出发，我们会来到我们的精神世界，这个没有问题，大多数人在一生中都可以走到这个世界，而且目前这个精神世界已经非常拥挤，大多数人还在这个精神世界里结婚生子了，他们在精神世界生活的非常惬意，他们以为人生的终点就是那里，遗憾的是，他们错过了人生中更重要的下一站，那就是从精神世界出发，我们终究会到达下一个更加美丽的世界——心灵世界。 心灵世界就是精神世界的一面镜子，精神世界在心灵世界这面清澈的镜子面前，一目了然，心灵世界就是一束光，精神世界在这一束光的照耀下，通体透明，无处可藏。 从心灵世界看人生百态，一切了悟于心，精神世界里所有的苦恼、所有的困惑、所有的纠结只不是人类自己作茧自缚而已。 这就是我一直强调的重点：治疗精神病必须从心灵层面入手的根本原因所在。 从我们的身体出发，我们会来到我们的精神世界，这个没有问题，大多数人在一生中都可以走到这个世界，而且目前这个精神世界已经非常拥挤，大多数人还在这个精神世界里结婚生子了，他们在精神世界生活的非常惬意，他们以为人生的终点就是那里，遗憾的是，他们错过了人生中更重要的下一站，那就是从精神世界出发，我们终究会到达下一个更加美丽的世界——心灵世界。 （完） 推荐大家看下seeker大师兄视频中的介绍：https://www.youtube.com/watch?v=uSQ8PrzrSmk 希望这篇文章能够帮助到您，感恩让我们再此相遇♥","categories":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/categories/Mental/"}],"tags":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/tags/Mental/"}]},{"title":"道家真气","slug":"LING-DaoJiaZhenQi","date":"2023-09-13T09:18:23.000Z","updated":"2023-09-13T09:18:23.000Z","comments":true,"path":"posts/8df76a52/","link":"","permalink":"https://t8840.github.io/posts/8df76a52/","excerpt":"","text":"","categories":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/categories/Mental/"}],"tags":[{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/tags/Mental/"}]},{"title":"RemoteControl","slug":"NET-RemoteControl","date":"2023-09-13T09:12:41.000Z","updated":"2023-09-13T09:12:41.000Z","comments":true,"path":"posts/e7b1adcd/","link":"","permalink":"https://t8840.github.io/posts/e7b1adcd/","excerpt":"","text":"远程控制工具 GotoHTTP GotoHTTP是一款基于https的远控工具。 优势 B2C 模式，无需安装控制端软件，有浏览器就可以远控。 流量走 https 协议，只要目标放行 443 端口出口就可以实现内网穿透。 GoToHTTP安装 官网地址：http://www.gotohttp.com/ 在Linux中运行 123wget http://gotohttp.com/gotohttp_gui_x64.tar.gztar -xvf gotohttp_gui_x64.tar.gzsudo ./gotohttp_gui_x64/gotohttp 如上，我们运行软件得到了控制Linux的id和控制码。 在浏览器输入远程电脑ID及控制码立即开始控制。 这时候，通过浏览器便可以直接控制Linux。 当然，用手机浏览器也是可以连接的。 控制安卓手机 安装手机需要运行，需要adb执行下面命令 adb tcpip 5555 在Windows运行 下载对应的Windows安装包，直接运行即可。连接方式和上面一样。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"网站信息收集","slug":"NET-SiteInfoCollect","date":"2023-09-13T09:07:25.000Z","updated":"2023-09-13T09:07:25.000Z","comments":true,"path":"posts/ef265ae3/","link":"","permalink":"https://t8840.github.io/posts/ef265ae3/","excerpt":"","text":"","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"VPN","slug":"NET-VPN","date":"2023-09-13T09:06:27.000Z","updated":"2023-09-13T09:06:27.000Z","comments":true,"path":"posts/bcafbad3/","link":"","permalink":"https://t8840.github.io/posts/bcafbad3/","excerpt":"","text":"","categories":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/categories/Devops/"}],"tags":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/tags/Devops/"}]},{"title":"Solana","slug":"WEB3-Solana","date":"2023-09-13T08:52:39.000Z","updated":"2023-09-13T08:52:39.000Z","comments":true,"path":"posts/d994c52d/","link":"","permalink":"https://t8840.github.io/posts/d994c52d/","excerpt":"","text":"Solana：面向性能的区块链 Solana 是一个快速、安全和抗审查的区块链，由于其开创性的可扩展性解决方案和创新技术，它在加密社区中引起了很大的关注。本指南深入探讨了 Solana 是什么，为什么它是独一无二的，以及为什么它受到了如此多的关注。 历史和背景 Solana 由 Anatoly Yakovenko 于 2017 年创立。在创建 Solana 之前，Yakovenko 在 Qualcomm 和 Dropbox 工作，这为他提供了优化系统性能的深入见解。认识到现有区块链所面临的可扩展性问题，Yakovenko 试图从零开始设计一个系统，该系统可以在不妥协安全性的情况下处理全球规模的需求。 技术创新 1. 历史证明 (PoH)： Solana 最独特的特点是其新颖的共识机制，称为历史证明。与传统的区块链不同，它要求验证者观察并就交易的顺序达成共识，PoH 允许验证者信任给交易的时间戳，而无需外部确认。这一创新极大地加快了验证过程，减少了节点之间的通信需求。 2. Tower BFT： 基于 PoH，Tower BFT 是 Solana 的自定义共识算法。它受益于 PoH 提供的已建立的时间顺序，快速达成共识并确认交易，使网络更加高效和安全。 3. Turbine： Solana 的数据广播解决方案是 Turbine。它不向所有节点发送完整数据，而是将数据分解成更小的数据包，并使用流协议分发它们，使数据传播效率提高数倍。 4. Gulf Stream： 为了处理交易缓存并将其转发到网络的边缘，Solana 使用了 Gulf Stream。这种机制允许验证者提前执行交易，减少确认时间并增加网络的整体吞吐量。 5. Sealevel： 通过 Sealevel，可以并行智能合约运行时。这允许在同一状态上并发处理交易，是大幅提高吞吐量的革命性方式。 6. Pipeline： 为了优化事务处理单元验证，Pipeline 将事务验证分配给不同的硬件单元进行并行和更快的处理。 代币和生态系统 SOL 是 Solana 的原生加密货币。它用于权益证明、交易费用，并可以在该平台上构建的各种 DeFi 应用程序中使用。 Solana 生态系统一直在快速增长，许多项目选择在其上构建，因为其高吞吐量和低交易成本。这导致了 Solana 上各种 DeFi 平台、NFT 市场和其他分散应用的崛起，进一步推动了其采用和增长。 优势和潜在挑战 优势： 可扩展性： Solana 吹嘘其吞吐量为每秒 65,000 笔交易，使其成为最快的区块链之一。 低费用： 尽管其吞吐量很高，但交易成本仍然很低。 不断增长的生态系统： 越来越多的项目正在 Solana 上建立，这表明了对其基础设施的信任。 潜在挑战： 网络中心化： 一些批评者认为，对高性能硬件的需求可能导致验证者的集中。 年轻的生态系统： 与 Ethereum 这样的成熟链相比，Solana 相对较新，随着其增长，可能会面临无法预见的挑战。 结论 Solana 代表了区块链技术的重大进步，解决了困扰早期代代的可扩展性问题。通过重新构想具有历史证明和 Tower BFT 机制的架构，它提供了一个承诺的未来去中心化应用的平台。然而，像所有技术一样，监控其演变并解决潜在挑战对确保其长期成功至关重要。","categories":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/categories/Web3/"}],"tags":[{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/tags/Web3/"}]},{"title":"Docker","slug":"DEV-Docker","date":"2023-09-13T08:36:26.000Z","updated":"2023-09-13T08:36:26.000Z","comments":true,"path":"posts/f5f9fa9b/","link":"","permalink":"https://t8840.github.io/posts/f5f9fa9b/","excerpt":"","text":"Docker安装 Linux安装 方式一：一键安装脚本 123456789$ sudo wget -qO- https://get.docker.com/ | bash$ # 如果上面的不行，执行下面两句$ curl -fsSL https://get.docker.com -o get-docker.sh$ sudo sh get-docker.sh$ # 安装成功执行下面语句，如果有类似回显，说明安装成功$ docker --versionDocker version 23.0.1, build a5ee5b1 方式二：二进制安装 Mac安装 下载：https://download.docker.com/mac/stable/Docker.dmg 双击安装 增加普通用户Docker权限 参考：https://www.cnblogs.com/lxsky/p/12829864.html root用户新建docker组：groupadd docker 使用普通用户appdeploy执行： 1234567891011121314151617181920sudo gpasswd -a $USER dockernewgrp docker# 没有sudo权限需要按照下面进行配置a. 首先找到文件位置，示例中文件在/etc/sudoers位置。whereis sudoersb.强调内容 修改文件权限，一般文件默认为只读。ls -l /etc/sudoers 查看文件权限chmod -v u+w /etc/sudoers 修改文件权限为可编辑c. 修改文件，在如下位置增加一行，保存退出。vim /etc/sudoers 进入文件编辑器文件内容改变如下：root ALL=(ALL) ALL 已有行appdeploy ALL=(ALL) ALL 新增行d. 记得将文件权限还原回只读。ls -l /etc/sudoers 查看文件权限chmod -v u-w /etc/sudoers 修改文件权限为只读 如果上面没有生效，再重启下docker systemctl daemon-reload systemctl restart docker Docker-Compose安装 方式一：pip3安装 有网络情况： pip3 install docker-compose 无网络情况： 1234# 使用有网络的电脑下载并上传pip3 download -d /root/software/python3.7/pippackage/ docker-compose# 安装pip3 install --no-index --find-links=/root/software/python3.7/pippackage/ docker-compose 方式二: 二进制安装 Linux安装：直接从 https://github.com/docker/compose/releases 找到合适的版本下载docker-compose-Linux-x86_64 接着上传到linux服务器","categories":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/categories/Devops/"}],"tags":[{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/tags/Devops/"}]},{"title":"常用API测试工具","slug":"TEST-ApiTestTools","date":"2023-09-13T08:12:46.000Z","updated":"2023-09-13T08:12:46.000Z","comments":true,"path":"posts/eda31c22/","link":"","permalink":"https://t8840.github.io/posts/eda31c22/","excerpt":"","text":"抓包工具 mitmproxy/anyproxy burpsuite/fiddle/Charles http client工具 request/httpx/aiohttp httprunner Yapi Jmeter APIAuto https://github.com/TommyLemon/APIAuto hoppscotch Open source API development ecosystem https://github.com/hoppscotch/hoppscotch Mock工具 YApi EasyMock HTTPretty https://github.com/gabrielfalcao/HTTPretty 商用工具 Apifox Apifox = Postman + Swagger + Mock + JMeter 文档：https://www.apifox.cn/help Metepheres","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-09-13T06:44:16.114Z","updated":"2023-09-13T06:44:16.116Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://t8840.github.io/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Solidity资料","slug":"WEB3-SolidityTool","date":"2023-03-01T13:22:05.000Z","updated":"2023-03-01T13:22:05.000Z","comments":true,"path":"posts/77571803/","link":"","permalink":"https://t8840.github.io/posts/77571803/","excerpt":"","text":"TOOL Cloud IDE https://beta.solpg.io/ 视频 文字版 项目","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/tags/Solidity/"}]},{"title":"Solidity","slug":"WEB3-Solidity","date":"2023-02-26T14:05:05.000Z","updated":"2023-02-26T14:05:05.000Z","comments":true,"path":"posts/b9a928cc/","link":"","permalink":"https://t8840.github.io/posts/b9a928cc/","excerpt":"","text":"Solidity是一种基于以太坊区块链的智能合约编程语言，它具有类似于JavaScript和C++的语法和特性。 Solidity入门语法 注释 Solidity支持两种注释方式，单行注释和多行注释。单行注释使用//，多行注释使用/* */。 123456// 这是单行注释/*这是多行注释*/ 变量和数据类型 Solidity支持多种数据类型，包括布尔型、整型、地址、字符串和数组等。 布尔型 布尔型表示逻辑值，只有两个可能的值，即true和false。 123bool a = true;bool b = false; 整型 整型表示整数值，可以分为有符号整型和无符号整型。 123int a = 123; // 有符号整型uint b = 456; // 无符号整型 地址 地址类型表示以太坊账户的地址，它是一个20字节的值。 12address a = 0x1234567890123456789012345678901234567890; 字符串 字符串类型表示文本值。 12string a = &quot;Hello World!&quot;; 数组 数组表示具有相同类型的值的有序集合。 123uint[] a = [1, 2, 3];string[] b = [&quot;Hello&quot;, &quot;World&quot;]; 函数 Solidity中的函数可以接受参数和返回值。函数使用function关键字声明，可以指定函数的可见性和修饰符。 1234function add(uint a, uint b) public pure returns (uint) &#123; return a + b;&#125; 上面的代码定义了一个名为add的函数，它接受两个无符号整型参数a和b，返回它们的和。public表示该函数可以被外部调用，pure表示该函数不会读取或修改合约状态。 控制流 Solidity支持条件语句和循环语句。 条件语句 条件语句使用if和else关键字。 12345678uint a = 10;if (a &gt; 5) &#123; // 如果a大于5，执行这里的代码&#125; else &#123; // 否则执行这里的代码&#125; 循环语句 循环语句使用for和while关键字。 123456789101112for (uint i = 0; i &lt; 10; i++) &#123; // 执行10次循环&#125;uint i = 10;while (i &gt; 0) &#123; // 执行10次循环 i--;&#125; 结构体 结构体表示一种自定义数据类型，可以包含多个字段。 1234567struct Person &#123; string name; uint age;&#125;Person p = Person(&quot;Alice&quot;, 20); 上面的代码定义了一个名为Person的结构体，它包含两个字段：name和age。然后我们创建了一个名为p的Person类型的实例。 123456789101112131415161718192021222324252627pragma solidity ^0.8.0;contract Example &#123; struct Person &#123; string name; uint age; bool isAdult; &#125; Person public alice; constructor() &#123; alice.name = &quot;Alice&quot;; alice.age = 30; alice.isAdult = true; &#125; function setAge(uint age) public &#123; alice.age = age; if (age &gt;= 18) &#123; alice.isAdult = true; &#125; else &#123; alice.isAdult = false; &#125; &#125;&#125; 上面的代码定义了一个名为Person的结构体，包含三个字段：name（字符串类型）、age（无符号整数类型）和isAdult（布尔类型）。合约还包含一个名为alice的公共状态变量，其类型为Person，可以用来存储一个人的姓名、年龄和成年状态。合约还定义了一个名为setAge的函数，用于设置alice的年龄，并根据年龄计算其成年状态。 映射 映射表示一种将键映射到值的数据结构。 1234mapping(address =&gt; uint) balances;balances[0x1234567890123456789012345678901234567890] = 100; 上面的代码定义了一个名为balances的映射，它将地址映射到无符号整型。然后我们将地址0x1234567890123456789012345678901234567890的值设置为100。 123456789101112131415pragma solidity ^0.8.0;contract Example &#123; mapping(address =&gt; uint) public balances; function deposit() public payable &#123; balances[msg.sender] += msg.value; &#125; function withdraw(uint amount) public &#123; require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;); payable(msg.sender).transfer(amount); balances[msg.sender] -= amount; &#125;&#125; 上面的代码定义了一个名为balances的映射，将每个地址映射到一个无符号整数值上，表示该地址的余额。合约还定义了两个函数： deposit：允许发送以太币到合约地址，并将其存入发送方的余额中。 withdraw：允许发送方从其余额中取出指定数量的以太币。 在deposit和withdraw函数中，合约使用了msg.sender来引用当前交易的发送方地址，将其余额增加或减少，并使用require函数来确保余额不会变为负数。如果检查失败，函数会抛出一个错误消息，并停止执行。 映射是Solidity中的一项强大功能，可用于创建各种数据结构，如哈希表、关联数组等。在实际开发中，映射通常会更加复杂，并使用更高级的技术来确保其安全性和正确性 事件 Solidity中的事件是一种机制，用于在合约执行期间将通知发送给区块链上的其他应用程序。事件通常用于跟踪合约执行的状态变化，如交易成功或失败，合约状态更改等。 1234567event Transfer(address indexed from, address indexed to, uint value);function transfer(address to, uint value) public returns (bool) &#123; emit Transfer(msg.sender, to, value); return true;&#125; 上面的代码定义了一个名为Transfer的事件，它包含三个参数：from、to和value。然后我们在transfer函数中调用Transfer事件，记录转账操作。 另一个简单的事件示例： 123456789101112pragma solidity ^0.8.0;contract Example &#123; event Transfer(address indexed from, address indexed to, uint amount); function transfer(address to, uint amount) public &#123; require(amount &gt; 0, &quot;Amount must be greater than zero&quot;); require(msg.sender.balance &gt;= amount, &quot;Insufficient balance&quot;); payable(to).transfer(amount); emit Transfer(msg.sender, to, amount); &#125;&#125; 上面的代码定义了一个名为Transfer的事件，它有三个参数：from（地址类型，表示发送方地址）、to（地址类型，表示接收方地址）和amount（无符号整数类型，表示转账金额）。合约还定义了一个名为transfer的函数，用于从当前发送方地址向指定地址转移指定数量的以太币，并触发Transfer事件以通知其他应用程序。 在调用transfer函数时，合约会检查发送方余额是否足够，如果足够，则转移以太币并触发事件。其他应用程序可以监听Transfer事件，并根据其参数值更新其状态或执行其他操作。 事件是Solidity中的一项强大功能，可用于在合约执行期间与其他应用程序进行通信，如向前端Web应用程序发送通知、向后端服务器发送数据等。在实际开发中，事件通常会更加复杂，并使用更高级的技术来确保其安全性和正确性。 Solidity高级语法 模块化 Solidity支持模块化，即将合约拆分为多个文件，每个文件可以包含一个或多个合约。 导入文件 在Solidity中，可以使用import关键字导入其他文件中定义的合约。 123456import &quot;./MyContract.sol&quot;;contract AnotherContract &#123; MyContract c = MyContract(0x1234567890123456789012345678901234567890);&#125; 上面的代码从文件MyContract.sol中导入了名为MyContract的合约，然后我们在AnotherContract合约中创建了一个MyContract类型的实例。 继承 Solidity支持合约的继承，即一个合约可以从另一个合约继承其状态变量和函数。 1234567891011121314contract ParentContract &#123; uint public a = 123; function foo() public pure returns (uint) &#123; return 456; &#125;&#125;contract ChildContract is ParentContract &#123; function bar() public view returns (uint) &#123; return a + foo(); &#125;&#125; 上面的代码定义了两个合约，ParentContract和ChildContract。ChildContract继承了ParentContract的状态变量a和函数foo。 抽象合约 在Solidity中，抽象合约是一种不能直接实例化的合约，它只提供了一组接口（函数签名），而没有实现任何功能。抽象合约可以被认为是一个纯虚基类，只定义了一些需要被实现的方法。 抽象合约通常用于定义通用的接口，以便其他合约可以继承它并实现接口中定义的方法。这使得合约更易于模块化，并使代码更加可读和易于维护。 以下是一个简单的抽象合约示例： 1234567pragma solidity ^0.8.0;abstract contract PaymentGateway &#123; function deposit(uint amount) public virtual; function withdraw(uint amount) public virtual;&#125; 上面的代码定义了一个名为PaymentGateway的抽象合约，它有两个函数接口：deposit和withdraw。这个合约不能被直接实例化，但可以被其他合约继承并实现这些接口。 以下是一个继承了PaymentGateway抽象合约并实现了其接口的示例合约： 123456789101112131415161718192021pragma solidity ^0.8.0;contract Bank is PaymentGateway &#123; mapping(address =&gt; uint) private balances; function deposit(uint amount) public override &#123; require(amount &gt; 0, &quot;Amount must be greater than zero&quot;); balances[msg.sender] += amount; &#125; function withdraw(uint amount) public override &#123; require(balances[msg.sender] &gt;= amount, &quot;Insufficient balance&quot;); balances[msg.sender] -= amount; payable(msg.sender).transfer(amount); &#125; function getBalance() public view returns (uint) &#123; return balances[msg.sender]; &#125;&#125; 上面的代码定义了一个名为Bank的合约，它继承了PaymentGateway抽象合约，并实现了其中定义的接口。Bank合约还定义了一个名为getBalance的函数，用于返回调用方的余额。 抽象合约是Solidity中的一个重要概念，它使得代码更加模块化和可重用。在实际开发中，可以使用抽象合约来定义通用的接口，并让其他合约继承它并实现这些接口，从而大大简化代码的开发和维护。 接口 Solidity支持接口，即仅定义函数签名而不提供实现的抽象合约。接口可以被其他合约实现。 12345678910interface MyInterface &#123; function foo() external returns (uint);&#125;contract MyContract is MyInterface &#123; function foo() public override returns (uint) &#123; return 123; &#125;&#125; 上面的代码定义了一个名为MyInterface的接口，它包含一个名为foo的函数。然后我们在MyContract合约中实现了foo函数。 消息 Solidity中有一些特殊的变量，它们称为“消息变量”，包含有关当前交易的信息。 msg.sender：当前交易的发送方地址。 msg.value：当前交易中发送的以太币数量。 msg.data：当前交易中传递的数据。 msg.sig：当前交易中函数调用的签名。 内联汇编 Solidity支持内联汇编，即在Solidity代码中直接嵌入汇编代码。 12345678function getGasPrice() public view returns (uint) &#123; uint gasPrice; assembly &#123; gasPrice := tx.gasprice &#125; return gasPrice;&#125; 上面的代码使用内联汇编获取当前交易的Gas价格。 安全性 Solidity是一门高度安全的编程语言，旨在防止智能合约中的漏洞。以下是Solidity中常用的安全性特性： 访问控制：Solidity提供了modifier关键字，用于在函数执行前检查某个条件是否满足。 溢出和下溢：Solidity提供了安全的数学库SafeMath，用于执行加、减、乘、除等操作时检查是否存在溢出或下溢。 资源管理：Solidity中的状态变量和存储变量有不同的访问权限，防止恶意合约访问和修改合约状态。 防重入攻击：Solidity提供了nonReentrant修饰符，用于防止合约被重复调用，从而避免恶意合约攻击。 示例合约 以下是一个简单的Solidity合约，它模拟了一个简单的银行账户系统，支持存款、取款和查询余额功能。 12345678910111213141516171819202122232425pragma solidity ^0.8.0;contract Bank &#123; mapping(address =&gt; uint) balances; event Deposit(address indexed from, uint value); event Withdrawal(address indexed to, uint value); function deposit() public payable &#123; require(msg.value &gt; 0, &quot;Deposit amount must be greater than 0&quot;); balances[msg.sender] += msg.value; emit Deposit(msg.sender, msg.value); &#125; function withdraw(uint amount) public &#123; require(amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;); require(amount &lt;= balances[msg.sender], &quot;Insufficient balance&quot;); balances[msg.sender] -= amount; payable(msg.sender).transfer(amount); emit Withdrawal(msg.sender, amount); &#125; function balanceOf(address account) public view returns (uint) &#123; return balances[account]; &#125; 上面的代码定义了一个名为Bank的合约，它包含一个名为balances的映射，用于存储每个地址的余额。合约还定义了三个函数： deposit：允许发送以太币到合约地址，并将其存入发送方的余额中。 withdraw：允许发送方从其余额中取出指定数量的以太币。 balanceOf：允许查询指定地址的余额。 合约还使用了事件Deposit和Withdrawal，用于记录每个存款和取款操作的发起方和数量。 这只是一个简单的示例合约，但它涵盖了Solidity中许多基本概念和语法。在实际开发中，合约通常会更加复杂，需要更高级的语法和技术来确保其安全性和正确性。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/tags/Solidity/"}]},{"title":"测试","slug":"Test","date":"2023-02-26T14:04:00.000Z","updated":"2023-02-26T14:04:00.000Z","comments":true,"path":"posts/9daba997/","link":"","permalink":"https://t8840.github.io/posts/9daba997/","excerpt":"","text":"测试","categories":[{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"}]},{"title":"Python入门","slug":"Python","date":"2023-02-26T14:02:52.000Z","updated":"2023-02-26T14:02:52.000Z","comments":true,"path":"posts/d9ef328/","link":"","permalink":"https://t8840.github.io/posts/d9ef328/","excerpt":"","text":"Python是一种高级、解释型的编程语言，广泛用于Web开发、数据科学、人工智能、自动化等各个领域。下面分别介绍Python的入门和高级语法。 Python基础语法介绍 变量和数据类型 在Python中，可以使用变量来存储值，并且不需要提前声明变量类型。Python支持多种数据类型，包括整数、浮点数、布尔值、字符串、列表、元组、字典等。 以下是一些变量和数据类型的示例： 1234567891011121314151617181920212223# 整数类型x = 5y = -10# 浮点数类型z = 3.14# 布尔值类型a = Trueb = False# 字符串类型c = &quot;Hello, World!&quot;# 列表类型d = [1, 2, 3, 4, 5]# 元组类型e = (1, 2, 3)# 字典类型f = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30&#125; 字节字符串 在 Python 中，b&quot;Hello, world!&quot; 是一个字节字符串的表示方式。 在 Python 3 中，字符串有两种类型：文本字符串（str）和字节字符串（bytes）。 文本字符串用于表示文本数据，而字节字符串用于表示原始的字节数据。 b&quot;Hello, world!&quot; 使用 b 前缀来表示一个字节字符串。它表示由 ASCII 字符组成的字节序列，每个字符都用一个字节表示。 字节字符串是在处理二进制数据、网络通信、文件操作等场景中常用的数据类型。通过使用字节字符串，可以确保数据以原始字节的形式进行处理，而不会进行任何编码或字符集转换。 在特定的上下文中，data = b&quot;Hello, world!&quot; 将字符串 “Hello, world!” 转换为字节字符串，并将其赋值给变量 data。这样，变量 data 将持有这个字节字符串，可以在后续的代码中使用。 文本字符串与字节字符串的转化 在 Python 中，文本字符串（str）使用 Unicode 编码来表示和处理。Unicode 是一种字符集，它为世界上几乎所有的字符分配了唯一的标识符，包括各种语言的字符、符号、表情符号等。 在计算机内部存储文本字符串时，Python 使用一种称为 UTF-8 的编码方案。UTF-8 是一种可变长度的编码方式，它使用不同长度的字节序列来表示 Unicode 字符，根据字符的不同而变化。 UTF-8 编码的特点是： ASCII 字符（U+0000 至 U+007F）使用单个字节表示，与 ASCII 编码兼容。 非 ASCII 字符使用多个字节表示，具体的字节数取决于字符的 Unicode 值。 当文本字符串被存储在计算机内存中时，它们以字节序列的形式存在。Python 解释器会根据使用的编码（如 UTF-8）将文本字符串转换为相应的字节序列。 在进行文本字符串的处理和操作时，Python 解释器会根据编码规则进行相应的解码和编码操作。这样，Python 可以正确地处理不同语言的字符，并提供字符串的各种操作和方法。 12345678910# 定义文本字符串text = &quot;Hello, world!&quot;# 将文本字符串转换为字节字符串byte_string = text.encode(&quot;utf-8&quot;)# print(byte_string) # b&#x27;Hello, world!&#x27;# 打印字节字符串的二进制表示# format(byte, &quot;08b&quot;)：对于每个字节 byte，使用 format() 函数将其格式化为一个 8 位的二进制字符串。其中，&quot;08b&quot; 表示使用 8 位（补零至 8 位）的二进制表示binary_representation = &quot; &quot;.join(format(byte, &quot;08b&quot;) for byte in byte_string)print(binary_representation) # 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001 运算符 Python支持多种运算符，包括算术运算符、比较运算符、逻辑运算符、位运算符等。以下是一些运算符的示例： 1234567891011121314151617181920212223242526272829# 算术运算符x = 5 + 3y = 5 - 3z = 5 * 3a = 5 / 3b = 5 % 3c = 5 ** 3# 比较运算符d = 5 == 3e = 5 != 3f = 5 &gt; 3g = 5 &lt; 3h = 5 &gt;= 3i = 5 &lt;= 3# 逻辑运算符j = True and Falsek = True or Falsel = not True# 位运算符m = 5 &amp; 3n = 5 | 3o = 5 ^ 3p = ~5q = 5 &lt;&lt; 3r = 5 &gt;&gt; 3 控制流语句 Python支持多种控制流语句，包括if语句、for循环、while循环等。以下是一些控制流语句的示例： 12345678910111213141516171819202122232425262728293031# if语句x = 5if x &gt; 0: print(&quot;x is positive&quot;)elif x &lt; 0: print(&quot;x is negative&quot;)else: print(&quot;x is zero&quot;)# for循环y = [1, 2, 3, 4, 5]for i in y: print(i)# while循环z = 1while z &lt;= 10: print(z) z += 1``` ### 函数在Python中，可以使用def语句定义函数。函数可以接受参数并返回值。以下是一个函数的示例：```pythondef add(x, y): return x + yresult = add(5, 3)print(result) # 输出8 模块和包 Python中的模块是一个包含Python定义和语句的文件，可以通过import语句导入。Python中的包是一个包含多个模块的目录。 以下是一个模块和包的示例： 12345678910111213141516171819# 模块# mymodule.pydef greeting(name): print(&quot;Hello, &quot; + name)# 使用模块import mymodulemymodule.greeting(&quot;Alice&quot;) # 输出Hello, Alice# 包# mypackage/mymodule.pydef add(x, y): return x + y# 使用包from mypackage import mymoduleresult = mymodule.add(5, 3)print(result) # 输出8 Python高级语法介绍 迭代器和生成器 Python中的迭代器是一个可以迭代访问的对象，例如列表、元组、字典等。Python中的生成器是一种更加高效的迭代器，使用yield语句生成值。 以下是一个迭代器和生成器的示例： 1234567891011121314151617181920212223242526272829303132333435363738# 迭代器my_list = [1, 2, 3, 4, 5]my_iterator = iter(my_list)print(next(my_iterator)) # 输出1print(next(my_iterator)) # 输出2print(next(my_iterator)) # 输出3# 生成器def my_generator(): yield 1 yield 2 yield 3for i in my_generator(): print(i) # 输出1, 2, 3``` ### 装饰器Python中的装饰器是一种用于修改函数或类的行为的语法。装饰器本质上是一个函数，可以在不修改原函数或类的情况下修改其行为。以下是一个装饰器的示例：```python# 装饰器def my_decorator(func): def wrapper(): print(&quot;Before the function is called.&quot;) func() print(&quot;After the function is called.&quot;) return wrapper@my_decoratordef my_function(): print(&quot;Hello, World!&quot;)my_function() # 输出Before the function is called. Hello, World! After the function is called. 异常处理 在Python中，可以使用try语句和except语句来处理异常。当程序出现异常时，Python会跳转到最近的except语句，并执行其中的代码。 以下是一个异常处理的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 异常处理try: x = 5 / 0except ZeroDivisionError: print(&quot;Error: division by zero&quot;)``` ### 多线程和多进程在Python中，可以使用多线程和多进程来实现并发编程。多线程是指在一个程序中同时执行多个线程，多进程是指在一个程序中同时运行多个进程。以下是一个多线程和多进程的示例：```python# 多线程import threadingdef print_numbers(): for i in range(10): print(i)def print_letters(): for letter in &quot;abcdefghij&quot;: print(letter)thread1 = threading.Thread(target=print_numbers)thread2 = threading.Thread(target=print_letters)thread1.start()thread2.start()# 多进程import multiprocessingdef square(number): return number ** 2if __name__ == &#x27;__main__&#x27;: pool = multiprocessing.Pool(processes=4) results = pool.map(square, [1, 2, 3, 4, 5]) print(results) # 输出[1, 4, 9, 16, 25]``` ### 类和面向对象编程Python是一种面向对象编程语言，支持类和对象的概念。可以使用class语句来定义类，使用对象来访问类中的属性和方法。以下是一个类和面向对象编程的示例：```python# 类和面向对象编程class Person: def __init__(self, name, age): self.name = name self.age = age def greet(self): print(&quot;Hello, my name is &quot; + self.name + &quot; and I am &quot; + str(self.age) + &quot; years old.&quot;)person1 = Person(&quot;Alice&quot;, 25)person1.greet() # 输出Hello, my name is Alice and I am 25 years old. Lambda函数 Lambda函数是一种匿名函数，可以使用lambda关键字定义。Lambda函数通常用于简单的操作，例如对列表进行排序或筛选。 以下是一个Lambda函数的示例： 123456789# Lambda函数numbers = [1, 2, 3, 4, 5]squared_numbers = list(map(lambda x: x ** 2, numbers))print(squared_numbers) # 输出[1, 4, 9, 16, 25]even_numbers = list(filter(lambda x: x % 2 == 0, numbers))print(even_numbers) # 输出[2, 4] 生成式 Python中的生成式是一种用于生成列表、集合或字典的简便语法。生成式通常比使用循环来生成相同的结果更加简洁和可读。 以下是一个生成式的示例： 12345678910# 生成式numbers = [1, 2, 3, 4, 5]squared_numbers = [x ** 2 for x in numbers]print(squared_numbers) # 输出[1, 4, 9, 16, 25]even_numbers = [x for x in numbers if x % 2 == 0]print(even_numbers) # 输出[2, 4] 对象 Python对象分为几种： 类对象（定义） 实例对象 deepcopy 在Python中，深拷贝（deep copy）和浅拷贝（shallow copy）是用于复制对象的两种不同方式。 浅拷贝（shallow copy）是创建一个新的对象，该对象与原始对象共享内部对象的引用。换句话说，它只复制了对象的引用，而不是创建对象的副本。当对其中一个对象进行修改时，另一个对象也会受到影响。 深拷贝（deep copy）是创建一个全新的对象，并递归复制原始对象及其内部所有对象。它创建了原始对象及其所有内部对象的独立副本。因此，对其中一个对象进行修改不会影响另一个对象。 在Python中，可以使用以下方式实现深拷贝和浅拷贝： 1234567891011import copy# shallow copynew_list = copy.copy(original_list) # 浅拷贝列表new_dict = copy.copy(original_dict) # 浅拷贝字典new_set = copy.copy(original_set) # 浅拷贝集合# deep copynew_list = copy.deepcopy(original_list) # 深拷贝列表new_dict = copy.deepcopy(original_dict) # 深拷贝字典new_set = copy.deepcopy(original_set) # 深拷贝集合 需要注意的是，深拷贝和浅拷贝的适用场景取决于您的需求。如果对象内部没有可变对象（如列表、字典等），并且您希望对其中一个对象的修改不会影响到另一个对象，那么浅拷贝就足够了。但如果对象内部包含了可变对象，并且您希望对其中一个对象的修改不影响到另一个对象，那么深拷贝是更安全和可靠的选择。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/tags/Python/"}]},{"title":"Go入门","slug":"Go","date":"2023-02-26T13:54:26.000Z","updated":"2023-02-26T13:54:26.000Z","comments":true,"path":"posts/3e80a85d/","link":"","permalink":"https://t8840.github.io/posts/3e80a85d/","excerpt":"","text":"Go语言基础语法介绍 安装和环境配置 首先，你需要下载并安装Go语言环境。可以从官方网站（https://golang.org/dl/）上下载并安装，安装完成后设置环境变量，使其可被命令行使用。 Go语言的Hello World程序如下： 12345678package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 这个程序包含了一个main函数，该函数调用了fmt包的Println函数，将&quot;Hello, World!&quot;打印到控制台。 变量和类型 Go语言是一种静态类型的语言，也就是说变量的类型在编译时就确定了。Go语言有多种基本数据类型，包括bool、int、float、string等，同时还有结构体和数组等复合类型。 变量可以使用var关键字来声明，例如： 12var i inti = 42 可以使用:=语法来简化变量声明和赋值的过程： 1i := 42 控制流语句 Go语言的控制流语句包括if、for、switch和select等。 if语句的语法如下： 1234567if condition &#123; // do something&#125; else if condition &#123; // do something else&#125; else &#123; // do something else&#125; for语句可以用来循环执行一段代码，语法如下： 123for initialization; condition; post &#123; // do something&#125; switch语句可以根据某个表达式的值进行多个分支选择，语法如下： 12345678switch expression &#123;case value1: // do somethingcase value2: // do something elsedefault: // do something else&#125; 函数和方法 Go语言中函数和方法是非常重要的概念。函数是一组指定输入和输出的代码，可以独立地调用。方法是与特定类型相关联的函数。 函数的语法如下： 1234func functionName(parameter1 type, parameter2 type) returnType &#123; // do something return someValue&#125; 方法的语法如下： 12345func (receiverType) methodName(parameter1 type, parameter2 type) returnType &#123; // do something return someValue&#125; 数组和切片 Go语言中的数组是一种固定长度的数据结构，定义一个数组的语法如下： 1var arr [5]int 切片是一种动态长度的数据结构，它可以根据需要自动扩容。定义一个切片的语法如下： 1var slice []int 结构体和指针 Go语言中的结构体是一种自定义类型，可以包含多个字段，定义一个结构体的语法如下： 1234type Person struct &#123;Name stringAge int&#125; 基本的结构体示例 12345678910111213141516171819202122232425type Person struct &#123; name string age int&#125;func main() &#123; p := Person&#123;name: &quot;Alice&quot;, age: 30&#125; fmt.Println(p)&#125;在上面的示例中，我们定义了一个名为Person的结构体，包含name和age两个字段。然后我们创建了一个Person类型的变量p，并为其赋值，最后打印p。2. 匿名结构体示例```gofunc main() &#123; p := struct &#123; name string age int &#125;&#123; name: &quot;Alice&quot;, age: 30, &#125; fmt.Println(p)&#125; 在上面的示例中，我们定义了一个匿名结构体，并为其赋值，最后打印该结构体。 嵌套结构体示例 12345678910111213141516171819202122232425type Address struct &#123; street string city string country string&#125;type Person struct &#123; name string age int address Address&#125;func main() &#123; p := Person&#123; name: &quot;Alice&quot;, age: 30, address: Address&#123; street: &quot;Main St&quot;, city: &quot;New York&quot;, country: &quot;USA&quot;, &#125;, &#125; fmt.Println(p)&#125; 在上面的示例中，我们定义了一个名为Address的结构体，包含street、city和country三个字段。然后我们定义了一个名为Person的结构体，包含name、age和address三个字段，其中address字段类型为Address。然后我们创建了一个Person类型的变量p，并为其赋值，其中address字段又包含了一个Address类型的值。最后打印p。 匿名字段结构体示例 1234567891011type Person struct &#123; string int&#125;func main() &#123; p := Person&#123;&quot;Alice&quot;, 30&#125; fmt.Println(p) fmt.Println(p.string)&#125; 在上面的示例中，我们定义了一个名为Person的结构体，包含两个匿名字段，分别为string和int类型。然后我们创建了一个Person类型的变量p，并为其赋值。我们可以通过.访问匿名字段的值，例如p.string表示访问string字段的值。最后打印p和p.string。 指针是一种特殊的变量类型，它存储了一个变量的内存地址，可以使用&amp;符号来获取一个变量的地址，使用*符号来获取指针所指向的值。例如： 1234var i intvar p *intp = &amp;i*i = 42 并发和并行 Go语言是一种天生支持并发和并行的语言。 Go语言中的goroutine是一种轻量级的线程，可以在同一个进程中同时运行多个goroutine。 Go语言中的channel是一种可以在不同goroutine之间进行通信的机制。 错误处理 Go语言中的错误处理非常重要。Go语言中的函数通常会返回一个错误值，如果函数执行过程中出现了错误，就会返回一个非空的错误值。可以使用if语句来检查是否出现了错误。 包和模块 Go语言中的包是一种组织代码的机制，一个包可以包含多个文件。包可以使用import语句来导入其他包中的代码。Go语言中的模块是一种用来管理代码版本和依赖关系的机制，可以使用go mod命令来管理模块。 Go语言高级语法介绍 接口和多态 Go语言中的接口是一种约束，可以指定一个类型需要实现哪些方法。可以使用接口来实现多态。例如： 12345678910111213141516171819202122type Animal interface &#123;Speak() string&#125;type Dog struct &#123;&#125;func (d Dog) Speak() string &#123;return &quot;Woof!&quot;&#125;type Cat struct &#123;&#125;func (c Cat) Speak() string &#123;return &quot;Meow!&quot;&#125;func main() &#123;animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;&#125;for _, animal := range animals &#123;fmt.Println(animal.Speak())&#125;&#125; 在这个例子中，Dog和Cat都实现了Animal接口的Speak方法，所以它们都可以存储在Animal类型的切片中。 反射 Go语言中的反射机制可以让程序在运行时动态地获取类型信息和调用方法。反射可以让程序更加灵活，但也会带来一些性能损失。例如： 1234567func main() &#123;var x float64 = 3.14v := reflect.ValueOf(x)fmt.Println(&quot;type:&quot;, v.Type())fmt.Println(&quot;value:&quot;, v.Float())&#125; 在这个例子中，reflect.ValueOf函数可以获取变量x的反射对象，可以使用Type方法获取x的类型信息，使用Float方法获取x的值。 并发编程 Go语言的并发编程非常强大，可以使用goroutine和channel来实现。例如： goroutine示例 goroutine是Go语言中的轻量级线程，可以在一个程序中同时运行多个goroutine。使用goroutine可以轻松地实现并发执行的任务，而无需显式地管理线程或协程。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;time&quot;)func printNumbers() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Println(i) time.Sleep(1 * time.Second) &#125;&#125;func main() &#123; go printNumbers() // 启动一个goroutine fmt.Println(&quot;Main function execution&quot;) time.Sleep(6 * time.Second) // 主函数等待6秒钟&#125; 在上面的示例中，printNumbers()函数被启动为一个goroutine，同时main()函数继续执行，因此可以看到输出交错进行。 channel示例 channel是Go语言中用于goroutine之间通信的机制。channel是一个类型化的管道，可以通过它发送和接收值。channel的发送和接收操作都是阻塞的，这使得goroutine可以安全地通信。 示例： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)func producer(c chan&lt;- int) &#123; for i := 1; i &lt;= 5; i++ &#123; c &lt;- i // 发送数据到channel &#125; close(c) // 关闭channel&#125;func consumer(c &lt;-chan int) &#123; for i := range c &#123; // 循环从channel中接收数据 fmt.Println(i) &#125;&#125;func main() &#123; c := make(chan int) // 创建一个channel go producer(c) // 启动一个生产者goroutine consumer(c) // 消费者从channel中接收数据&#125; 在上面的示例中，producer()函数将1到5的整数发送到channel中，然后关闭channel。consumer()函数从channel中接收数据并将其打印出来。注意到在main()函数中没有显式地等待生产者和消费者的执行，但是由于channel是阻塞的，因此它们的执行顺序是正确的。 匿名函数和闭包 Go语言支持匿名函数和闭包，这使得代码更简洁、易于阅读和维护。闭包是一个函数值，它引用了函数体外部的变量。 示例： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; x := 10 func() &#123; fmt.Println(&quot;x =&quot;, x) // 匿名函数引用外部变量 x &#125;()&#125; defer语句 defer语句可以用于在函数返回前执行某些代码。defer语句通常用于清理资源或解锁锁定的资源。 示例： 123456789package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) // 在函数返回前执行 fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125; 接口 Go语言的接口使得代码更具可扩展性和可复用性。接口是一种类型，定义了一组方法，任何实现了这些方法的类型都可以作为该接口的实例。 示例： 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;type Shape interface &#123; Area() float64 Perimeter() float64&#125;type Rectangle struct &#123; width float64 height float64&#125;func (r Rectangle) Area() float64 &#123; return r.width * r.height&#125;func (r Rectangle) Perimeter() float64 &#123; return 2*r.width + 2*r.height&#125;func main() &#123; var s Shape = Rectangle&#123;width: 10, height: 20&#125; fmt.Println(&quot;Area:&quot;, s.Area()) fmt.Println(&quot;Perimeter:&quot;, s.Perimeter())&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://t8840.github.io/tags/Go/"}]}],"categories":[{"name":"WEB3","slug":"WEB3","permalink":"https://t8840.github.io/categories/WEB3/"},{"name":"测试开发","slug":"测试开发","permalink":"https://t8840.github.io/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"},{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/categories/InfoCollect/"},{"name":"TOOL","slug":"TOOL","permalink":"https://t8840.github.io/categories/TOOL/"},{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/categories/Python/"},{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/categories/Mental/"},{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/categories/Web3/"},{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/categories/Devops/"},{"name":"JS","slug":"JS","permalink":"https://t8840.github.io/categories/JS/"},{"name":"Trade","slug":"Trade","permalink":"https://t8840.github.io/categories/Trade/"},{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"编程语言","slug":"编程语言","permalink":"https://t8840.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Solana","slug":"Solana","permalink":"https://t8840.github.io/tags/Solana/"},{"name":"WEB3","slug":"WEB3","permalink":"https://t8840.github.io/tags/WEB3/"},{"name":"Test","slug":"Test","permalink":"https://t8840.github.io/tags/Test/"},{"name":"InfoCollect","slug":"InfoCollect","permalink":"https://t8840.github.io/tags/InfoCollect/"},{"name":"TOOL TEST","slug":"TOOL-TEST","permalink":"https://t8840.github.io/tags/TOOL-TEST/"},{"name":"Python","slug":"Python","permalink":"https://t8840.github.io/tags/Python/"},{"name":"TOOL","slug":"TOOL","permalink":"https://t8840.github.io/tags/TOOL/"},{"name":"Mental","slug":"Mental","permalink":"https://t8840.github.io/tags/Mental/"},{"name":"Web3","slug":"Web3","permalink":"https://t8840.github.io/tags/Web3/"},{"name":"Devops","slug":"Devops","permalink":"https://t8840.github.io/tags/Devops/"},{"name":"JS","slug":"JS","permalink":"https://t8840.github.io/tags/JS/"},{"name":"Trade","slug":"Trade","permalink":"https://t8840.github.io/tags/Trade/"},{"name":"网络安全","slug":"网络安全","permalink":"https://t8840.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Solidity","slug":"Solidity","permalink":"https://t8840.github.io/tags/Solidity/"},{"name":"Go","slug":"Go","permalink":"https://t8840.github.io/tags/Go/"}]}